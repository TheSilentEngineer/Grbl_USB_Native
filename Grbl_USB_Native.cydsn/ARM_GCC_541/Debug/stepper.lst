ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"stepper.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	sys_position,12,4
  20              		.comm	sys_probe_position,12,4
  21              		.comm	sys_probe_state,1,1
  22              		.comm	sys_rt_exec_state,1,1
  23              		.comm	sys_rt_exec_alarm,1,1
  24              		.comm	sys_rt_exec_motion_override,1,1
  25              		.comm	sys_rt_exec_accessory_override,1,1
  26              		.bss
  27              		.align	2
  28              	st_block_buffer:
  29 0000 00000000 		.space	100
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.align	2
  31              	segment_buffer:
  32 0064 00000000 		.space	48
  32      00000000 
  32      00000000 
  32      00000000 
  32      00000000 
  33              		.align	2
  34              	st:
  35 0094 00000000 		.space	40
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              	segment_buffer_tail:
  37 00bc 00       		.space	1
  38              	segment_buffer_head:
  39 00bd 00       		.space	1
  40              	segment_next_head:
  41 00be 00       		.space	1
  42              	step_port_invert_mask:
  43 00bf 00       		.space	1
  44              	dir_port_invert_mask:
  45 00c0 00       		.space	1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 2


  46              	busy:
  47 00c1 00       		.space	1
  48 00c2 0000     		.align	2
  49              	pl_block:
  50 00c4 00000000 		.space	4
  51              		.align	2
  52              	st_prep_block:
  53 00c8 00000000 		.space	4
  54              		.align	2
  55              	prep:
  56 00cc 00000000 		.space	56
  56      00000000 
  56      00000000 
  56      00000000 
  56      00000000 
  57              		.section	.text.st_wake_up,"ax",%progbits
  58              		.align	2
  59              		.global	st_wake_up
  60              		.thumb
  61              		.thumb_func
  62              		.type	st_wake_up, %function
  63              	st_wake_up:
  64              	.LFB64:
  65              		.file 1 "stepper.c"
   1:stepper.c     **** /*
   2:stepper.c     ****   stepper.c - stepper motor driver: executes motion plans using stepper motors
   3:stepper.c     ****   Part of Grbl
   4:stepper.c     **** 
   5:stepper.c     ****   Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
   6:stepper.c     ****   Copyright (c) 2009-2011 Simen Svale Skogsrud
   7:stepper.c     ****       Updated For PSOC BJD 2017
   8:stepper.c     **** 
   9:stepper.c     ****   Grbl is free software: you can redistribute it and/or modify
  10:stepper.c     ****   it under the terms of the GNU General Public License as published by
  11:stepper.c     ****   the Free Software Foundation, either version 3 of the License, or
  12:stepper.c     ****   (at your option) any later version.
  13:stepper.c     **** 
  14:stepper.c     ****   Grbl is distributed in the hope that it will be useful,
  15:stepper.c     ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:stepper.c     ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:stepper.c     ****   GNU General Public License for more details.
  18:stepper.c     **** 
  19:stepper.c     ****   You should have received a copy of the GNU General Public License
  20:stepper.c     ****   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  21:stepper.c     **** */
  22:stepper.c     **** 
  23:stepper.c     **** #include "grbl.h"
  24:stepper.c     **** #include <math.h>
  25:stepper.c     **** 
  26:stepper.c     **** 
  27:stepper.c     **** // Some useful constants.
  28:stepper.c     **** #define DT_SEGMENT (1.0/(ACCELERATION_TICKS_PER_SECOND*60.0)) // min/segment
  29:stepper.c     **** #define REQ_MM_INCREMENT_SCALAR 1.25
  30:stepper.c     **** #define RAMP_ACCEL 0
  31:stepper.c     **** #define RAMP_CRUISE 1
  32:stepper.c     **** #define RAMP_DECEL 2
  33:stepper.c     **** #define RAMP_DECEL_OVERRIDE 3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 3


  34:stepper.c     **** 
  35:stepper.c     **** #define PREP_FLAG_RECALCULATE bit(0)
  36:stepper.c     **** #define PREP_FLAG_HOLD_PARTIAL_BLOCK bit(1)
  37:stepper.c     **** #define PREP_FLAG_PARKING bit(2)
  38:stepper.c     **** #define PREP_FLAG_DECEL_OVERRIDE bit(3)
  39:stepper.c     **** 
  40:stepper.c     **** // Define Adaptive Multi-Axis Step-Smoothing(AMASS) levels and cutoff frequencies. The highest leve
  41:stepper.c     **** // frequency bin starts at 0Hz and ends at its cutoff frequency. The next lower level frequency bin
  42:stepper.c     **** // starts at the next higher cutoff frequency, and so on. The cutoff frequencies for each level mus
  43:stepper.c     **** // be considered carefully against how much it over-drives the stepper ISR, the accuracy of the 16-
  44:stepper.c     **** // timer, and the CPU overhead. Level 0 (no AMASS, normal operation) frequency bin starts at the
  45:stepper.c     **** // Level 1 cutoff frequency and up to as fast as the CPU allows (over 30kHz in limited testing).
  46:stepper.c     **** // NOTE: AMASS cutoff frequency multiplied by ISR overdrive factor must not exceed maximum step fre
  47:stepper.c     **** // NOTE: Current settings are set to overdrive the ISR to no more than 16kHz, balancing CPU overhea
  48:stepper.c     **** // and timer accuracy.  Do not alter these settings unless you know what you are doing.
  49:stepper.c     **** #define MAX_AMASS_LEVEL 3
  50:stepper.c     **** // AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff fre
  51:stepper.c     **** #define AMASS_LEVEL1 (F_CPU/8000) // Over-drives ISR (x2). Defined as F_CPU/(Cutoff frequency in Hz
  52:stepper.c     **** #define AMASS_LEVEL2 (F_CPU/4000) // Over-drives ISR (x4)
  53:stepper.c     **** #define AMASS_LEVEL3 (F_CPU/2000) // Over-drives ISR (x8)
  54:stepper.c     **** 
  55:stepper.c     **** 
  56:stepper.c     **** // Stores the planner block Bresenham algorithm execution data for the segments in the segment
  57:stepper.c     **** // buffer. Normally, this buffer is partially in-use, but, for the worst case scenario, it will
  58:stepper.c     **** // never exceed the number of accessible stepper buffer segments (SEGMENT_BUFFER_SIZE-1).
  59:stepper.c     **** // NOTE: This data is copied from the prepped planner blocks so that the planner blocks may be
  60:stepper.c     **** // discarded when entirely consumed and completed by the segment buffer. Also, AMASS alters this
  61:stepper.c     **** // data for its own use.
  62:stepper.c     **** typedef struct {
  63:stepper.c     ****   uint32_t steps[N_AXIS];
  64:stepper.c     ****   uint32_t step_event_count;
  65:stepper.c     ****   uint8_t direction_bits;
  66:stepper.c     ****   #ifdef VARIABLE_SPINDLE
  67:stepper.c     ****     uint8_t is_pwm_rate_adjusted; // Tracks motions that require constant laser power/rate
  68:stepper.c     ****   #endif
  69:stepper.c     **** } st_block_t;
  70:stepper.c     **** static st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
  71:stepper.c     **** 
  72:stepper.c     **** // Primary stepper segment ring buffer. Contains small, short line segments for the stepper
  73:stepper.c     **** // algorithm to execute, which are "checked-out" incrementally from the first block in the
  74:stepper.c     **** // planner buffer. Once "checked-out", the steps in the segments buffer cannot be modified by
  75:stepper.c     **** // the planner, where the remaining planner block steps still can.
  76:stepper.c     **** typedef struct {
  77:stepper.c     ****   uint16_t n_step;           // Number of step events to be executed for this segment
  78:stepper.c     ****   uint16_t cycles_per_tick;  // Step distance traveled per ISR tick, aka step rate.
  79:stepper.c     ****   uint8_t  st_block_index;   // Stepper block data index. Uses this information to execute this seg
  80:stepper.c     ****   #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
  81:stepper.c     ****     uint8_t amass_level;    // Indicates AMASS level for the ISR to execute this segment
  82:stepper.c     ****   #else
  83:stepper.c     ****     uint8_t prescaler;      // Without AMASS, a prescaler is required to adjust for slow timing.
  84:stepper.c     ****   #endif
  85:stepper.c     ****   #ifdef VARIABLE_SPINDLE
  86:stepper.c     ****     uint8_t spindle_pwm;
  87:stepper.c     ****   #endif
  88:stepper.c     **** } segment_t;
  89:stepper.c     **** static segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
  90:stepper.c     **** 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 4


  91:stepper.c     **** // Stepper ISR data struct. Contains the running data for the main stepper ISR.
  92:stepper.c     **** typedef struct {
  93:stepper.c     ****   // Used by the bresenham line algorithm
  94:stepper.c     ****   uint32_t counter_x,        // Counter variables for the bresenham line tracer
  95:stepper.c     ****            counter_y,
  96:stepper.c     ****            counter_z
  97:stepper.c     ****            #ifdef A_AXIS
  98:stepper.c     ****             , counter_a
  99:stepper.c     ****            #endif
 100:stepper.c     ****            #ifdef B_AXIS
 101:stepper.c     ****             , counter_b
 102:stepper.c     ****            #endif
 103:stepper.c     ****            #ifdef C_AXIS
 104:stepper.c     ****             , counter_c
 105:stepper.c     ****             #endif
 106:stepper.c     ****           ;
 107:stepper.c     ****   #ifdef STEP_PULSE_DELAY
 108:stepper.c     ****     uint8_t step_bits;  // Stores out_bits output to complete the step pulse delay
 109:stepper.c     ****   #endif
 110:stepper.c     **** 
 111:stepper.c     ****   uint8_t execute_step;     // Flags step execution for each interrupt.
 112:stepper.c     ****   uint8_t step_pulse_time;  // Step pulse reset time after step rise
 113:stepper.c     ****   uint8_t step_outbits;         // The next stepping-bits to be output
 114:stepper.c     ****   uint8_t dir_outbits;
 115:stepper.c     ****   #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 116:stepper.c     ****     uint32_t steps[N_AXIS];
 117:stepper.c     ****   #endif
 118:stepper.c     **** 
 119:stepper.c     ****   uint16_t step_count;       // Steps remaining in line segment motion
 120:stepper.c     ****   uint8_t exec_block_index; // Tracks the current st_block index. Change indicates new block.
 121:stepper.c     ****   st_block_t *exec_block;   // Pointer to the block data for the segment being executed
 122:stepper.c     ****   segment_t *exec_segment;  // Pointer to the segment being executed
 123:stepper.c     **** } stepper_t;
 124:stepper.c     **** static stepper_t st;
 125:stepper.c     **** 
 126:stepper.c     **** // Step segment ring buffer indices
 127:stepper.c     **** static volatile uint8_t segment_buffer_tail;
 128:stepper.c     **** static uint8_t segment_buffer_head;
 129:stepper.c     **** static uint8_t segment_next_head;
 130:stepper.c     **** 
 131:stepper.c     **** // Step and direction port invert masks.
 132:stepper.c     **** static uint8_t step_port_invert_mask;
 133:stepper.c     **** static uint8_t dir_port_invert_mask;
 134:stepper.c     **** 
 135:stepper.c     **** // Used to avoid ISR nesting of the "Stepper Driver Interrupt". Should never occur though.
 136:stepper.c     **** static volatile uint8_t busy;
 137:stepper.c     **** 
 138:stepper.c     **** // Pointers for the step segment being prepped from the planner buffer. Accessed only by the
 139:stepper.c     **** // main program. Pointers may be planning segments or planner blocks ahead of what being executed.
 140:stepper.c     **** static plan_block_t *pl_block;     // Pointer to the planner block being prepped
 141:stepper.c     **** static st_block_t *st_prep_block;  // Pointer to the stepper block data being prepped
 142:stepper.c     **** 
 143:stepper.c     **** // Segment preparation data struct. Contains all the necessary information to compute new segments
 144:stepper.c     **** // based on the current executing planner block.
 145:stepper.c     **** typedef struct {
 146:stepper.c     ****   uint8_t st_block_index;  // Index of stepper common data block being prepped
 147:stepper.c     ****   uint8_t recalculate_flag;
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 5


 148:stepper.c     **** 
 149:stepper.c     ****   float dt_remainder;
 150:stepper.c     ****   float steps_remaining;
 151:stepper.c     ****   float step_per_mm;
 152:stepper.c     ****   float req_mm_increment;
 153:stepper.c     **** 
 154:stepper.c     ****   #ifdef PARKING_ENABLE
 155:stepper.c     ****     uint8_t last_st_block_index;
 156:stepper.c     ****     float last_steps_remaining;
 157:stepper.c     ****     float last_step_per_mm;
 158:stepper.c     ****     float last_dt_remainder;
 159:stepper.c     ****   #endif
 160:stepper.c     **** 
 161:stepper.c     ****   uint8_t ramp_type;      // Current segment ramp state
 162:stepper.c     ****   float mm_complete;      // End of velocity profile from end of current planner block in (mm).
 163:stepper.c     ****                           // NOTE: This value must coincide with a step(no mantissa) when converted
 164:stepper.c     ****   float current_speed;    // Current speed at the end of the segment buffer (mm/min)
 165:stepper.c     ****   float maximum_speed;    // Maximum speed of executing block. Not always nominal speed. (mm/min)
 166:stepper.c     ****   float exit_speed;       // Exit speed of executing block (mm/min)
 167:stepper.c     ****   float accelerate_until; // Acceleration ramp end measured from end of block (mm)
 168:stepper.c     ****   float decelerate_after; // Deceleration ramp start measured from end of block (mm)
 169:stepper.c     **** 
 170:stepper.c     ****   #ifdef VARIABLE_SPINDLE
 171:stepper.c     ****     float inv_rate;    // Used by PWM laser mode to speed up segment calculations.
 172:stepper.c     ****     uint8_t current_spindle_pwm; 
 173:stepper.c     ****   #endif
 174:stepper.c     **** } st_prep_t;
 175:stepper.c     **** static st_prep_t prep;
 176:stepper.c     **** 
 177:stepper.c     **** 
 178:stepper.c     **** /*    BLOCK VELOCITY PROFILE DEFINITION
 179:stepper.c     ****           __________________________
 180:stepper.c     ****          /|                        |\     _________________         ^
 181:stepper.c     ****         / |                        | \   /|               |\        |
 182:stepper.c     ****        /  |                        |  \ / |               | \       s
 183:stepper.c     ****       /   |                        |   |  |               |  \      p
 184:stepper.c     ****      /    |                        |   |  |               |   \     e
 185:stepper.c     ****     +-----+------------------------+---+--+---------------+----+    e
 186:stepper.c     ****     |               BLOCK 1            ^      BLOCK 2          |    d
 187:stepper.c     ****                                        |
 188:stepper.c     ****                   time ----->      EXAMPLE: Block 2 entry speed is at max junction velocity
 189:stepper.c     **** 
 190:stepper.c     ****   The planner block buffer is planned assuming constant acceleration velocity profiles and are
 191:stepper.c     ****   continuously joined at block junctions as shown above. However, the planner only actively compute
 192:stepper.c     ****   the block entry speeds for an optimal velocity plan, but does not compute the block internal
 193:stepper.c     ****   velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
 194:stepper.c     ****   stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
 195:stepper.c     ****   deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
 196:stepper.c     ****   triangle(no cruise).
 197:stepper.c     **** 
 198:stepper.c     ****                                         maximum_speed (< nominal_speed) ->  +
 199:stepper.c     ****                     +--------+ <- maximum_speed (= nominal_speed)          /|\
 200:stepper.c     ****                    /          \                                           / | \
 201:stepper.c     ****  current_speed -> +            \                                         /  |  + <- exit_speed
 202:stepper.c     ****                   |             + <- exit_speed                         /   |  |
 203:stepper.c     ****                   +-------------+                     current_speed -> +----+--+
 204:stepper.c     ****                    time -->  ^  ^                                           ^  ^
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 6


 205:stepper.c     ****                              |  |                                           |  |
 206:stepper.c     ****                 decelerate_after(in mm)                             decelerate_after(in mm)
 207:stepper.c     ****                     ^           ^                                           ^  ^
 208:stepper.c     ****                     |           |                                           |  |
 209:stepper.c     ****                 accelerate_until(in mm)                             accelerate_until(in mm)
 210:stepper.c     **** 
 211:stepper.c     ****   The step segment buffer computes the executing block velocity profile and tracks the critical
 212:stepper.c     ****   parameters for the stepper algorithm to accurately trace the profile. These critical parameters
 213:stepper.c     ****   are shown and defined in the above illustration.
 214:stepper.c     **** */
 215:stepper.c     **** 
 216:stepper.c     **** 
 217:stepper.c     **** // Stepper state initialization. Cycle should only start if the st.cycle_start flag is
 218:stepper.c     **** // enabled. Startup init and limits call this function but shouldn't start the cycle.
 219:stepper.c     **** void st_wake_up()
 220:stepper.c     **** {
  66              		.loc 1 220 0
  67              		.cfi_startproc
  68              		@ args = 0, pretend = 0, frame = 0
  69              		@ frame_needed = 1, uses_anonymous_args = 0
  70 0000 80B5     		push	{r7, lr}
  71              		.cfi_def_cfa_offset 8
  72              		.cfi_offset 7, -8
  73              		.cfi_offset 14, -4
  74 0002 00AF     		add	r7, sp, #0
  75              		.cfi_def_cfa_register 7
 221:stepper.c     ****   // Enable stepper drivers.
 222:stepper.c     ****  // Enable stepper drivers.  
 223:stepper.c     ****   Control_Step_Enable_Write(1);
  76              		.loc 1 223 0
  77 0004 0120     		movs	r0, #1
  78 0006 FFF7FEFF 		bl	Control_Step_Enable_Write
 224:stepper.c     **** 
 225:stepper.c     ****   // Initialize stepper output bits to ensure first ISR call does not step.
 226:stepper.c     ****   st.step_outbits = step_port_invert_mask;
  79              		.loc 1 226 0
  80 000a 0B4B     		ldr	r3, .L2
  81 000c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
  82 000e 0B4B     		ldr	r3, .L2+4
  83 0010 9A73     		strb	r2, [r3, #14]
 227:stepper.c     **** 
 228:stepper.c     ****   // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
 229:stepper.c     ****   #ifdef STEP_PULSE_DELAY
 230:stepper.c     ****     // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.
 231:stepper.c     ****     st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND)
 232:stepper.c     ****     // Set delay between direction pin write and step command.
 233:stepper.c     ****     OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
 234:stepper.c     ****   #else // Normal operation
 235:stepper.c     ****     // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
 236:stepper.c     ****     st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
  84              		.loc 1 236 0
  85 0012 0B4B     		ldr	r3, .L2+8
  86 0014 93F83030 		ldrb	r3, [r3, #48]	@ zero_extendqisi2
  87 0018 023B     		subs	r3, r3, #2
  88 001a 1A46     		mov	r2, r3
  89 001c 1346     		mov	r3, r2
  90 001e 5B00     		lsls	r3, r3, #1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 7


  91 0020 1344     		add	r3, r3, r2
  92 0022 DB00     		lsls	r3, r3, #3
  93 0024 DB08     		lsrs	r3, r3, #3
  94 0026 DBB2     		uxtb	r3, r3
  95 0028 5B42     		negs	r3, r3
  96 002a DAB2     		uxtb	r2, r3
  97 002c 034B     		ldr	r3, .L2+4
  98 002e 5A73     		strb	r2, [r3, #13]
 237:stepper.c     ****   #endif
 238:stepper.c     **** 
 239:stepper.c     ****   // Enable Stepper Driver Interrupt
 240:stepper.c     ****  Stepper_Timer_Start();
  99              		.loc 1 240 0
 100 0030 FFF7FEFF 		bl	Stepper_Timer_Start
 241:stepper.c     **** }
 101              		.loc 1 241 0
 102 0034 00BF     		nop
 103 0036 80BD     		pop	{r7, pc}
 104              	.L3:
 105              		.align	2
 106              	.L2:
 107 0038 BF000000 		.word	step_port_invert_mask
 108 003c 94000000 		.word	st
 109 0040 00000000 		.word	settings
 110              		.cfi_endproc
 111              	.LFE64:
 112              		.size	st_wake_up, .-st_wake_up
 113              		.section	.text.st_go_idle,"ax",%progbits
 114              		.align	2
 115              		.global	st_go_idle
 116              		.thumb
 117              		.thumb_func
 118              		.type	st_go_idle, %function
 119              	st_go_idle:
 120              	.LFB65:
 242:stepper.c     **** 
 243:stepper.c     **** 
 244:stepper.c     **** // Stepper shutdown
 245:stepper.c     **** void st_go_idle()
 246:stepper.c     **** {
 121              		.loc 1 246 0
 122              		.cfi_startproc
 123              		@ args = 0, pretend = 0, frame = 8
 124              		@ frame_needed = 1, uses_anonymous_args = 0
 125 0000 80B5     		push	{r7, lr}
 126              		.cfi_def_cfa_offset 8
 127              		.cfi_offset 7, -8
 128              		.cfi_offset 14, -4
 129 0002 82B0     		sub	sp, sp, #8
 130              		.cfi_def_cfa_offset 16
 131 0004 00AF     		add	r7, sp, #0
 132              		.cfi_def_cfa_register 7
 247:stepper.c     ****   // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
 248:stepper.c     ****   Stepper_Timer_Stop(); // PSoc Change
 133              		.loc 1 248 0
 134 0006 FFF7FEFF 		bl	Stepper_Timer_Stop
 249:stepper.c     ****   busy = false;
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 8


 135              		.loc 1 249 0
 136 000a 134B     		ldr	r3, .L7
 137 000c 0022     		movs	r2, #0
 138 000e 1A70     		strb	r2, [r3]
 250:stepper.c     ****   
 251:stepper.c     **** 
 252:stepper.c     **** 
 253:stepper.c     ****   // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
 254:stepper.c     ****   bool pin_state = false; // Keep enabled.
 139              		.loc 1 254 0
 140 0010 0023     		movs	r3, #0
 141 0012 FB71     		strb	r3, [r7, #7]
 255:stepper.c     ****   if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) 
 142              		.loc 1 255 0
 143 0014 114B     		ldr	r3, .L7+4
 144 0016 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 145 001a FF2B     		cmp	r3, #255
 146 001c 08D1     		bne	.L5
 147              		.loc 1 255 0 is_stmt 0 discriminator 2
 148 001e 104B     		ldr	r3, .L7+8
 149 0020 1B78     		ldrb	r3, [r3]
 150 0022 DBB2     		uxtb	r3, r3
 151 0024 002B     		cmp	r3, #0
 152 0026 03D1     		bne	.L5
 153              		.loc 1 255 0 discriminator 4
 154 0028 0E4B     		ldr	r3, .L7+12
 155 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 156 002c 802B     		cmp	r3, #128
 157 002e 0BD1     		bne	.L6
 158              	.L5:
 159              		.loc 1 255 0 discriminator 5
 160 0030 0C4B     		ldr	r3, .L7+12
 161 0032 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 162 0034 042B     		cmp	r3, #4
 163 0036 07D0     		beq	.L6
 256:stepper.c     ****     // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a c
 257:stepper.c     ****     // stop and not drift from residual inertial forces at the end of the last movement.
 258:stepper.c     ****     delay_ms(settings.stepper_idle_lock_time);
 164              		.loc 1 258 0 is_stmt 1
 165 0038 084B     		ldr	r3, .L7+4
 166 003a 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 167 003e 1846     		mov	r0, r3
 168 0040 FFF7FEFF 		bl	CyDelay
 259:stepper.c     ****     pin_state = true; // Override. Disable steppers.   
 169              		.loc 1 259 0
 170 0044 0123     		movs	r3, #1
 171 0046 FB71     		strb	r3, [r7, #7]
 172              	.L6:
 260:stepper.c     ****     
 261:stepper.c     ****     
 262:stepper.c     ****   }
 263:stepper.c     ****   
 264:stepper.c     ****   Control_Step_Enable_Write(pin_state); // PSoc Change
 173              		.loc 1 264 0
 174 0048 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 175 004a 1846     		mov	r0, r3
 176 004c FFF7FEFF 		bl	Control_Step_Enable_Write
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 9


 265:stepper.c     ****   
 266:stepper.c     **** }
 177              		.loc 1 266 0
 178 0050 00BF     		nop
 179 0052 0837     		adds	r7, r7, #8
 180              		.cfi_def_cfa_offset 8
 181 0054 BD46     		mov	sp, r7
 182              		.cfi_def_cfa_register 13
 183              		@ sp needed
 184 0056 80BD     		pop	{r7, pc}
 185              	.L8:
 186              		.align	2
 187              	.L7:
 188 0058 C1000000 		.word	busy
 189 005c 00000000 		.word	settings
 190 0060 00000000 		.word	sys_rt_exec_alarm
 191 0064 00000000 		.word	sys
 192              		.cfi_endproc
 193              	.LFE65:
 194              		.size	st_go_idle, .-st_go_idle
 195              		.section	.text.stepper_timer_isr,"ax",%progbits
 196              		.align	2
 197              		.global	stepper_timer_isr
 198              		.thumb
 199              		.thumb_func
 200              		.type	stepper_timer_isr, %function
 201              	stepper_timer_isr:
 202              	.LFB66:
 267:stepper.c     **** 
 268:stepper.c     **** 
 269:stepper.c     **** /* "The Stepper Driver Interrupt" - This timer interrupt is the workhorse of Grbl. Grbl employs
 270:stepper.c     ****    the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.
 271:stepper.c     ****    Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical
 272:stepper.c     ****    round-off errors and only requires fast integer counters, meaning low computational overhead
 273:stepper.c     ****    and maximizing the Arduino's capabilities. However, the downside of the Bresenham algorithm
 274:stepper.c     ****    is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step
 275:stepper.c     ****    pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is
 276:stepper.c     ****    particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but
 277:stepper.c     ****    is usually not a physical problem at higher frequencies, although audible.
 278:stepper.c     ****      To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis
 279:stepper.c     ****    Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,
 280:stepper.c     ****    AMASS artificially increases the Bresenham resolution without effecting the algorithm's
 281:stepper.c     ****    innate exactness. AMASS adapts its resolution levels automatically depending on the step
 282:stepper.c     ****    frequency to be executed, meaning that for even lower step frequencies the step smoothing
 283:stepper.c     ****    level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham
 284:stepper.c     ****    step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift
 285:stepper.c     ****    the Bresenham step event count, effectively multiplying it by 2, while the axis step counts
 286:stepper.c     ****    remain the same, and then double the stepper ISR frequency. In effect, we are allowing the
 287:stepper.c     ****    non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is
 288:stepper.c     ****    stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS
 289:stepper.c     ****    Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any
 290:stepper.c     ****    of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the
 291:stepper.c     ****    stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing
 292:stepper.c     ****    issues with the Bresenham algorithm and does not significantly alter Grbl's performance, but
 293:stepper.c     ****    in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.
 294:stepper.c     ****      AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full
 295:stepper.c     ****    Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 10


 296:stepper.c     ****    intermediate steps must be completed such that baseline Bresenham (Level 0) count is always
 297:stepper.c     ****    retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed.
 298:stepper.c     ****    Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can
 299:stepper.c     ****    be multiplied by any integer value, multiplication by powers of two are simply used to ease
 300:stepper.c     ****    CPU overhead with bitshift integer operations.
 301:stepper.c     ****      This interrupt is simple and dumb by design. All the computational heavy-lifting, as in
 302:stepper.c     ****    determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,
 303:stepper.c     ****    defined as constant velocity over n number of steps, from the step segment buffer and then
 304:stepper.c     ****    executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This
 305:stepper.c     ****    ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port
 306:stepper.c     ****    after each pulse. The bresenham line tracer algorithm controls all stepper outputs
 307:stepper.c     ****    simultaneously with these two interrupts.
 308:stepper.c     **** 
 309:stepper.c     ****    NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick,
 310:stepper.c     ****    which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
 311:stepper.c     ****    ISR is 5usec typical and 25usec maximum, well below requirement.
 312:stepper.c     ****    NOTE: This ISR expects at least one step to be executed per segment.
 313:stepper.c     **** */
 314:stepper.c     **** // TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use sma
 315:stepper.c     **** // int8 variables and update position counters only when a segment completes. This can get complica
 316:stepper.c     **** // with probing and homing cycles that require true real-time positions.
 317:stepper.c     **** void stepper_timer_isr() //ISR(TIMER1_COMPA_vect)
 318:stepper.c     **** {
 203              		.loc 1 318 0
 204              		.cfi_startproc
 205              		@ args = 0, pretend = 0, frame = 0
 206              		@ frame_needed = 1, uses_anonymous_args = 0
 207 0000 80B5     		push	{r7, lr}
 208              		.cfi_def_cfa_offset 8
 209              		.cfi_offset 7, -8
 210              		.cfi_offset 14, -4
 211 0002 00AF     		add	r7, sp, #0
 212              		.cfi_def_cfa_register 7
 319:stepper.c     ****   Stepper_Timer_ReadStatusRegister(); // clear the PSoc interrupt
 213              		.loc 1 319 0
 214 0004 FFF7FEFF 		bl	Stepper_Timer_ReadStatusRegister
 320:stepper.c     ****   
 321:stepper.c     ****   if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
 215              		.loc 1 321 0
 216 0008 914B     		ldr	r3, .L26
 217 000a 1B78     		ldrb	r3, [r3]
 218 000c DBB2     		uxtb	r3, r3
 219 000e 002B     		cmp	r3, #0
 220 0010 40F06781 		bne	.L25
 322:stepper.c     **** 
 323:stepper.c     ****   // Set the direction pins a couple of nanoseconds before we step the steppers
 324:stepper.c     ****    Control_Reg_Dir_Write(st.dir_outbits);
 221              		.loc 1 324 0
 222 0014 8F4B     		ldr	r3, .L26+4
 223 0016 DB7B     		ldrb	r3, [r3, #15]	@ zero_extendqisi2
 224 0018 1846     		mov	r0, r3
 225 001a FFF7FEFF 		bl	Control_Reg_Dir_Write
 325:stepper.c     **** 
 326:stepper.c     ****   // Then pulse the stepping pins
 327:stepper.c     ****   #ifdef STEP_PULSE_DELAY
 328:stepper.c     ****     st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwri
 329:stepper.c     ****   #else  // Normal operation
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 11


 330:stepper.c     ****     Control_Reg_Step_Write(st.step_outbits);
 226              		.loc 1 330 0
 227 001e 8D4B     		ldr	r3, .L26+4
 228 0020 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 229 0022 1846     		mov	r0, r3
 230 0024 FFF7FEFF 		bl	Control_Reg_Step_Write
 331:stepper.c     ****   #endif
 332:stepper.c     **** 
 333:stepper.c     ****  
 334:stepper.c     **** 
 335:stepper.c     ****   busy = true;
 231              		.loc 1 335 0
 232 0028 894B     		ldr	r3, .L26
 233 002a 0122     		movs	r2, #1
 234 002c 1A70     		strb	r2, [r3]
 336:stepper.c     ****   Stepper_Timer_Start(); //sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to 
 235              		.loc 1 336 0
 236 002e FFF7FEFF 		bl	Stepper_Timer_Start
 337:stepper.c     ****          // NOTE: The remaining code in this ISR will finish before returning to main program.
 338:stepper.c     **** 
 339:stepper.c     ****   // If there is no step segment, attempt to pop one from the stepper buffer
 340:stepper.c     ****   if (st.exec_segment == NULL) {
 237              		.loc 1 340 0
 238 0032 884B     		ldr	r3, .L26+4
 239 0034 5B6A     		ldr	r3, [r3, #36]
 240 0036 002B     		cmp	r3, #0
 241 0038 77D1     		bne	.L12
 341:stepper.c     ****     // Anything in the buffer? If so, load and initialize next step segment.
 342:stepper.c     ****     if (segment_buffer_head != segment_buffer_tail) {
 242              		.loc 1 342 0
 243 003a 874B     		ldr	r3, .L26+8
 244 003c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 245 003e 874B     		ldr	r3, .L26+12
 246 0040 1B78     		ldrb	r3, [r3]
 247 0042 DBB2     		uxtb	r3, r3
 248 0044 9A42     		cmp	r2, r3
 249 0046 62D0     		beq	.L13
 343:stepper.c     ****       // Initialize new step segment and load number of steps to execute
 344:stepper.c     ****       st.exec_segment = &segment_buffer[segment_buffer_tail];
 250              		.loc 1 344 0
 251 0048 844B     		ldr	r3, .L26+12
 252 004a 1B78     		ldrb	r3, [r3]
 253 004c DBB2     		uxtb	r3, r3
 254 004e DB00     		lsls	r3, r3, #3
 255 0050 834A     		ldr	r2, .L26+16
 256 0052 1344     		add	r3, r3, r2
 257 0054 7F4A     		ldr	r2, .L26+4
 258 0056 5362     		str	r3, [r2, #36]
 345:stepper.c     **** 
 346:stepper.c     ****       #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 347:stepper.c     ****         // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 2
 348:stepper.c     ****         TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
 349:stepper.c     ****       #endif
 350:stepper.c     **** 
 351:stepper.c     ****       // Initialize step segment timing per step and load number of steps to execute.
 352:stepper.c     ****       Stepper_Timer_WritePeriod(st.exec_segment->cycles_per_tick); // OCR1A = st.exec_segment->cycl
 259              		.loc 1 352 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 12


 260 0058 7E4B     		ldr	r3, .L26+4
 261 005a 5B6A     		ldr	r3, [r3, #36]
 262 005c 5B88     		ldrh	r3, [r3, #2]
 263 005e 1846     		mov	r0, r3
 264 0060 FFF7FEFF 		bl	Stepper_Timer_WritePeriod
 353:stepper.c     ****       st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 265              		.loc 1 353 0
 266 0064 7B4B     		ldr	r3, .L26+4
 267 0066 5B6A     		ldr	r3, [r3, #36]
 268 0068 1A88     		ldrh	r2, [r3]
 269 006a 7A4B     		ldr	r3, .L26+4
 270 006c 9A83     		strh	r2, [r3, #28]	@ movhi
 354:stepper.c     ****       // If the new segment starts a new planner block, initialize stepper variables and counters.
 355:stepper.c     ****       // NOTE: When the segment data index changes, this indicates a new planner block.
 356:stepper.c     ****       if ( st.exec_block_index != st.exec_segment->st_block_index ) {
 271              		.loc 1 356 0
 272 006e 794B     		ldr	r3, .L26+4
 273 0070 9A7F     		ldrb	r2, [r3, #30]	@ zero_extendqisi2
 274 0072 784B     		ldr	r3, .L26+4
 275 0074 5B6A     		ldr	r3, [r3, #36]
 276 0076 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 277 0078 9A42     		cmp	r2, r3
 278 007a 1DD0     		beq	.L14
 357:stepper.c     ****         st.exec_block_index = st.exec_segment->st_block_index;
 279              		.loc 1 357 0
 280 007c 754B     		ldr	r3, .L26+4
 281 007e 5B6A     		ldr	r3, [r3, #36]
 282 0080 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 283 0082 744B     		ldr	r3, .L26+4
 284 0084 9A77     		strb	r2, [r3, #30]
 358:stepper.c     ****         st.exec_block = &st_block_buffer[st.exec_block_index];
 285              		.loc 1 358 0
 286 0086 734B     		ldr	r3, .L26+4
 287 0088 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 288 008a 1A46     		mov	r2, r3
 289 008c 1346     		mov	r3, r2
 290 008e 9B00     		lsls	r3, r3, #2
 291 0090 1344     		add	r3, r3, r2
 292 0092 9B00     		lsls	r3, r3, #2
 293 0094 734A     		ldr	r2, .L26+20
 294 0096 1344     		add	r3, r3, r2
 295 0098 6E4A     		ldr	r2, .L26+4
 296 009a 1362     		str	r3, [r2, #32]
 359:stepper.c     **** 
 360:stepper.c     ****         // Initialize Bresenham line and distance counters
 361:stepper.c     ****         st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
 297              		.loc 1 361 0
 298 009c 6D4B     		ldr	r3, .L26+4
 299 009e 1B6A     		ldr	r3, [r3, #32]
 300 00a0 DB68     		ldr	r3, [r3, #12]
 301 00a2 5B08     		lsrs	r3, r3, #1
 302 00a4 6B4A     		ldr	r2, .L26+4
 303 00a6 9360     		str	r3, [r2, #8]
 304 00a8 6A4B     		ldr	r3, .L26+4
 305 00aa 9B68     		ldr	r3, [r3, #8]
 306 00ac 694A     		ldr	r2, .L26+4
 307 00ae 5360     		str	r3, [r2, #4]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 13


 308 00b0 684B     		ldr	r3, .L26+4
 309 00b2 5B68     		ldr	r3, [r3, #4]
 310 00b4 674A     		ldr	r2, .L26+4
 311 00b6 1360     		str	r3, [r2]
 312              	.L14:
 362:stepper.c     ****       }
 363:stepper.c     ****       st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
 313              		.loc 1 363 0
 314 00b8 664B     		ldr	r3, .L26+4
 315 00ba 1B6A     		ldr	r3, [r3, #32]
 316 00bc 1A7C     		ldrb	r2, [r3, #16]	@ zero_extendqisi2
 317 00be 6A4B     		ldr	r3, .L26+24
 318 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 319 00c2 5340     		eors	r3, r3, r2
 320 00c4 DAB2     		uxtb	r2, r3
 321 00c6 634B     		ldr	r3, .L26+4
 322 00c8 DA73     		strb	r2, [r3, #15]
 364:stepper.c     **** 
 365:stepper.c     ****       #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 366:stepper.c     ****         // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
 367:stepper.c     ****         st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
 323              		.loc 1 367 0
 324 00ca 624B     		ldr	r3, .L26+4
 325 00cc 1B6A     		ldr	r3, [r3, #32]
 326 00ce 1B68     		ldr	r3, [r3]
 327 00d0 604A     		ldr	r2, .L26+4
 328 00d2 526A     		ldr	r2, [r2, #36]
 329 00d4 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 330 00d6 D340     		lsrs	r3, r3, r2
 331 00d8 5E4A     		ldr	r2, .L26+4
 332 00da 1361     		str	r3, [r2, #16]
 368:stepper.c     ****         st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
 333              		.loc 1 368 0
 334 00dc 5D4B     		ldr	r3, .L26+4
 335 00de 1B6A     		ldr	r3, [r3, #32]
 336 00e0 5B68     		ldr	r3, [r3, #4]
 337 00e2 5C4A     		ldr	r2, .L26+4
 338 00e4 526A     		ldr	r2, [r2, #36]
 339 00e6 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 340 00e8 D340     		lsrs	r3, r3, r2
 341 00ea 5A4A     		ldr	r2, .L26+4
 342 00ec 5361     		str	r3, [r2, #20]
 369:stepper.c     ****         st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
 343              		.loc 1 369 0
 344 00ee 594B     		ldr	r3, .L26+4
 345 00f0 1B6A     		ldr	r3, [r3, #32]
 346 00f2 9B68     		ldr	r3, [r3, #8]
 347 00f4 574A     		ldr	r2, .L26+4
 348 00f6 526A     		ldr	r2, [r2, #36]
 349 00f8 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 350 00fa D340     		lsrs	r3, r3, r2
 351 00fc 554A     		ldr	r2, .L26+4
 352 00fe 9361     		str	r3, [r2, #24]
 370:stepper.c     ****         
 371:stepper.c     ****         #ifdef A_AXIS
 372:stepper.c     ****            st.steps[A_AXIS] = st.exec_block->steps[A_AXIS] >> st.exec_segment->amass_level;
 373:stepper.c     ****         #endif
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 14


 374:stepper.c     ****         #ifdef B_AXIS
 375:stepper.c     ****            st.steps[B_AXIS] = st.exec_block->steps[B_AXIS] >> st.exec_segment->amass_level;
 376:stepper.c     ****         #endif
 377:stepper.c     ****         #ifdef C_AXIS
 378:stepper.c     ****            st.steps[C_AXIS] = st.exec_block->steps[C_AXIS] >> st.exec_segment->amass_level;
 379:stepper.c     ****         #endif
 380:stepper.c     ****  
 381:stepper.c     ****         
 382:stepper.c     ****       #endif
 383:stepper.c     **** 
 384:stepper.c     ****       #ifdef VARIABLE_SPINDLE
 385:stepper.c     ****         // Set real-time spindle output as segment is loaded, just prior to the first step.
 386:stepper.c     ****         spindle_set_speed(st.exec_segment->spindle_pwm);
 353              		.loc 1 386 0
 354 0100 544B     		ldr	r3, .L26+4
 355 0102 5B6A     		ldr	r3, [r3, #36]
 356 0104 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 357 0106 1846     		mov	r0, r3
 358 0108 FFF7FEFF 		bl	spindle_set_speed
 359 010c 0DE0     		b	.L12
 360              	.L13:
 387:stepper.c     ****       #endif
 388:stepper.c     **** 
 389:stepper.c     ****     } else {
 390:stepper.c     ****       // Segment buffer empty. Shutdown.
 391:stepper.c     ****       st_go_idle();
 361              		.loc 1 391 0
 362 010e FFF7FEFF 		bl	st_go_idle
 392:stepper.c     ****       #ifdef VARIABLE_SPINDLE
 393:stepper.c     ****         // Ensure pwm is set properly upon completion of rate-controlled motion.
 394:stepper.c     ****         if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
 363              		.loc 1 394 0
 364 0112 504B     		ldr	r3, .L26+4
 365 0114 1B6A     		ldr	r3, [r3, #32]
 366 0116 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 367 0118 002B     		cmp	r3, #0
 368 011a 02D0     		beq	.L15
 369              		.loc 1 394 0 is_stmt 0 discriminator 1
 370 011c 0020     		movs	r0, #0
 371 011e FFF7FEFF 		bl	spindle_set_speed
 372              	.L15:
 395:stepper.c     ****       #endif
 396:stepper.c     ****       system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
 373              		.loc 1 396 0 is_stmt 1
 374 0122 0420     		movs	r0, #4
 375 0124 FFF7FEFF 		bl	system_set_exec_state_flag
 397:stepper.c     ****       return; // Nothing to do but exit.
 376              		.loc 1 397 0
 377 0128 DCE0     		b	.L9
 378              	.L12:
 398:stepper.c     ****     }
 399:stepper.c     ****   }
 400:stepper.c     **** 
 401:stepper.c     **** 
 402:stepper.c     ****   // Check probing state.
 403:stepper.c     ****   if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
 379              		.loc 1 403 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 15


 380 012a 504B     		ldr	r3, .L26+28
 381 012c 1B78     		ldrb	r3, [r3]
 382 012e DBB2     		uxtb	r3, r3
 383 0130 012B     		cmp	r3, #1
 384 0132 01D1     		bne	.L16
 385              		.loc 1 403 0 is_stmt 0 discriminator 1
 386 0134 FFF7FEFF 		bl	probe_state_monitor
 387              	.L16:
 404:stepper.c     **** 
 405:stepper.c     ****   // Reset step out bits.
 406:stepper.c     ****   st.step_outbits = 0;
 388              		.loc 1 406 0 is_stmt 1
 389 0138 464B     		ldr	r3, .L26+4
 390 013a 0022     		movs	r2, #0
 391 013c 9A73     		strb	r2, [r3, #14]
 407:stepper.c     **** 
 408:stepper.c     ****   // Execute step displacement profile by Bresenham line algorithm
 409:stepper.c     ****   #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 410:stepper.c     ****     st.counter_x += st.steps[X_AXIS];
 392              		.loc 1 410 0
 393 013e 454B     		ldr	r3, .L26+4
 394 0140 1A68     		ldr	r2, [r3]
 395 0142 444B     		ldr	r3, .L26+4
 396 0144 1B69     		ldr	r3, [r3, #16]
 397 0146 1344     		add	r3, r3, r2
 398 0148 424A     		ldr	r2, .L26+4
 399 014a 1360     		str	r3, [r2]
 411:stepper.c     ****   #else
 412:stepper.c     ****     st.counter_x += st.exec_block->steps[X_AXIS];
 413:stepper.c     ****   #endif
 414:stepper.c     ****   if (st.counter_x > st.exec_block->step_event_count) {
 400              		.loc 1 414 0
 401 014c 414B     		ldr	r3, .L26+4
 402 014e 1A68     		ldr	r2, [r3]
 403 0150 404B     		ldr	r3, .L26+4
 404 0152 1B6A     		ldr	r3, [r3, #32]
 405 0154 DB68     		ldr	r3, [r3, #12]
 406 0156 9A42     		cmp	r2, r3
 407 0158 20D9     		bls	.L17
 415:stepper.c     ****     st.step_outbits |= (1<<X_STEP_BIT);
 408              		.loc 1 415 0
 409 015a 3E4B     		ldr	r3, .L26+4
 410 015c 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 411 015e 43F00103 		orr	r3, r3, #1
 412 0162 DAB2     		uxtb	r2, r3
 413 0164 3B4B     		ldr	r3, .L26+4
 414 0166 9A73     		strb	r2, [r3, #14]
 416:stepper.c     ****     st.counter_x -= st.exec_block->step_event_count;
 415              		.loc 1 416 0
 416 0168 3A4B     		ldr	r3, .L26+4
 417 016a 1A68     		ldr	r2, [r3]
 418 016c 394B     		ldr	r3, .L26+4
 419 016e 1B6A     		ldr	r3, [r3, #32]
 420 0170 DB68     		ldr	r3, [r3, #12]
 421 0172 D31A     		subs	r3, r2, r3
 422 0174 374A     		ldr	r2, .L26+4
 423 0176 1360     		str	r3, [r2]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 16


 417:stepper.c     ****     if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
 424              		.loc 1 417 0
 425 0178 364B     		ldr	r3, .L26+4
 426 017a 1B6A     		ldr	r3, [r3, #32]
 427 017c 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 428 017e 03F00103 		and	r3, r3, #1
 429 0182 002B     		cmp	r3, #0
 430 0184 05D0     		beq	.L18
 431              		.loc 1 417 0 is_stmt 0 discriminator 1
 432 0186 3A4B     		ldr	r3, .L26+32
 433 0188 1B68     		ldr	r3, [r3]
 434 018a 013B     		subs	r3, r3, #1
 435 018c 384A     		ldr	r2, .L26+32
 436 018e 1360     		str	r3, [r2]
 437 0190 04E0     		b	.L17
 438              	.L18:
 418:stepper.c     ****     else { sys_position[X_AXIS]++; }
 439              		.loc 1 418 0 is_stmt 1
 440 0192 374B     		ldr	r3, .L26+32
 441 0194 1B68     		ldr	r3, [r3]
 442 0196 0133     		adds	r3, r3, #1
 443 0198 354A     		ldr	r2, .L26+32
 444 019a 1360     		str	r3, [r2]
 445              	.L17:
 419:stepper.c     ****   }
 420:stepper.c     ****   #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 421:stepper.c     ****     st.counter_y += st.steps[Y_AXIS];
 446              		.loc 1 421 0
 447 019c 2D4B     		ldr	r3, .L26+4
 448 019e 5A68     		ldr	r2, [r3, #4]
 449 01a0 2C4B     		ldr	r3, .L26+4
 450 01a2 5B69     		ldr	r3, [r3, #20]
 451 01a4 1344     		add	r3, r3, r2
 452 01a6 2B4A     		ldr	r2, .L26+4
 453 01a8 5360     		str	r3, [r2, #4]
 422:stepper.c     ****   #else
 423:stepper.c     ****     st.counter_y += st.exec_block->steps[Y_AXIS];
 424:stepper.c     ****   #endif
 425:stepper.c     ****   if (st.counter_y > st.exec_block->step_event_count) {
 454              		.loc 1 425 0
 455 01aa 2A4B     		ldr	r3, .L26+4
 456 01ac 5A68     		ldr	r2, [r3, #4]
 457 01ae 294B     		ldr	r3, .L26+4
 458 01b0 1B6A     		ldr	r3, [r3, #32]
 459 01b2 DB68     		ldr	r3, [r3, #12]
 460 01b4 9A42     		cmp	r2, r3
 461 01b6 20D9     		bls	.L19
 426:stepper.c     ****     st.step_outbits |= (1<<Y_STEP_BIT);
 462              		.loc 1 426 0
 463 01b8 264B     		ldr	r3, .L26+4
 464 01ba 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 465 01bc 43F00203 		orr	r3, r3, #2
 466 01c0 DAB2     		uxtb	r2, r3
 467 01c2 244B     		ldr	r3, .L26+4
 468 01c4 9A73     		strb	r2, [r3, #14]
 427:stepper.c     ****     st.counter_y -= st.exec_block->step_event_count;
 469              		.loc 1 427 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 17


 470 01c6 234B     		ldr	r3, .L26+4
 471 01c8 5A68     		ldr	r2, [r3, #4]
 472 01ca 224B     		ldr	r3, .L26+4
 473 01cc 1B6A     		ldr	r3, [r3, #32]
 474 01ce DB68     		ldr	r3, [r3, #12]
 475 01d0 D31A     		subs	r3, r2, r3
 476 01d2 204A     		ldr	r2, .L26+4
 477 01d4 5360     		str	r3, [r2, #4]
 428:stepper.c     ****     if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
 478              		.loc 1 428 0
 479 01d6 1F4B     		ldr	r3, .L26+4
 480 01d8 1B6A     		ldr	r3, [r3, #32]
 481 01da 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 482 01dc 03F00203 		and	r3, r3, #2
 483 01e0 002B     		cmp	r3, #0
 484 01e2 05D0     		beq	.L20
 485              		.loc 1 428 0 is_stmt 0 discriminator 1
 486 01e4 224B     		ldr	r3, .L26+32
 487 01e6 5B68     		ldr	r3, [r3, #4]
 488 01e8 013B     		subs	r3, r3, #1
 489 01ea 214A     		ldr	r2, .L26+32
 490 01ec 5360     		str	r3, [r2, #4]
 491 01ee 04E0     		b	.L19
 492              	.L20:
 429:stepper.c     ****     else { sys_position[Y_AXIS]++; }
 493              		.loc 1 429 0 is_stmt 1
 494 01f0 1F4B     		ldr	r3, .L26+32
 495 01f2 5B68     		ldr	r3, [r3, #4]
 496 01f4 0133     		adds	r3, r3, #1
 497 01f6 1E4A     		ldr	r2, .L26+32
 498 01f8 5360     		str	r3, [r2, #4]
 499              	.L19:
 430:stepper.c     ****   }
 431:stepper.c     ****   #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 432:stepper.c     ****     st.counter_z += st.steps[Z_AXIS];
 500              		.loc 1 432 0
 501 01fa 164B     		ldr	r3, .L26+4
 502 01fc 9A68     		ldr	r2, [r3, #8]
 503 01fe 154B     		ldr	r3, .L26+4
 504 0200 9B69     		ldr	r3, [r3, #24]
 505 0202 1344     		add	r3, r3, r2
 506 0204 134A     		ldr	r2, .L26+4
 507 0206 9360     		str	r3, [r2, #8]
 433:stepper.c     ****   #else
 434:stepper.c     ****     st.counter_z += st.exec_block->steps[Z_AXIS];
 435:stepper.c     ****   #endif
 436:stepper.c     ****   if (st.counter_z > st.exec_block->step_event_count) {
 508              		.loc 1 436 0
 509 0208 124B     		ldr	r3, .L26+4
 510 020a 9A68     		ldr	r2, [r3, #8]
 511 020c 114B     		ldr	r3, .L26+4
 512 020e 1B6A     		ldr	r3, [r3, #32]
 513 0210 DB68     		ldr	r3, [r3, #12]
 514 0212 9A42     		cmp	r2, r3
 515 0214 33D9     		bls	.L21
 437:stepper.c     ****     st.step_outbits |= (1<<Z_STEP_BIT);
 516              		.loc 1 437 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 18


 517 0216 0F4B     		ldr	r3, .L26+4
 518 0218 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 519 021a 43F00403 		orr	r3, r3, #4
 520 021e DAB2     		uxtb	r2, r3
 521 0220 0C4B     		ldr	r3, .L26+4
 522 0222 9A73     		strb	r2, [r3, #14]
 438:stepper.c     ****     st.counter_z -= st.exec_block->step_event_count;
 523              		.loc 1 438 0
 524 0224 0B4B     		ldr	r3, .L26+4
 525 0226 9A68     		ldr	r2, [r3, #8]
 526 0228 0A4B     		ldr	r3, .L26+4
 527 022a 1B6A     		ldr	r3, [r3, #32]
 528 022c DB68     		ldr	r3, [r3, #12]
 529 022e D31A     		subs	r3, r2, r3
 530 0230 084A     		ldr	r2, .L26+4
 531 0232 9360     		str	r3, [r2, #8]
 439:stepper.c     ****     if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
 532              		.loc 1 439 0
 533 0234 074B     		ldr	r3, .L26+4
 534 0236 1B6A     		ldr	r3, [r3, #32]
 535 0238 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 536 023a 03F00403 		and	r3, r3, #4
 537 023e 002B     		cmp	r3, #0
 538 0240 18D0     		beq	.L22
 539              		.loc 1 439 0 is_stmt 0 discriminator 1
 540 0242 0B4B     		ldr	r3, .L26+32
 541 0244 9B68     		ldr	r3, [r3, #8]
 542 0246 013B     		subs	r3, r3, #1
 543 0248 094A     		ldr	r2, .L26+32
 544 024a 9360     		str	r3, [r2, #8]
 545 024c 17E0     		b	.L21
 546              	.L27:
 547 024e 00BF     		.align	2
 548              	.L26:
 549 0250 C1000000 		.word	busy
 550 0254 94000000 		.word	st
 551 0258 BD000000 		.word	segment_buffer_head
 552 025c BC000000 		.word	segment_buffer_tail
 553 0260 64000000 		.word	segment_buffer
 554 0264 00000000 		.word	st_block_buffer
 555 0268 C0000000 		.word	dir_port_invert_mask
 556 026c 00000000 		.word	sys_probe_state
 557 0270 00000000 		.word	sys_position
 558              	.L22:
 440:stepper.c     ****     else { sys_position[Z_AXIS]++; }
 559              		.loc 1 440 0 is_stmt 1
 560 0274 1C4B     		ldr	r3, .L28
 561 0276 9B68     		ldr	r3, [r3, #8]
 562 0278 0133     		adds	r3, r3, #1
 563 027a 1B4A     		ldr	r2, .L28
 564 027c 9360     		str	r3, [r2, #8]
 565              	.L21:
 441:stepper.c     ****   }
 442:stepper.c     ****   
 443:stepper.c     ****   #ifdef A_AXIS
 444:stepper.c     ****    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 445:stepper.c     ****      st.counter_a += st.steps[A_AXIS];
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 19


 446:stepper.c     ****    #else
 447:stepper.c     ****      st.counter_a += st.exec_block->steps[A_AXIS];
 448:stepper.c     ****    #endif
 449:stepper.c     ****    if (st.counter_a > st.exec_block->step_event_count) {
 450:stepper.c     ****      st.step_outbits |= (1<<A_STEP_BIT);
 451:stepper.c     ****      st.counter_a -= st.exec_block->step_event_count;
 452:stepper.c     ****      if (st.exec_block->direction_bits & (1<<A_DIRECTION_BIT)) { sys_position[A_AXIS]--; }
 453:stepper.c     ****      else { sys_position[A_AXIS]++; }
 454:stepper.c     ****    }
 455:stepper.c     ****   #endif
 456:stepper.c     ****   
 457:stepper.c     ****   
 458:stepper.c     ****  #ifdef B_AXIS
 459:stepper.c     ****    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 460:stepper.c     ****      st.counter_b += st.steps[B_AXIS];
 461:stepper.c     ****    #else
 462:stepper.c     ****      st.counter_b += st.exec_block->steps[B_AXIS];
 463:stepper.c     ****    #endif
 464:stepper.c     ****    if (st.counter_b > st.exec_block->step_event_count) {
 465:stepper.c     ****      st.step_outbits |= (1<<B_STEP_BIT);
 466:stepper.c     ****      st.counter_b -= st.exec_block->step_event_count;
 467:stepper.c     ****      if (st.exec_block->direction_bits & (1<<B_DIRECTION_BIT)) { sys_position[B_AXIS]--; }
 468:stepper.c     ****      else { sys_position[B_AXIS]++; }
 469:stepper.c     ****    }
 470:stepper.c     ****  #endif
 471:stepper.c     **** 
 472:stepper.c     ****  #ifdef C_AXIS
 473:stepper.c     ****    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 474:stepper.c     ****      st.counter_c += st.steps[C_AXIS];
 475:stepper.c     ****    #else
 476:stepper.c     ****      st.counter_c += st.exec_block->steps[C_AXIS];
 477:stepper.c     ****    #endif
 478:stepper.c     ****    if (st.counter_c > st.exec_block->step_event_count) {
 479:stepper.c     ****      st.step_outbits |= (1<<C_STEP_BIT);
 480:stepper.c     ****      st.counter_c -= st.exec_block->step_event_count;
 481:stepper.c     ****      if (st.exec_block->direction_bits & (1<<C_DIRECTION_BIT)) { sys_position[C_AXIS]--; }
 482:stepper.c     ****      else { sys_position[C_AXIS]++; }
 483:stepper.c     ****    }
 484:stepper.c     ****  #endif
 485:stepper.c     ****   
 486:stepper.c     ****   
 487:stepper.c     **** 
 488:stepper.c     ****   // During a homing cycle, lock out and prevent desired axes from moving.
 489:stepper.c     ****   if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
 566              		.loc 1 489 0
 567 027e 1B4B     		ldr	r3, .L28+4
 568 0280 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 569 0282 042B     		cmp	r3, #4
 570 0284 07D1     		bne	.L23
 571              		.loc 1 489 0 is_stmt 0 discriminator 1
 572 0286 1A4B     		ldr	r3, .L28+8
 573 0288 9A7B     		ldrb	r2, [r3, #14]	@ zero_extendqisi2
 574 028a 184B     		ldr	r3, .L28+4
 575 028c 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 576 028e 1340     		ands	r3, r3, r2
 577 0290 DAB2     		uxtb	r2, r3
 578 0292 174B     		ldr	r3, .L28+8
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 20


 579 0294 9A73     		strb	r2, [r3, #14]
 580              	.L23:
 490:stepper.c     **** 
 491:stepper.c     ****   st.step_count--; // Decrement step events count
 581              		.loc 1 491 0 is_stmt 1
 582 0296 164B     		ldr	r3, .L28+8
 583 0298 9B8B     		ldrh	r3, [r3, #28]
 584 029a 013B     		subs	r3, r3, #1
 585 029c 9AB2     		uxth	r2, r3
 586 029e 144B     		ldr	r3, .L28+8
 587 02a0 9A83     		strh	r2, [r3, #28]	@ movhi
 492:stepper.c     ****   if (st.step_count == 0) {
 588              		.loc 1 492 0
 589 02a2 134B     		ldr	r3, .L28+8
 590 02a4 9B8B     		ldrh	r3, [r3, #28]
 591 02a6 002B     		cmp	r3, #0
 592 02a8 0FD1     		bne	.L24
 493:stepper.c     ****     // Segment is complete. Discard current segment and advance segment indexing.
 494:stepper.c     ****     st.exec_segment = NULL;
 593              		.loc 1 494 0
 594 02aa 114B     		ldr	r3, .L28+8
 595 02ac 0022     		movs	r2, #0
 596 02ae 5A62     		str	r2, [r3, #36]
 495:stepper.c     ****     if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
 597              		.loc 1 495 0
 598 02b0 104B     		ldr	r3, .L28+12
 599 02b2 1B78     		ldrb	r3, [r3]
 600 02b4 DBB2     		uxtb	r3, r3
 601 02b6 0133     		adds	r3, r3, #1
 602 02b8 DBB2     		uxtb	r3, r3
 603 02ba 0E4A     		ldr	r2, .L28+12
 604 02bc 1946     		mov	r1, r3
 605 02be 1170     		strb	r1, [r2]
 606 02c0 062B     		cmp	r3, #6
 607 02c2 02D1     		bne	.L24
 608              		.loc 1 495 0 is_stmt 0 discriminator 1
 609 02c4 0B4B     		ldr	r3, .L28+12
 610 02c6 0022     		movs	r2, #0
 611 02c8 1A70     		strb	r2, [r3]
 612              	.L24:
 496:stepper.c     ****   }
 497:stepper.c     **** 
 498:stepper.c     ****   st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
 613              		.loc 1 498 0 is_stmt 1
 614 02ca 094B     		ldr	r3, .L28+8
 615 02cc 9A7B     		ldrb	r2, [r3, #14]	@ zero_extendqisi2
 616 02ce 0A4B     		ldr	r3, .L28+16
 617 02d0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 618 02d2 5340     		eors	r3, r3, r2
 619 02d4 DAB2     		uxtb	r2, r3
 620 02d6 064B     		ldr	r3, .L28+8
 621 02d8 9A73     		strb	r2, [r3, #14]
 499:stepper.c     ****   busy = false;
 622              		.loc 1 499 0
 623 02da 084B     		ldr	r3, .L28+20
 624 02dc 0022     		movs	r2, #0
 625 02de 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 21


 626 02e0 00E0     		b	.L9
 627              	.L25:
 321:stepper.c     **** 
 628              		.loc 1 321 0
 629 02e2 00BF     		nop
 630              	.L9:
 500:stepper.c     **** }
 631              		.loc 1 500 0
 632 02e4 80BD     		pop	{r7, pc}
 633              	.L29:
 634 02e6 00BF     		.align	2
 635              	.L28:
 636 02e8 00000000 		.word	sys_position
 637 02ec 00000000 		.word	sys
 638 02f0 94000000 		.word	st
 639 02f4 BC000000 		.word	segment_buffer_tail
 640 02f8 BF000000 		.word	step_port_invert_mask
 641 02fc C1000000 		.word	busy
 642              		.cfi_endproc
 643              	.LFE66:
 644              		.size	stepper_timer_isr, .-stepper_timer_isr
 645              		.section	.text.st_generate_step_dir_invert_masks,"ax",%progbits
 646              		.align	2
 647              		.global	st_generate_step_dir_invert_masks
 648              		.thumb
 649              		.thumb_func
 650              		.type	st_generate_step_dir_invert_masks, %function
 651              	st_generate_step_dir_invert_masks:
 652              	.LFB67:
 501:stepper.c     **** 
 502:stepper.c     **** 
 503:stepper.c     **** /* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step
 504:stepper.c     ****    pulse. This should always trigger before the next Timer1 COMPA interrupt and independently
 505:stepper.c     ****    finish, if Timer1 is disabled after completing a move.
 506:stepper.c     ****    NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by
 507:stepper.c     ****    a few microseconds, if they execute right before one another. Not a big deal, but can
 508:stepper.c     ****    cause issues at high step rates if another high frequency asynchronous interrupt is
 509:stepper.c     ****    added to Grbl.
 510:stepper.c     **** */
 511:stepper.c     **** // This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
 512:stepper.c     **** // a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
 513:stepper.c     **** // completing one step cycle.
 514:stepper.c     **** /*  don't need for PSoc
 515:stepper.c     **** ISR(TIMER0_OVF_vect)
 516:stepper.c     **** {
 517:stepper.c     ****   // Reset stepping pins (leave the direction pins)
 518:stepper.c     ****   STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
 519:stepper.c     ****   TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
 520:stepper.c     **** }
 521:stepper.c     **** */
 522:stepper.c     **** #ifdef STEP_PULSE_DELAY
 523:stepper.c     ****   // Not needed in PSoC
 524:stepper.c     **** #endif
 525:stepper.c     **** 
 526:stepper.c     **** 
 527:stepper.c     **** // Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
 528:stepper.c     **** void st_generate_step_dir_invert_masks()
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 22


 529:stepper.c     **** {
 653              		.loc 1 529 0
 654              		.cfi_startproc
 655              		@ args = 0, pretend = 0, frame = 8
 656              		@ frame_needed = 1, uses_anonymous_args = 0
 657 0000 80B5     		push	{r7, lr}
 658              		.cfi_def_cfa_offset 8
 659              		.cfi_offset 7, -8
 660              		.cfi_offset 14, -4
 661 0002 82B0     		sub	sp, sp, #8
 662              		.cfi_def_cfa_offset 16
 663 0004 00AF     		add	r7, sp, #0
 664              		.cfi_def_cfa_register 7
 530:stepper.c     ****   uint8_t idx;
 531:stepper.c     ****   step_port_invert_mask = 0;
 665              		.loc 1 531 0
 666 0006 204B     		ldr	r3, .L35
 667 0008 0022     		movs	r2, #0
 668 000a 1A70     		strb	r2, [r3]
 532:stepper.c     ****   dir_port_invert_mask = 0;
 669              		.loc 1 532 0
 670 000c 1F4B     		ldr	r3, .L35+4
 671 000e 0022     		movs	r2, #0
 672 0010 1A70     		strb	r2, [r3]
 533:stepper.c     ****   for (idx=0; idx<N_AXIS; idx++) {
 673              		.loc 1 533 0
 674 0012 0023     		movs	r3, #0
 675 0014 FB71     		strb	r3, [r7, #7]
 676 0016 30E0     		b	.L31
 677              	.L34:
 534:stepper.c     ****     if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mas
 678              		.loc 1 534 0
 679 0018 1D4B     		ldr	r3, .L35+8
 680 001a 93F83130 		ldrb	r3, [r3, #49]	@ zero_extendqisi2
 681 001e 1A46     		mov	r2, r3
 682 0020 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 683 0022 42FA03F3 		asr	r3, r2, r3
 684 0026 03F00103 		and	r3, r3, #1
 685 002a 002B     		cmp	r3, #0
 686 002c 0BD0     		beq	.L32
 687              		.loc 1 534 0 is_stmt 0 discriminator 1
 688 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 689 0030 1846     		mov	r0, r3
 690 0032 FFF7FEFF 		bl	get_step_pin_mask
 691 0036 0346     		mov	r3, r0
 692 0038 1A46     		mov	r2, r3
 693 003a 134B     		ldr	r3, .L35
 694 003c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 695 003e 1343     		orrs	r3, r3, r2
 696 0040 DAB2     		uxtb	r2, r3
 697 0042 114B     		ldr	r3, .L35
 698 0044 1A70     		strb	r2, [r3]
 699              	.L32:
 535:stepper.c     ****     if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_
 700              		.loc 1 535 0 is_stmt 1
 701 0046 124B     		ldr	r3, .L35+8
 702 0048 93F83230 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 23


 703 004c 1A46     		mov	r2, r3
 704 004e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 705 0050 42FA03F3 		asr	r3, r2, r3
 706 0054 03F00103 		and	r3, r3, #1
 707 0058 002B     		cmp	r3, #0
 708 005a 0BD0     		beq	.L33
 709              		.loc 1 535 0 is_stmt 0 discriminator 1
 710 005c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 711 005e 1846     		mov	r0, r3
 712 0060 FFF7FEFF 		bl	get_direction_pin_mask
 713 0064 0346     		mov	r3, r0
 714 0066 1A46     		mov	r2, r3
 715 0068 084B     		ldr	r3, .L35+4
 716 006a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 717 006c 1343     		orrs	r3, r3, r2
 718 006e DAB2     		uxtb	r2, r3
 719 0070 064B     		ldr	r3, .L35+4
 720 0072 1A70     		strb	r2, [r3]
 721              	.L33:
 533:stepper.c     ****   for (idx=0; idx<N_AXIS; idx++) {
 722              		.loc 1 533 0 is_stmt 1 discriminator 2
 723 0074 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 724 0076 0133     		adds	r3, r3, #1
 725 0078 FB71     		strb	r3, [r7, #7]
 726              	.L31:
 533:stepper.c     ****   for (idx=0; idx<N_AXIS; idx++) {
 727              		.loc 1 533 0 is_stmt 0 discriminator 1
 728 007a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 729 007c 022B     		cmp	r3, #2
 730 007e CBD9     		bls	.L34
 536:stepper.c     ****   }
 537:stepper.c     **** }
 731              		.loc 1 537 0 is_stmt 1
 732 0080 00BF     		nop
 733 0082 0837     		adds	r7, r7, #8
 734              		.cfi_def_cfa_offset 8
 735 0084 BD46     		mov	sp, r7
 736              		.cfi_def_cfa_register 13
 737              		@ sp needed
 738 0086 80BD     		pop	{r7, pc}
 739              	.L36:
 740              		.align	2
 741              	.L35:
 742 0088 BF000000 		.word	step_port_invert_mask
 743 008c C0000000 		.word	dir_port_invert_mask
 744 0090 00000000 		.word	settings
 745              		.cfi_endproc
 746              	.LFE67:
 747              		.size	st_generate_step_dir_invert_masks, .-st_generate_step_dir_invert_masks
 748              		.section	.text.st_reset,"ax",%progbits
 749              		.align	2
 750              		.global	st_reset
 751              		.thumb
 752              		.thumb_func
 753              		.type	st_reset, %function
 754              	st_reset:
 755              	.LFB68:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 24


 538:stepper.c     **** 
 539:stepper.c     **** 
 540:stepper.c     **** // Reset and clear stepper subsystem variables
 541:stepper.c     **** void st_reset()
 542:stepper.c     **** {
 756              		.loc 1 542 0
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 0
 759              		@ frame_needed = 1, uses_anonymous_args = 0
 760 0000 80B5     		push	{r7, lr}
 761              		.cfi_def_cfa_offset 8
 762              		.cfi_offset 7, -8
 763              		.cfi_offset 14, -4
 764 0002 00AF     		add	r7, sp, #0
 765              		.cfi_def_cfa_register 7
 543:stepper.c     ****   // Initialize stepper driver idle state.
 544:stepper.c     ****   st_go_idle();
 766              		.loc 1 544 0
 767 0004 FFF7FEFF 		bl	st_go_idle
 545:stepper.c     **** 
 546:stepper.c     ****   // Initialize stepper algorithm variables.
 547:stepper.c     ****   memset(&prep, 0, sizeof(st_prep_t));
 768              		.loc 1 547 0
 769 0008 3822     		movs	r2, #56
 770 000a 0021     		movs	r1, #0
 771 000c 1848     		ldr	r0, .L38
 772 000e FFF7FEFF 		bl	memset
 548:stepper.c     ****   memset(&st, 0, sizeof(stepper_t));
 773              		.loc 1 548 0
 774 0012 2822     		movs	r2, #40
 775 0014 0021     		movs	r1, #0
 776 0016 1748     		ldr	r0, .L38+4
 777 0018 FFF7FEFF 		bl	memset
 549:stepper.c     ****   st.exec_segment = NULL;
 778              		.loc 1 549 0
 779 001c 154B     		ldr	r3, .L38+4
 780 001e 0022     		movs	r2, #0
 781 0020 5A62     		str	r2, [r3, #36]
 550:stepper.c     ****   pl_block = NULL;  // Planner block pointer used by segment buffer
 782              		.loc 1 550 0
 783 0022 154B     		ldr	r3, .L38+8
 784 0024 0022     		movs	r2, #0
 785 0026 1A60     		str	r2, [r3]
 551:stepper.c     ****   segment_buffer_tail = 0;
 786              		.loc 1 551 0
 787 0028 144B     		ldr	r3, .L38+12
 788 002a 0022     		movs	r2, #0
 789 002c 1A70     		strb	r2, [r3]
 552:stepper.c     ****   segment_buffer_head = 0; // empty = tail
 790              		.loc 1 552 0
 791 002e 144B     		ldr	r3, .L38+16
 792 0030 0022     		movs	r2, #0
 793 0032 1A70     		strb	r2, [r3]
 553:stepper.c     ****   segment_next_head = 1;
 794              		.loc 1 553 0
 795 0034 134B     		ldr	r3, .L38+20
 796 0036 0122     		movs	r2, #1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 25


 797 0038 1A70     		strb	r2, [r3]
 554:stepper.c     ****   busy = false;
 798              		.loc 1 554 0
 799 003a 134B     		ldr	r3, .L38+24
 800 003c 0022     		movs	r2, #0
 801 003e 1A70     		strb	r2, [r3]
 555:stepper.c     **** 
 556:stepper.c     ****   st_generate_step_dir_invert_masks();
 802              		.loc 1 556 0
 803 0040 FFF7FEFF 		bl	st_generate_step_dir_invert_masks
 557:stepper.c     ****   st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
 804              		.loc 1 557 0
 805 0044 114B     		ldr	r3, .L38+28
 806 0046 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 807 0048 0A4B     		ldr	r3, .L38+4
 808 004a DA73     		strb	r2, [r3, #15]
 558:stepper.c     **** 
 559:stepper.c     ****   // Initialize step and direction port pins.
 560:stepper.c     ****   Control_Reg_Step_Write(0b111 | step_port_invert_mask);
 809              		.loc 1 560 0
 810 004c 104B     		ldr	r3, .L38+32
 811 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 812 0050 43F00703 		orr	r3, r3, #7
 813 0054 DBB2     		uxtb	r3, r3
 814 0056 1846     		mov	r0, r3
 815 0058 FFF7FEFF 		bl	Control_Reg_Step_Write
 561:stepper.c     ****   //STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
 562:stepper.c     ****   Control_Reg_Dir_Write(0b111 | dir_port_invert_mask);
 816              		.loc 1 562 0
 817 005c 0B4B     		ldr	r3, .L38+28
 818 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 819 0060 43F00703 		orr	r3, r3, #7
 820 0064 DBB2     		uxtb	r3, r3
 821 0066 1846     		mov	r0, r3
 822 0068 FFF7FEFF 		bl	Control_Reg_Dir_Write
 563:stepper.c     ****   //DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
 564:stepper.c     **** }
 823              		.loc 1 564 0
 824 006c 00BF     		nop
 825 006e 80BD     		pop	{r7, pc}
 826              	.L39:
 827              		.align	2
 828              	.L38:
 829 0070 CC000000 		.word	prep
 830 0074 94000000 		.word	st
 831 0078 C4000000 		.word	pl_block
 832 007c BC000000 		.word	segment_buffer_tail
 833 0080 BD000000 		.word	segment_buffer_head
 834 0084 BE000000 		.word	segment_next_head
 835 0088 C1000000 		.word	busy
 836 008c C0000000 		.word	dir_port_invert_mask
 837 0090 BF000000 		.word	step_port_invert_mask
 838              		.cfi_endproc
 839              	.LFE68:
 840              		.size	st_reset, .-st_reset
 841              		.section	.text.stepper_init,"ax",%progbits
 842              		.align	2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 26


 843              		.global	stepper_init
 844              		.thumb
 845              		.thumb_func
 846              		.type	stepper_init, %function
 847              	stepper_init:
 848              	.LFB69:
 565:stepper.c     **** 
 566:stepper.c     **** 
 567:stepper.c     **** // Initialize and start the stepper motor subsystem
 568:stepper.c     **** void stepper_init()
 569:stepper.c     **** {
 849              		.loc 1 569 0
 850              		.cfi_startproc
 851              		@ args = 0, pretend = 0, frame = 0
 852              		@ frame_needed = 1, uses_anonymous_args = 0
 853 0000 80B5     		push	{r7, lr}
 854              		.cfi_def_cfa_offset 8
 855              		.cfi_offset 7, -8
 856              		.cfi_offset 14, -4
 857 0002 00AF     		add	r7, sp, #0
 858              		.cfi_def_cfa_register 7
 570:stepper.c     ****   Clock_Step_Pulse_Start();
 859              		.loc 1 570 0
 860 0004 FFF7FEFF 		bl	Clock_Step_Pulse_Start
 571:stepper.c     ****   isr_Step_StartEx(stepper_timer_isr);
 861              		.loc 1 571 0
 862 0008 0248     		ldr	r0, .L41
 863 000a FFF7FEFF 		bl	isr_Step_StartEx
 572:stepper.c     **** }
 864              		.loc 1 572 0
 865 000e 00BF     		nop
 866 0010 80BD     		pop	{r7, pc}
 867              	.L42:
 868 0012 00BF     		.align	2
 869              	.L41:
 870 0014 00000000 		.word	stepper_timer_isr
 871              		.cfi_endproc
 872              	.LFE69:
 873              		.size	stepper_init, .-stepper_init
 874              		.global	__aeabi_fmul
 875              		.section	.text.st_update_plan_block_parameters,"ax",%progbits
 876              		.align	2
 877              		.global	st_update_plan_block_parameters
 878              		.thumb
 879              		.thumb_func
 880              		.type	st_update_plan_block_parameters, %function
 881              	st_update_plan_block_parameters:
 882              	.LFB70:
 573:stepper.c     **** 
 574:stepper.c     **** 
 575:stepper.c     **** // Called by planner_recalculate() when the executing block is updated by the new plan.
 576:stepper.c     **** void st_update_plan_block_parameters()
 577:stepper.c     **** {
 883              		.loc 1 577 0
 884              		.cfi_startproc
 885              		@ args = 0, pretend = 0, frame = 0
 886              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 27


 887 0000 98B5     		push	{r3, r4, r7, lr}
 888              		.cfi_def_cfa_offset 16
 889              		.cfi_offset 3, -16
 890              		.cfi_offset 4, -12
 891              		.cfi_offset 7, -8
 892              		.cfi_offset 14, -4
 893 0002 00AF     		add	r7, sp, #0
 894              		.cfi_def_cfa_register 7
 578:stepper.c     ****   if (pl_block != NULL) { // Ignore if at start of a new block.
 895              		.loc 1 578 0
 896 0004 0D4B     		ldr	r3, .L46
 897 0006 1B68     		ldr	r3, [r3]
 898 0008 002B     		cmp	r3, #0
 899 000a 15D0     		beq	.L45
 579:stepper.c     ****     prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
 900              		.loc 1 579 0
 901 000c 0C4B     		ldr	r3, .L46+4
 902 000e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 903 0010 43F00103 		orr	r3, r3, #1
 904 0014 DAB2     		uxtb	r2, r3
 905 0016 0A4B     		ldr	r3, .L46+4
 906 0018 5A70     		strb	r2, [r3, #1]
 580:stepper.c     ****     pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
 907              		.loc 1 580 0
 908 001a 084B     		ldr	r3, .L46
 909 001c 1C68     		ldr	r4, [r3]
 910 001e 084B     		ldr	r3, .L46+4
 911 0020 DA69     		ldr	r2, [r3, #28]	@ float
 912 0022 074B     		ldr	r3, .L46+4
 913 0024 DB69     		ldr	r3, [r3, #28]	@ float
 914 0026 1946     		mov	r1, r3
 915 0028 1046     		mov	r0, r2
 916 002a FFF7FEFF 		bl	__aeabi_fmul
 917 002e 0346     		mov	r3, r0
 918 0030 6361     		str	r3, [r4, #20]	@ float
 581:stepper.c     ****     pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 919              		.loc 1 581 0
 920 0032 024B     		ldr	r3, .L46
 921 0034 0022     		movs	r2, #0
 922 0036 1A60     		str	r2, [r3]
 923              	.L45:
 582:stepper.c     ****   }
 583:stepper.c     **** }
 924              		.loc 1 583 0
 925 0038 00BF     		nop
 926 003a 98BD     		pop	{r3, r4, r7, pc}
 927              	.L47:
 928              		.align	2
 929              	.L46:
 930 003c C4000000 		.word	pl_block
 931 0040 CC000000 		.word	prep
 932              		.cfi_endproc
 933              	.LFE70:
 934              		.size	st_update_plan_block_parameters, .-st_update_plan_block_parameters
 935              		.section	.text.st_next_block_index,"ax",%progbits
 936              		.align	2
 937              		.thumb
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 28


 938              		.thumb_func
 939              		.type	st_next_block_index, %function
 940              	st_next_block_index:
 941              	.LFB71:
 584:stepper.c     **** 
 585:stepper.c     **** 
 586:stepper.c     **** // Increments the step segment buffer block data ring buffer.
 587:stepper.c     **** static uint8_t st_next_block_index(uint8_t block_index)
 588:stepper.c     **** {
 942              		.loc 1 588 0
 943              		.cfi_startproc
 944              		@ args = 0, pretend = 0, frame = 8
 945              		@ frame_needed = 1, uses_anonymous_args = 0
 946              		@ link register save eliminated.
 947 0000 80B4     		push	{r7}
 948              		.cfi_def_cfa_offset 4
 949              		.cfi_offset 7, -4
 950 0002 83B0     		sub	sp, sp, #12
 951              		.cfi_def_cfa_offset 16
 952 0004 00AF     		add	r7, sp, #0
 953              		.cfi_def_cfa_register 7
 954 0006 0346     		mov	r3, r0
 955 0008 FB71     		strb	r3, [r7, #7]
 589:stepper.c     ****   block_index++;
 956              		.loc 1 589 0
 957 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 958 000c 0133     		adds	r3, r3, #1
 959 000e FB71     		strb	r3, [r7, #7]
 590:stepper.c     ****   if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
 960              		.loc 1 590 0
 961 0010 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 962 0012 052B     		cmp	r3, #5
 963 0014 01D1     		bne	.L49
 964              		.loc 1 590 0 is_stmt 0 discriminator 1
 965 0016 0023     		movs	r3, #0
 966 0018 00E0     		b	.L50
 967              	.L49:
 591:stepper.c     ****   return(block_index);
 968              		.loc 1 591 0 is_stmt 1
 969 001a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 970              	.L50:
 592:stepper.c     **** }
 971              		.loc 1 592 0
 972 001c 1846     		mov	r0, r3
 973 001e 0C37     		adds	r7, r7, #12
 974              		.cfi_def_cfa_offset 4
 975 0020 BD46     		mov	sp, r7
 976              		.cfi_def_cfa_register 13
 977              		@ sp needed
 978 0022 80BC     		pop	{r7}
 979              		.cfi_restore 7
 980              		.cfi_def_cfa_offset 0
 981 0024 7047     		bx	lr
 982              		.cfi_endproc
 983              	.LFE71:
 984              		.size	st_next_block_index, .-st_next_block_index
 985              		.global	__aeabi_ui2f
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 29


 986              		.global	__aeabi_fdiv
 987              		.global	__aeabi_f2d
 988              		.global	__aeabi_d2f
 989              		.global	__aeabi_fsub
 990              		.global	__aeabi_fcmplt
 991              		.global	__aeabi_fadd
 992              		.global	__aeabi_fcmpgt
 993              		.global	__aeabi_fcmple
 994              		.global	__aeabi_fcmpeq
 995              		.global	__aeabi_dadd
 996              		.global	__aeabi_dmul
 997              		.global	__aeabi_dsub
 998              		.global	__aeabi_ddiv
 999              		.global	__aeabi_f2iz
 1000              		.global	__aeabi_f2uiz
 1001              		.global	__aeabi_d2uiz
 1002 0026 00BF     		.section	.text.st_prep_buffer,"ax",%progbits
 1003              		.align	2
 1004              		.global	st_prep_buffer
 1005              		.thumb
 1006              		.thumb_func
 1007              		.type	st_prep_buffer, %function
 1008              	st_prep_buffer:
 1009              	.LFB72:
 593:stepper.c     **** 
 594:stepper.c     **** 
 595:stepper.c     **** #ifdef PARKING_ENABLE
 596:stepper.c     ****   // Changes the run state of the step segment buffer to execute the special parking motion.
 597:stepper.c     ****   void st_parking_setup_buffer()
 598:stepper.c     ****   {
 599:stepper.c     ****     // Store step execution data of partially completed block, if necessary.
 600:stepper.c     ****     if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
 601:stepper.c     ****       prep.last_st_block_index = prep.st_block_index;
 602:stepper.c     ****       prep.last_steps_remaining = prep.steps_remaining;
 603:stepper.c     ****       prep.last_dt_remainder = prep.dt_remainder;
 604:stepper.c     ****       prep.last_step_per_mm = prep.step_per_mm;
 605:stepper.c     ****     }
 606:stepper.c     ****     // Set flags to execute a parking motion
 607:stepper.c     ****     prep.recalculate_flag |= PREP_FLAG_PARKING;
 608:stepper.c     ****     prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE);
 609:stepper.c     ****     pl_block = NULL; // Always reset parking motion to reload new block.
 610:stepper.c     ****   }
 611:stepper.c     **** 
 612:stepper.c     **** 
 613:stepper.c     ****   // Restores the step segment buffer to the normal run state after a parking motion.
 614:stepper.c     ****   void st_parking_restore_buffer()
 615:stepper.c     ****   {
 616:stepper.c     ****     // Restore step execution data and flags of partially completed block, if necessary.
 617:stepper.c     ****     if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
 618:stepper.c     ****       st_prep_block = &st_block_buffer[prep.last_st_block_index];
 619:stepper.c     ****       prep.st_block_index = prep.last_st_block_index;
 620:stepper.c     ****       prep.steps_remaining = prep.last_steps_remaining;
 621:stepper.c     ****       prep.dt_remainder = prep.last_dt_remainder;
 622:stepper.c     ****       prep.step_per_mm = prep.last_step_per_mm;
 623:stepper.c     ****       prep.recalculate_flag = (PREP_FLAG_HOLD_PARTIAL_BLOCK | PREP_FLAG_RECALCULATE);
 624:stepper.c     ****       prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm; // Recompute this value.
 625:stepper.c     ****     } else {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 30


 626:stepper.c     ****       prep.recalculate_flag = false;
 627:stepper.c     ****     }
 628:stepper.c     ****     pl_block = NULL; // Set to reload next block.
 629:stepper.c     ****   }
 630:stepper.c     **** #endif
 631:stepper.c     **** 
 632:stepper.c     **** 
 633:stepper.c     **** /* Prepares step segment buffer. Continuously called from main program.
 634:stepper.c     **** 
 635:stepper.c     ****    The segment buffer is an intermediary buffer interface between the execution of steps
 636:stepper.c     ****    by the stepper algorithm and the velocity profiles generated by the planner. The stepper
 637:stepper.c     ****    algorithm only executes steps within the segment buffer and is filled by the main program
 638:stepper.c     ****    when steps are "checked-out" from the first block in the planner buffer. This keeps the
 639:stepper.c     ****    step execution and planning optimization processes atomic and protected from each other.
 640:stepper.c     ****    The number of steps "checked-out" from the planner buffer and the number of segments in
 641:stepper.c     ****    the segment buffer is sized and computed such that no operation in the main program takes
 642:stepper.c     ****    longer than the time it takes the stepper algorithm to empty it before refilling it.
 643:stepper.c     ****    Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
 644:stepper.c     ****    NOTE: Computation units are in steps, millimeters, and minutes.
 645:stepper.c     **** */
 646:stepper.c     **** void st_prep_buffer()
 647:stepper.c     **** {
 1010              		.loc 1 647 0
 1011              		.cfi_startproc
 1012              		@ args = 0, pretend = 0, frame = 88
 1013              		@ frame_needed = 1, uses_anonymous_args = 0
 1014 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 1015              		.cfi_def_cfa_offset 32
 1016              		.cfi_offset 4, -32
 1017              		.cfi_offset 5, -28
 1018              		.cfi_offset 7, -24
 1019              		.cfi_offset 8, -20
 1020              		.cfi_offset 9, -16
 1021              		.cfi_offset 10, -12
 1022              		.cfi_offset 11, -8
 1023              		.cfi_offset 14, -4
 1024 0004 96B0     		sub	sp, sp, #88
 1025              		.cfi_def_cfa_offset 120
 1026 0006 00AF     		add	r7, sp, #0
 1027              		.cfi_def_cfa_register 7
 648:stepper.c     ****   // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
 649:stepper.c     ****   if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
 1028              		.loc 1 649 0
 1029 0008 A14B     		ldr	r3, .L170
 1030 000a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1031 000c 03F00103 		and	r3, r3, #1
 1032 0010 002B     		cmp	r3, #0
 1033 0012 40F08686 		bne	.L168
 650:stepper.c     **** 
 651:stepper.c     ****   while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 1034              		.loc 1 651 0
 1035 0016 00F07BBE 		b	.L54
 1036              	.L136:
 1037              	.LBB2:
 652:stepper.c     **** 
 653:stepper.c     ****     // Determine if we need to load a new planner block or if the block needs to be recomputed.
 654:stepper.c     ****     if (pl_block == NULL) {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 31


 1038              		.loc 1 654 0
 1039 001a 9E4B     		ldr	r3, .L170+4
 1040 001c 1B68     		ldr	r3, [r3]
 1041 001e 002B     		cmp	r3, #0
 1042 0020 40F0B982 		bne	.L55
 1043              	.LBB3:
 655:stepper.c     **** 
 656:stepper.c     ****       // Query planner for a queued block
 657:stepper.c     ****       if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_b
 1044              		.loc 1 657 0
 1045 0024 9A4B     		ldr	r3, .L170
 1046 0026 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1047 0028 03F00403 		and	r3, r3, #4
 1048 002c 002B     		cmp	r3, #0
 1049 002e 05D0     		beq	.L56
 1050              		.loc 1 657 0 is_stmt 0 discriminator 1
 1051 0030 FFF7FEFF 		bl	plan_get_system_motion_block
 1052 0034 0246     		mov	r2, r0
 1053 0036 974B     		ldr	r3, .L170+4
 1054 0038 1A60     		str	r2, [r3]
 1055 003a 04E0     		b	.L57
 1056              	.L56:
 658:stepper.c     ****       else { pl_block = plan_get_current_block(); }
 1057              		.loc 1 658 0 is_stmt 1
 1058 003c FFF7FEFF 		bl	plan_get_current_block
 1059 0040 0246     		mov	r2, r0
 1060 0042 944B     		ldr	r3, .L170+4
 1061 0044 1A60     		str	r2, [r3]
 1062              	.L57:
 659:stepper.c     ****       if (pl_block == NULL) { return; } // No planner blocks. Exit.
 1063              		.loc 1 659 0
 1064 0046 934B     		ldr	r3, .L170+4
 1065 0048 1B68     		ldr	r3, [r3]
 1066 004a 002B     		cmp	r3, #0
 1067 004c 00F06B86 		beq	.L169
 660:stepper.c     **** 
 661:stepper.c     ****       // Check if we need to only recompute the velocity profile or load a new block.
 662:stepper.c     ****       if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
 1068              		.loc 1 662 0
 1069 0050 914B     		ldr	r3, .L170+8
 1070 0052 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1071 0054 03F00103 		and	r3, r3, #1
 1072 0058 002B     		cmp	r3, #0
 1073 005a 03D0     		beq	.L59
 663:stepper.c     **** 
 664:stepper.c     ****         #ifdef PARKING_ENABLE
 665:stepper.c     ****           if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_REC
 666:stepper.c     ****           else { prep.recalculate_flag = false; }
 667:stepper.c     ****         #else
 668:stepper.c     ****           prep.recalculate_flag = false;
 1074              		.loc 1 668 0
 1075 005c 8E4B     		ldr	r3, .L170+8
 1076 005e 0022     		movs	r2, #0
 1077 0060 5A70     		strb	r2, [r3, #1]
 1078 0062 B9E0     		b	.L60
 1079              	.L59:
 1080              	.LBB4:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 32


 669:stepper.c     ****         #endif
 670:stepper.c     **** 
 671:stepper.c     ****       } else {
 672:stepper.c     **** 
 673:stepper.c     ****         // Load the Bresenham stepping data for the block.
 674:stepper.c     ****         prep.st_block_index = st_next_block_index(prep.st_block_index);
 1081              		.loc 1 674 0
 1082 0064 8C4B     		ldr	r3, .L170+8
 1083 0066 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1084 0068 1846     		mov	r0, r3
 1085 006a FFF7FEFF 		bl	st_next_block_index
 1086 006e 0346     		mov	r3, r0
 1087 0070 1A46     		mov	r2, r3
 1088 0072 894B     		ldr	r3, .L170+8
 1089 0074 1A70     		strb	r2, [r3]
 675:stepper.c     **** 
 676:stepper.c     ****         // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
 677:stepper.c     ****         // when the segment buffer completes the planner block, it may be discarded when the
 678:stepper.c     ****         // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
 679:stepper.c     ****         st_prep_block = &st_block_buffer[prep.st_block_index];
 1090              		.loc 1 679 0
 1091 0076 884B     		ldr	r3, .L170+8
 1092 0078 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1093 007a 1A46     		mov	r2, r3
 1094 007c 1346     		mov	r3, r2
 1095 007e 9B00     		lsls	r3, r3, #2
 1096 0080 1344     		add	r3, r3, r2
 1097 0082 9B00     		lsls	r3, r3, #2
 1098 0084 854A     		ldr	r2, .L170+12
 1099 0086 1344     		add	r3, r3, r2
 1100 0088 854A     		ldr	r2, .L170+16
 1101 008a 1360     		str	r3, [r2]
 680:stepper.c     ****         st_prep_block->direction_bits = pl_block->direction_bits;
 1102              		.loc 1 680 0
 1103 008c 844B     		ldr	r3, .L170+16
 1104 008e 1B68     		ldr	r3, [r3]
 1105 0090 804A     		ldr	r2, .L170+4
 1106 0092 1268     		ldr	r2, [r2]
 1107 0094 127C     		ldrb	r2, [r2, #16]	@ zero_extendqisi2
 1108 0096 1A74     		strb	r2, [r3, #16]
 681:stepper.c     ****         uint8_t idx;
 682:stepper.c     ****         #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 683:stepper.c     ****           for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx]; }
 684:stepper.c     ****           st_prep_block->step_event_count = pl_block->step_event_count;
 685:stepper.c     ****         #else
 686:stepper.c     ****           // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
 687:stepper.c     ****           // level, such that we never divide beyond the original data anywhere in the algorithm.
 688:stepper.c     ****           // If the original data is divided, we can lose a step from integer roundoff.
 689:stepper.c     ****           for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_
 1109              		.loc 1 689 0
 1110 0098 0023     		movs	r3, #0
 1111 009a 87F85730 		strb	r3, [r7, #87]
 1112 009e 11E0     		b	.L61
 1113              	.L62:
 1114              		.loc 1 689 0 is_stmt 0 discriminator 3
 1115 00a0 7F4B     		ldr	r3, .L170+16
 1116 00a2 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 33


 1117 00a4 97F85720 		ldrb	r2, [r7, #87]	@ zero_extendqisi2
 1118 00a8 7A49     		ldr	r1, .L170+4
 1119 00aa 0968     		ldr	r1, [r1]
 1120 00ac 97F85700 		ldrb	r0, [r7, #87]	@ zero_extendqisi2
 1121 00b0 51F82010 		ldr	r1, [r1, r0, lsl #2]
 1122 00b4 C900     		lsls	r1, r1, #3
 1123 00b6 43F82210 		str	r1, [r3, r2, lsl #2]
 1124 00ba 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 1125 00be 0133     		adds	r3, r3, #1
 1126 00c0 87F85730 		strb	r3, [r7, #87]
 1127              	.L61:
 1128              		.loc 1 689 0 discriminator 1
 1129 00c4 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 1130 00c8 022B     		cmp	r3, #2
 1131 00ca E9D9     		bls	.L62
 690:stepper.c     ****           st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 1132              		.loc 1 690 0 is_stmt 1
 1133 00cc 744B     		ldr	r3, .L170+16
 1134 00ce 1B68     		ldr	r3, [r3]
 1135 00d0 704A     		ldr	r2, .L170+4
 1136 00d2 1268     		ldr	r2, [r2]
 1137 00d4 D268     		ldr	r2, [r2, #12]
 1138 00d6 D200     		lsls	r2, r2, #3
 1139 00d8 DA60     		str	r2, [r3, #12]
 691:stepper.c     ****         #endif
 692:stepper.c     **** 
 693:stepper.c     ****         // Initialize segment buffer data for generating the segments.
 694:stepper.c     ****         prep.steps_remaining = (float)pl_block->step_event_count;
 1140              		.loc 1 694 0
 1141 00da 6E4B     		ldr	r3, .L170+4
 1142 00dc 1B68     		ldr	r3, [r3]
 1143 00de DB68     		ldr	r3, [r3, #12]
 1144 00e0 1846     		mov	r0, r3
 1145 00e2 FFF7FEFF 		bl	__aeabi_ui2f
 1146 00e6 0246     		mov	r2, r0
 1147 00e8 6B4B     		ldr	r3, .L170+8
 1148 00ea 9A60     		str	r2, [r3, #8]	@ float
 695:stepper.c     ****         prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
 1149              		.loc 1 695 0
 1150 00ec 6A4B     		ldr	r3, .L170+8
 1151 00ee 9A68     		ldr	r2, [r3, #8]	@ float
 1152 00f0 684B     		ldr	r3, .L170+4
 1153 00f2 1B68     		ldr	r3, [r3]
 1154 00f4 1B6A     		ldr	r3, [r3, #32]	@ float
 1155 00f6 1946     		mov	r1, r3
 1156 00f8 1046     		mov	r0, r2
 1157 00fa FFF7FEFF 		bl	__aeabi_fdiv
 1158 00fe 0346     		mov	r3, r0
 1159 0100 1A46     		mov	r2, r3
 1160 0102 654B     		ldr	r3, .L170+8
 1161 0104 DA60     		str	r2, [r3, #12]	@ float
 696:stepper.c     ****         prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
 1162              		.loc 1 696 0
 1163 0106 644B     		ldr	r3, .L170+8
 1164 0108 DB68     		ldr	r3, [r3, #12]	@ float
 1165 010a 1946     		mov	r1, r3
 1166 010c 6548     		ldr	r0, .L170+20
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 34


 1167 010e FFF7FEFF 		bl	__aeabi_fdiv
 1168 0112 0346     		mov	r3, r0
 1169 0114 1A46     		mov	r2, r3
 1170 0116 604B     		ldr	r3, .L170+8
 1171 0118 1A61     		str	r2, [r3, #16]	@ float
 697:stepper.c     ****         prep.dt_remainder = 0.0; // Reset for new segment block
 1172              		.loc 1 697 0
 1173 011a 5F4B     		ldr	r3, .L170+8
 1174 011c 4FF00002 		mov	r2, #0
 1175 0120 5A60     		str	r2, [r3, #4]	@ float
 698:stepper.c     **** 
 699:stepper.c     ****         if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DE
 1176              		.loc 1 699 0
 1177 0122 5B4B     		ldr	r3, .L170
 1178 0124 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1179 0126 03F00203 		and	r3, r3, #2
 1180 012a 002B     		cmp	r3, #0
 1181 012c 05D1     		bne	.L63
 1182              		.loc 1 699 0 is_stmt 0 discriminator 1
 1183 012e 5A4B     		ldr	r3, .L170+8
 1184 0130 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1185 0132 03F00803 		and	r3, r3, #8
 1186 0136 002B     		cmp	r3, #0
 1187 0138 17D0     		beq	.L64
 1188              	.L63:
 700:stepper.c     ****           // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
 701:stepper.c     ****           prep.current_speed = prep.exit_speed;
 1189              		.loc 1 701 0 is_stmt 1
 1190 013a 574B     		ldr	r3, .L170+8
 1191 013c 5B6A     		ldr	r3, [r3, #36]	@ float
 1192 013e 564A     		ldr	r2, .L170+8
 1193 0140 D361     		str	r3, [r2, #28]	@ float
 702:stepper.c     ****           pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
 1194              		.loc 1 702 0
 1195 0142 544B     		ldr	r3, .L170+4
 1196 0144 1C68     		ldr	r4, [r3]
 1197 0146 544B     		ldr	r3, .L170+8
 1198 0148 5A6A     		ldr	r2, [r3, #36]	@ float
 1199 014a 534B     		ldr	r3, .L170+8
 1200 014c 5B6A     		ldr	r3, [r3, #36]	@ float
 1201 014e 1946     		mov	r1, r3
 1202 0150 1046     		mov	r0, r2
 1203 0152 FFF7FEFF 		bl	__aeabi_fmul
 1204 0156 0346     		mov	r3, r0
 1205 0158 6361     		str	r3, [r4, #20]	@ float
 703:stepper.c     ****           prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
 1206              		.loc 1 703 0
 1207 015a 4F4B     		ldr	r3, .L170+8
 1208 015c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1209 015e 23F00803 		bic	r3, r3, #8
 1210 0162 DAB2     		uxtb	r2, r3
 1211 0164 4C4B     		ldr	r3, .L170+8
 1212 0166 5A70     		strb	r2, [r3, #1]
 1213 0168 14E0     		b	.L65
 1214              	.L64:
 704:stepper.c     ****         } else {
 705:stepper.c     ****           prep.current_speed = sqrt(pl_block->entry_speed_sqr);
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 35


 1215              		.loc 1 705 0
 1216 016a 4A4B     		ldr	r3, .L170+4
 1217 016c 1B68     		ldr	r3, [r3]
 1218 016e 5B69     		ldr	r3, [r3, #20]	@ float
 1219 0170 1846     		mov	r0, r3
 1220 0172 FFF7FEFF 		bl	__aeabi_f2d
 1221 0176 0346     		mov	r3, r0
 1222 0178 0C46     		mov	r4, r1
 1223 017a 1846     		mov	r0, r3
 1224 017c 2146     		mov	r1, r4
 1225 017e FFF7FEFF 		bl	sqrt
 1226 0182 0346     		mov	r3, r0
 1227 0184 0C46     		mov	r4, r1
 1228 0186 1846     		mov	r0, r3
 1229 0188 2146     		mov	r1, r4
 1230 018a FFF7FEFF 		bl	__aeabi_d2f
 1231 018e 0246     		mov	r2, r0
 1232 0190 414B     		ldr	r3, .L170+8
 1233 0192 DA61     		str	r2, [r3, #28]	@ float
 1234              	.L65:
 706:stepper.c     ****         }
 707:stepper.c     ****         
 708:stepper.c     ****         #ifdef VARIABLE_SPINDLE
 709:stepper.c     ****           // Setup laser mode variables. PWM rate adjusted motions will always complete a motion wi
 710:stepper.c     ****           // spindle off. 
 711:stepper.c     ****           st_prep_block->is_pwm_rate_adjusted = false;
 1235              		.loc 1 711 0
 1236 0194 424B     		ldr	r3, .L170+16
 1237 0196 1B68     		ldr	r3, [r3]
 1238 0198 0022     		movs	r2, #0
 1239 019a 5A74     		strb	r2, [r3, #17]
 712:stepper.c     ****           if (settings.flags & BITFLAG_LASER_MODE) {
 1240              		.loc 1 712 0
 1241 019c 424B     		ldr	r3, .L170+24
 1242 019e 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1243 01a2 03F00203 		and	r3, r3, #2
 1244 01a6 002B     		cmp	r3, #0
 1245 01a8 16D0     		beq	.L60
 713:stepper.c     ****             if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
 1246              		.loc 1 713 0
 1247 01aa 3A4B     		ldr	r3, .L170+4
 1248 01ac 1B68     		ldr	r3, [r3]
 1249 01ae 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1250 01b0 03F02003 		and	r3, r3, #32
 1251 01b4 002B     		cmp	r3, #0
 1252 01b6 0FD0     		beq	.L60
 714:stepper.c     ****               // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
 715:stepper.c     ****               prep.inv_rate = 1.0/pl_block->programmed_rate;
 1253              		.loc 1 715 0
 1254 01b8 364B     		ldr	r3, .L170+4
 1255 01ba 1B68     		ldr	r3, [r3]
 1256 01bc DB6A     		ldr	r3, [r3, #44]	@ float
 1257 01be 1946     		mov	r1, r3
 1258 01c0 4FF07E50 		mov	r0, #1065353216
 1259 01c4 FFF7FEFF 		bl	__aeabi_fdiv
 1260 01c8 0346     		mov	r3, r0
 1261 01ca 1A46     		mov	r2, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 36


 1262 01cc 324B     		ldr	r3, .L170+8
 1263 01ce 1A63     		str	r2, [r3, #48]	@ float
 716:stepper.c     ****               st_prep_block->is_pwm_rate_adjusted = true; 
 1264              		.loc 1 716 0
 1265 01d0 334B     		ldr	r3, .L170+16
 1266 01d2 1B68     		ldr	r3, [r3]
 1267 01d4 0122     		movs	r2, #1
 1268 01d6 5A74     		strb	r2, [r3, #17]
 1269              	.L60:
 1270              	.LBE4:
 717:stepper.c     ****             }
 718:stepper.c     ****           }
 719:stepper.c     ****         #endif
 720:stepper.c     ****       }
 721:stepper.c     **** 
 722:stepper.c     **** 			/* ---------------------------------------------------------------------------------
 723:stepper.c     **** 			 Compute the velocity profile of a new planner block based on its entry and exit
 724:stepper.c     **** 			 speeds, or recompute the profile of a partially-completed planner block if the
 725:stepper.c     **** 			 planner has updated it. For a commanded forced-deceleration, such as from a feed
 726:stepper.c     **** 			 hold, override the planner velocities and decelerate to the target exit speed.
 727:stepper.c     **** 			*/
 728:stepper.c     **** 			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
 1271              		.loc 1 728 0
 1272 01d8 2F4B     		ldr	r3, .L170+8
 1273 01da 4FF00002 		mov	r2, #0
 1274 01de 9A61     		str	r2, [r3, #24]	@ float
 729:stepper.c     **** 			float inv_2_accel = 0.5/pl_block->acceleration;
 1275              		.loc 1 729 0
 1276 01e0 2C4B     		ldr	r3, .L170+4
 1277 01e2 1B68     		ldr	r3, [r3]
 1278 01e4 DB69     		ldr	r3, [r3, #28]	@ float
 1279 01e6 1946     		mov	r1, r3
 1280 01e8 4FF07C50 		mov	r0, #1056964608
 1281 01ec FFF7FEFF 		bl	__aeabi_fdiv
 1282 01f0 0346     		mov	r3, r0
 1283 01f2 7B61     		str	r3, [r7, #20]	@ float
 730:stepper.c     **** 			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
 1284              		.loc 1 730 0
 1285 01f4 264B     		ldr	r3, .L170
 1286 01f6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1287 01f8 03F00203 		and	r3, r3, #2
 1288 01fc 002B     		cmp	r3, #0
 1289 01fe 5DD0     		beq	.L66
 1290              	.LBB5:
 731:stepper.c     **** 				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
 732:stepper.c     **** 				// the planner block profile, enforcing a deceleration to zero speed.
 733:stepper.c     **** 				prep.ramp_type = RAMP_DECEL;
 1291              		.loc 1 733 0
 1292 0200 254B     		ldr	r3, .L170+8
 1293 0202 0222     		movs	r2, #2
 1294 0204 1A75     		strb	r2, [r3, #20]
 734:stepper.c     **** 				// Compute decelerate distance relative to end of block.
 735:stepper.c     **** 				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
 1295              		.loc 1 735 0
 1296 0206 234B     		ldr	r3, .L170+4
 1297 0208 1B68     		ldr	r3, [r3]
 1298 020a 1C6A     		ldr	r4, [r3, #32]	@ float
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 37


 1299 020c 214B     		ldr	r3, .L170+4
 1300 020e 1B68     		ldr	r3, [r3]
 1301 0210 5B69     		ldr	r3, [r3, #20]	@ float
 1302 0212 7969     		ldr	r1, [r7, #20]	@ float
 1303 0214 1846     		mov	r0, r3
 1304 0216 FFF7FEFF 		bl	__aeabi_fmul
 1305 021a 0346     		mov	r3, r0
 1306 021c 1946     		mov	r1, r3
 1307 021e 2046     		mov	r0, r4
 1308 0220 FFF7FEFF 		bl	__aeabi_fsub
 1309 0224 0346     		mov	r3, r0
 1310 0226 3B61     		str	r3, [r7, #16]	@ float
 736:stepper.c     **** 				if (decel_dist < 0.0) {
 1311              		.loc 1 736 0
 1312 0228 4FF00001 		mov	r1, #0
 1313 022c 3869     		ldr	r0, [r7, #16]	@ float
 1314 022e FFF7FEFF 		bl	__aeabi_fcmplt
 1315 0232 0346     		mov	r3, r0
 1316 0234 002B     		cmp	r3, #0
 1317 0236 39D0     		beq	.L154
 737:stepper.c     **** 					// Deceleration through entire planner block. End of feed hold is not in this block.
 738:stepper.c     **** 					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeter
 1318              		.loc 1 738 0
 1319 0238 164B     		ldr	r3, .L170+4
 1320 023a 1B68     		ldr	r3, [r3]
 1321 023c 5C69     		ldr	r4, [r3, #20]	@ float
 1322 023e 154B     		ldr	r3, .L170+4
 1323 0240 1B68     		ldr	r3, [r3]
 1324 0242 DB69     		ldr	r3, [r3, #28]	@ float
 1325 0244 1946     		mov	r1, r3
 1326 0246 1846     		mov	r0, r3
 1327 0248 FFF7FEFF 		bl	__aeabi_fadd
 1328 024c 0346     		mov	r3, r0
 1329 024e 1A46     		mov	r2, r3
 1330 0250 104B     		ldr	r3, .L170+4
 1331 0252 1B68     		ldr	r3, [r3]
 1332 0254 1B6A     		ldr	r3, [r3, #32]	@ float
 1333 0256 1946     		mov	r1, r3
 1334 0258 1046     		mov	r0, r2
 1335 025a FFF7FEFF 		bl	__aeabi_fmul
 1336 025e 0346     		mov	r3, r0
 1337 0260 1946     		mov	r1, r3
 1338 0262 2046     		mov	r0, r4
 1339 0264 FFF7FEFF 		bl	__aeabi_fsub
 1340 0268 0346     		mov	r3, r0
 1341 026a 1846     		mov	r0, r3
 1342 026c FFF7FEFF 		bl	__aeabi_f2d
 1343 0270 0346     		mov	r3, r0
 1344 0272 0C46     		mov	r4, r1
 1345 0274 1846     		mov	r0, r3
 1346 0276 2146     		mov	r1, r4
 1347 0278 FFF7FEFF 		bl	sqrt
 1348 027c 0346     		mov	r3, r0
 1349 027e 0C46     		mov	r4, r1
 1350 0280 1846     		mov	r0, r3
 1351 0282 2146     		mov	r1, r4
 1352 0284 FFF7FEFF 		bl	__aeabi_d2f
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 38


 1353 0288 0246     		mov	r2, r0
 1354 028a 034B     		ldr	r3, .L170+8
 1355 028c 5A62     		str	r2, [r3, #36]	@ float
 1356 028e 7BE1     		b	.L70
 1357              	.L171:
 1358              		.align	2
 1359              	.L170:
 1360 0290 00000000 		.word	sys
 1361 0294 C4000000 		.word	pl_block
 1362 0298 CC000000 		.word	prep
 1363 029c 00000000 		.word	st_block_buffer
 1364 02a0 C8000000 		.word	st_prep_block
 1365 02a4 0000A03F 		.word	1067450368
 1366 02a8 00000000 		.word	settings
 1367              	.L154:
 739:stepper.c     **** 				} else {
 740:stepper.c     **** 					prep.mm_complete = decel_dist; // End of feed hold.
 1368              		.loc 1 740 0
 1369 02ac 904A     		ldr	r2, .L172
 1370 02ae 3B69     		ldr	r3, [r7, #16]	@ float
 1371 02b0 9361     		str	r3, [r2, #24]	@ float
 741:stepper.c     **** 					prep.exit_speed = 0.0;
 1372              		.loc 1 741 0
 1373 02b2 8F4B     		ldr	r3, .L172
 1374 02b4 4FF00002 		mov	r2, #0
 1375 02b8 5A62     		str	r2, [r3, #36]	@ float
 1376 02ba 65E1     		b	.L70
 1377              	.L66:
 1378              	.LBE5:
 1379              	.LBB6:
 742:stepper.c     **** 				}
 743:stepper.c     **** 			} else { // [Normal Operation]
 744:stepper.c     **** 				// Compute or recompute velocity profile parameters of the prepped planner block.
 745:stepper.c     **** 				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
 1380              		.loc 1 745 0
 1381 02bc 8C4B     		ldr	r3, .L172
 1382 02be 0022     		movs	r2, #0
 1383 02c0 1A75     		strb	r2, [r3, #20]
 746:stepper.c     **** 				prep.accelerate_until = pl_block->millimeters;
 1384              		.loc 1 746 0
 1385 02c2 8C4B     		ldr	r3, .L172+4
 1386 02c4 1B68     		ldr	r3, [r3]
 1387 02c6 1B6A     		ldr	r3, [r3, #32]	@ float
 1388 02c8 894A     		ldr	r2, .L172
 1389 02ca 9362     		str	r3, [r2, #40]	@ float
 747:stepper.c     **** 
 748:stepper.c     **** 				float exit_speed_sqr;
 749:stepper.c     **** 				float nominal_speed;
 750:stepper.c     ****         if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 1390              		.loc 1 750 0
 1391 02cc 8A4B     		ldr	r3, .L172+8
 1392 02ce 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1393 02d0 03F00403 		and	r3, r3, #4
 1394 02d4 002B     		cmp	r3, #0
 1395 02d6 06D0     		beq	.L71
 751:stepper.c     ****           prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
 1396              		.loc 1 751 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 39


 1397 02d8 4FF00003 		mov	r3, #0
 1398 02dc 3B65     		str	r3, [r7, #80]	@ float
 1399 02de 844A     		ldr	r2, .L172
 1400 02e0 3B6D     		ldr	r3, [r7, #80]	@ float
 1401 02e2 5362     		str	r3, [r2, #36]	@ float
 1402 02e4 14E0     		b	.L72
 1403              	.L71:
 752:stepper.c     ****         } else {
 753:stepper.c     ****           exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 1404              		.loc 1 753 0
 1405 02e6 FFF7FEFF 		bl	plan_get_exec_block_exit_speed_sqr
 1406 02ea 3865     		str	r0, [r7, #80]	@ float
 754:stepper.c     ****           prep.exit_speed = sqrt(exit_speed_sqr);
 1407              		.loc 1 754 0
 1408 02ec 386D     		ldr	r0, [r7, #80]	@ float
 1409 02ee FFF7FEFF 		bl	__aeabi_f2d
 1410 02f2 0346     		mov	r3, r0
 1411 02f4 0C46     		mov	r4, r1
 1412 02f6 1846     		mov	r0, r3
 1413 02f8 2146     		mov	r1, r4
 1414 02fa FFF7FEFF 		bl	sqrt
 1415 02fe 0346     		mov	r3, r0
 1416 0300 0C46     		mov	r4, r1
 1417 0302 1846     		mov	r0, r3
 1418 0304 2146     		mov	r1, r4
 1419 0306 FFF7FEFF 		bl	__aeabi_d2f
 1420 030a 0246     		mov	r2, r0
 1421 030c 784B     		ldr	r3, .L172
 1422 030e 5A62     		str	r2, [r3, #36]	@ float
 1423              	.L72:
 755:stepper.c     ****         }
 756:stepper.c     **** 
 757:stepper.c     ****         nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 1424              		.loc 1 757 0
 1425 0310 784B     		ldr	r3, .L172+4
 1426 0312 1B68     		ldr	r3, [r3]
 1427 0314 1846     		mov	r0, r3
 1428 0316 FFF7FEFF 		bl	plan_compute_profile_nominal_speed
 1429 031a F860     		str	r0, [r7, #12]	@ float
 758:stepper.c     **** 				float nominal_speed_sqr = nominal_speed*nominal_speed;
 1430              		.loc 1 758 0
 1431 031c F968     		ldr	r1, [r7, #12]	@ float
 1432 031e F868     		ldr	r0, [r7, #12]	@ float
 1433 0320 FFF7FEFF 		bl	__aeabi_fmul
 1434 0324 0346     		mov	r3, r0
 1435 0326 BB60     		str	r3, [r7, #8]	@ float
 759:stepper.c     **** 				float intersect_distance =
 760:stepper.c     **** 								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
 1436              		.loc 1 760 0
 1437 0328 724B     		ldr	r3, .L172+4
 1438 032a 1B68     		ldr	r3, [r3]
 1439 032c 1C6A     		ldr	r4, [r3, #32]	@ float
 1440 032e 714B     		ldr	r3, .L172+4
 1441 0330 1B68     		ldr	r3, [r3]
 1442 0332 5B69     		ldr	r3, [r3, #20]	@ float
 1443 0334 396D     		ldr	r1, [r7, #80]	@ float
 1444 0336 1846     		mov	r0, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 40


 1445 0338 FFF7FEFF 		bl	__aeabi_fsub
 1446 033c 0346     		mov	r3, r0
 1447 033e 7969     		ldr	r1, [r7, #20]	@ float
 1448 0340 1846     		mov	r0, r3
 1449 0342 FFF7FEFF 		bl	__aeabi_fmul
 1450 0346 0346     		mov	r3, r0
 1451 0348 1946     		mov	r1, r3
 1452 034a 2046     		mov	r0, r4
 1453 034c FFF7FEFF 		bl	__aeabi_fadd
 1454 0350 0346     		mov	r3, r0
 759:stepper.c     **** 				float intersect_distance =
 1455              		.loc 1 759 0
 1456 0352 4FF07C51 		mov	r1, #1056964608
 1457 0356 1846     		mov	r0, r3
 1458 0358 FFF7FEFF 		bl	__aeabi_fmul
 1459 035c 0346     		mov	r3, r0
 1460 035e 7B60     		str	r3, [r7, #4]	@ float
 761:stepper.c     **** 
 762:stepper.c     ****         if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reducti
 1461              		.loc 1 762 0
 1462 0360 644B     		ldr	r3, .L172+4
 1463 0362 1B68     		ldr	r3, [r3]
 1464 0364 5B69     		ldr	r3, [r3, #20]	@ float
 1465 0366 B968     		ldr	r1, [r7, #8]	@ float
 1466 0368 1846     		mov	r0, r3
 1467 036a FFF7FEFF 		bl	__aeabi_fcmpgt
 1468 036e 0346     		mov	r3, r0
 1469 0370 002B     		cmp	r3, #0
 1470 0372 6BD0     		beq	.L155
 763:stepper.c     ****           prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-no
 1471              		.loc 1 763 0
 1472 0374 5F4B     		ldr	r3, .L172+4
 1473 0376 1B68     		ldr	r3, [r3]
 1474 0378 1C6A     		ldr	r4, [r3, #32]	@ float
 1475 037a 5E4B     		ldr	r3, .L172+4
 1476 037c 1B68     		ldr	r3, [r3]
 1477 037e 5B69     		ldr	r3, [r3, #20]	@ float
 1478 0380 B968     		ldr	r1, [r7, #8]	@ float
 1479 0382 1846     		mov	r0, r3
 1480 0384 FFF7FEFF 		bl	__aeabi_fsub
 1481 0388 0346     		mov	r3, r0
 1482 038a 7969     		ldr	r1, [r7, #20]	@ float
 1483 038c 1846     		mov	r0, r3
 1484 038e FFF7FEFF 		bl	__aeabi_fmul
 1485 0392 0346     		mov	r3, r0
 1486 0394 1946     		mov	r1, r3
 1487 0396 2046     		mov	r0, r4
 1488 0398 FFF7FEFF 		bl	__aeabi_fsub
 1489 039c 0346     		mov	r3, r0
 1490 039e 1A46     		mov	r2, r3
 1491 03a0 534B     		ldr	r3, .L172
 1492 03a2 9A62     		str	r2, [r3, #40]	@ float
 764:stepper.c     ****           if (prep.accelerate_until <= 0.0) { // Deceleration-only.
 1493              		.loc 1 764 0
 1494 03a4 524B     		ldr	r3, .L172
 1495 03a6 9B6A     		ldr	r3, [r3, #40]	@ float
 1496 03a8 4FF00001 		mov	r1, #0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 41


 1497 03ac 1846     		mov	r0, r3
 1498 03ae FFF7FEFF 		bl	__aeabi_fcmple
 1499 03b2 0346     		mov	r3, r0
 1500 03b4 002B     		cmp	r3, #0
 1501 03b6 35D0     		beq	.L156
 765:stepper.c     ****             prep.ramp_type = RAMP_DECEL;
 1502              		.loc 1 765 0
 1503 03b8 4D4B     		ldr	r3, .L172
 1504 03ba 0222     		movs	r2, #2
 1505 03bc 1A75     		strb	r2, [r3, #20]
 766:stepper.c     ****             // prep.decelerate_after = pl_block->millimeters;
 767:stepper.c     ****             // prep.maximum_speed = prep.current_speed;
 768:stepper.c     **** 
 769:stepper.c     ****             // Compute override block exit speed since it doesn't match the planner exit speed.
 770:stepper.c     ****             prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->m
 1506              		.loc 1 770 0
 1507 03be 4D4B     		ldr	r3, .L172+4
 1508 03c0 1B68     		ldr	r3, [r3]
 1509 03c2 5C69     		ldr	r4, [r3, #20]	@ float
 1510 03c4 4B4B     		ldr	r3, .L172+4
 1511 03c6 1B68     		ldr	r3, [r3]
 1512 03c8 DB69     		ldr	r3, [r3, #28]	@ float
 1513 03ca 1946     		mov	r1, r3
 1514 03cc 1846     		mov	r0, r3
 1515 03ce FFF7FEFF 		bl	__aeabi_fadd
 1516 03d2 0346     		mov	r3, r0
 1517 03d4 1A46     		mov	r2, r3
 1518 03d6 474B     		ldr	r3, .L172+4
 1519 03d8 1B68     		ldr	r3, [r3]
 1520 03da 1B6A     		ldr	r3, [r3, #32]	@ float
 1521 03dc 1946     		mov	r1, r3
 1522 03de 1046     		mov	r0, r2
 1523 03e0 FFF7FEFF 		bl	__aeabi_fmul
 1524 03e4 0346     		mov	r3, r0
 1525 03e6 1946     		mov	r1, r3
 1526 03e8 2046     		mov	r0, r4
 1527 03ea FFF7FEFF 		bl	__aeabi_fsub
 1528 03ee 0346     		mov	r3, r0
 1529 03f0 1846     		mov	r0, r3
 1530 03f2 FFF7FEFF 		bl	__aeabi_f2d
 1531 03f6 0346     		mov	r3, r0
 1532 03f8 0C46     		mov	r4, r1
 1533 03fa 1846     		mov	r0, r3
 1534 03fc 2146     		mov	r1, r4
 1535 03fe FFF7FEFF 		bl	sqrt
 1536 0402 0346     		mov	r3, r0
 1537 0404 0C46     		mov	r4, r1
 1538 0406 1846     		mov	r0, r3
 1539 0408 2146     		mov	r1, r4
 1540 040a FFF7FEFF 		bl	__aeabi_d2f
 1541 040e 0246     		mov	r2, r0
 1542 0410 374B     		ldr	r3, .L172
 1543 0412 5A62     		str	r2, [r3, #36]	@ float
 771:stepper.c     ****             prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as decele
 1544              		.loc 1 771 0
 1545 0414 364B     		ldr	r3, .L172
 1546 0416 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 42


 1547 0418 43F00803 		orr	r3, r3, #8
 1548 041c DAB2     		uxtb	r2, r3
 1549 041e 344B     		ldr	r3, .L172
 1550 0420 5A70     		strb	r2, [r3, #1]
 1551 0422 B1E0     		b	.L70
 1552              	.L156:
 772:stepper.c     **** 
 773:stepper.c     ****             // TODO: Determine correct handling of parameters in deceleration-only.
 774:stepper.c     ****             // Can be tricky since entry speed will be current speed, as in feed holds.
 775:stepper.c     ****             // Also, look into near-zero speed handling issues with this.
 776:stepper.c     **** 
 777:stepper.c     ****           } else {
 778:stepper.c     ****             // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated pla
 779:stepper.c     ****             prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 1553              		.loc 1 779 0
 1554 0424 396D     		ldr	r1, [r7, #80]	@ float
 1555 0426 B868     		ldr	r0, [r7, #8]	@ float
 1556 0428 FFF7FEFF 		bl	__aeabi_fsub
 1557 042c 0346     		mov	r3, r0
 1558 042e 7969     		ldr	r1, [r7, #20]	@ float
 1559 0430 1846     		mov	r0, r3
 1560 0432 FFF7FEFF 		bl	__aeabi_fmul
 1561 0436 0346     		mov	r3, r0
 1562 0438 1A46     		mov	r2, r3
 1563 043a 2D4B     		ldr	r3, .L172
 1564 043c DA62     		str	r2, [r3, #44]	@ float
 780:stepper.c     ****             prep.maximum_speed = nominal_speed;
 1565              		.loc 1 780 0
 1566 043e 2C4A     		ldr	r2, .L172
 1567 0440 FB68     		ldr	r3, [r7, #12]	@ float
 1568 0442 1362     		str	r3, [r2, #32]	@ float
 781:stepper.c     ****             prep.ramp_type = RAMP_DECEL_OVERRIDE;
 1569              		.loc 1 781 0
 1570 0444 2A4B     		ldr	r3, .L172
 1571 0446 0322     		movs	r2, #3
 1572 0448 1A75     		strb	r2, [r3, #20]
 1573 044a 9DE0     		b	.L70
 1574              	.L155:
 782:stepper.c     ****           }
 783:stepper.c     **** 				} else if (intersect_distance > 0.0) {
 1575              		.loc 1 783 0
 1576 044c 4FF00001 		mov	r1, #0
 1577 0450 7868     		ldr	r0, [r7, #4]	@ float
 1578 0452 FFF7FEFF 		bl	__aeabi_fcmpgt
 1579 0456 0346     		mov	r3, r0
 1580 0458 002B     		cmp	r3, #0
 1581 045a 00F08D80 		beq	.L157
 784:stepper.c     **** 					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 1582              		.loc 1 784 0
 1583 045e 254B     		ldr	r3, .L172+4
 1584 0460 1B68     		ldr	r3, [r3]
 1585 0462 1B6A     		ldr	r3, [r3, #32]	@ float
 1586 0464 7968     		ldr	r1, [r7, #4]	@ float
 1587 0466 1846     		mov	r0, r3
 1588 0468 FFF7FEFF 		bl	__aeabi_fcmpgt
 1589 046c 0346     		mov	r3, r0
 1590 046e 002B     		cmp	r3, #0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 43


 1591 0470 7ED0     		beq	.L158
 785:stepper.c     **** 						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
 786:stepper.c     **** 						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 1592              		.loc 1 786 0
 1593 0472 396D     		ldr	r1, [r7, #80]	@ float
 1594 0474 B868     		ldr	r0, [r7, #8]	@ float
 1595 0476 FFF7FEFF 		bl	__aeabi_fsub
 1596 047a 0346     		mov	r3, r0
 1597 047c 7969     		ldr	r1, [r7, #20]	@ float
 1598 047e 1846     		mov	r0, r3
 1599 0480 FFF7FEFF 		bl	__aeabi_fmul
 1600 0484 0346     		mov	r3, r0
 1601 0486 1A46     		mov	r2, r3
 1602 0488 194B     		ldr	r3, .L172
 1603 048a DA62     		str	r2, [r3, #44]	@ float
 787:stepper.c     **** 						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 1604              		.loc 1 787 0
 1605 048c 184B     		ldr	r3, .L172
 1606 048e DB6A     		ldr	r3, [r3, #44]	@ float
 1607 0490 7968     		ldr	r1, [r7, #4]	@ float
 1608 0492 1846     		mov	r0, r3
 1609 0494 FFF7FEFF 		bl	__aeabi_fcmplt
 1610 0498 0346     		mov	r3, r0
 1611 049a 002B     		cmp	r3, #0
 1612 049c 2ED0     		beq	.L159
 788:stepper.c     **** 							prep.maximum_speed = nominal_speed;
 1613              		.loc 1 788 0
 1614 049e 144A     		ldr	r2, .L172
 1615 04a0 FB68     		ldr	r3, [r7, #12]	@ float
 1616 04a2 1362     		str	r3, [r2, #32]	@ float
 789:stepper.c     **** 							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 1617              		.loc 1 789 0
 1618 04a4 134B     		ldr	r3, .L172+4
 1619 04a6 1B68     		ldr	r3, [r3]
 1620 04a8 5B69     		ldr	r3, [r3, #20]	@ float
 1621 04aa B968     		ldr	r1, [r7, #8]	@ float
 1622 04ac 1846     		mov	r0, r3
 1623 04ae FFF7FEFF 		bl	__aeabi_fcmpeq
 1624 04b2 0346     		mov	r3, r0
 1625 04b4 002B     		cmp	r3, #0
 1626 04b6 03D0     		beq	.L160
 790:stepper.c     **** 								// Cruise-deceleration or cruise-only type.
 791:stepper.c     **** 								prep.ramp_type = RAMP_CRUISE;
 1627              		.loc 1 791 0
 1628 04b8 0D4B     		ldr	r3, .L172
 1629 04ba 0122     		movs	r2, #1
 1630 04bc 1A75     		strb	r2, [r3, #20]
 1631 04be 63E0     		b	.L70
 1632              	.L160:
 792:stepper.c     **** 							} else {
 793:stepper.c     **** 								// Full-trapezoid or acceleration-cruise types
 794:stepper.c     **** 								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
 1633              		.loc 1 794 0
 1634 04c0 0B4B     		ldr	r3, .L172
 1635 04c2 9C6A     		ldr	r4, [r3, #40]	@ float
 1636 04c4 0B4B     		ldr	r3, .L172+4
 1637 04c6 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 44


 1638 04c8 5B69     		ldr	r3, [r3, #20]	@ float
 1639 04ca 1946     		mov	r1, r3
 1640 04cc B868     		ldr	r0, [r7, #8]	@ float
 1641 04ce FFF7FEFF 		bl	__aeabi_fsub
 1642 04d2 0346     		mov	r3, r0
 1643 04d4 7969     		ldr	r1, [r7, #20]	@ float
 1644 04d6 1846     		mov	r0, r3
 1645 04d8 FFF7FEFF 		bl	__aeabi_fmul
 1646 04dc 0346     		mov	r3, r0
 1647 04de 1946     		mov	r1, r3
 1648 04e0 2046     		mov	r0, r4
 1649 04e2 FFF7FEFF 		bl	__aeabi_fsub
 1650 04e6 0346     		mov	r3, r0
 1651 04e8 1A46     		mov	r2, r3
 1652 04ea 014B     		ldr	r3, .L172
 1653 04ec 9A62     		str	r2, [r3, #40]	@ float
 1654 04ee 4BE0     		b	.L70
 1655              	.L173:
 1656              		.align	2
 1657              	.L172:
 1658 04f0 CC000000 		.word	prep
 1659 04f4 C4000000 		.word	pl_block
 1660 04f8 00000000 		.word	sys
 1661              	.L159:
 795:stepper.c     **** 							}
 796:stepper.c     **** 						} else { // Triangle type
 797:stepper.c     **** 							prep.accelerate_until = intersect_distance;
 1662              		.loc 1 797 0
 1663 04fc 854A     		ldr	r2, .L174
 1664 04fe 7B68     		ldr	r3, [r7, #4]	@ float
 1665 0500 9362     		str	r3, [r2, #40]	@ float
 798:stepper.c     **** 							prep.decelerate_after = intersect_distance;
 1666              		.loc 1 798 0
 1667 0502 844A     		ldr	r2, .L174
 1668 0504 7B68     		ldr	r3, [r7, #4]	@ float
 1669 0506 D362     		str	r3, [r2, #44]	@ float
 799:stepper.c     **** 							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
 1670              		.loc 1 799 0
 1671 0508 834B     		ldr	r3, .L174+4
 1672 050a 1B68     		ldr	r3, [r3]
 1673 050c DB69     		ldr	r3, [r3, #28]	@ float
 1674 050e 1846     		mov	r0, r3
 1675 0510 FFF7FEFF 		bl	__aeabi_f2d
 1676 0514 0246     		mov	r2, r0
 1677 0516 0B46     		mov	r3, r1
 1678 0518 FFF7FEFF 		bl	__aeabi_dadd
 1679 051c 0346     		mov	r3, r0
 1680 051e 0C46     		mov	r4, r1
 1681 0520 2546     		mov	r5, r4
 1682 0522 1C46     		mov	r4, r3
 1683 0524 7868     		ldr	r0, [r7, #4]	@ float
 1684 0526 FFF7FEFF 		bl	__aeabi_f2d
 1685 052a 0246     		mov	r2, r0
 1686 052c 0B46     		mov	r3, r1
 1687 052e 2046     		mov	r0, r4
 1688 0530 2946     		mov	r1, r5
 1689 0532 FFF7FEFF 		bl	__aeabi_dmul
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 45


 1690 0536 0346     		mov	r3, r0
 1691 0538 0C46     		mov	r4, r1
 1692 053a 2546     		mov	r5, r4
 1693 053c 1C46     		mov	r4, r3
 1694 053e 386D     		ldr	r0, [r7, #80]	@ float
 1695 0540 FFF7FEFF 		bl	__aeabi_f2d
 1696 0544 0246     		mov	r2, r0
 1697 0546 0B46     		mov	r3, r1
 1698 0548 2046     		mov	r0, r4
 1699 054a 2946     		mov	r1, r5
 1700 054c FFF7FEFF 		bl	__aeabi_dadd
 1701 0550 0346     		mov	r3, r0
 1702 0552 0C46     		mov	r4, r1
 1703 0554 1846     		mov	r0, r3
 1704 0556 2146     		mov	r1, r4
 1705 0558 FFF7FEFF 		bl	sqrt
 1706 055c 0346     		mov	r3, r0
 1707 055e 0C46     		mov	r4, r1
 1708 0560 1846     		mov	r0, r3
 1709 0562 2146     		mov	r1, r4
 1710 0564 FFF7FEFF 		bl	__aeabi_d2f
 1711 0568 0246     		mov	r2, r0
 1712 056a 6A4B     		ldr	r3, .L174
 1713 056c 1A62     		str	r2, [r3, #32]	@ float
 1714 056e 0BE0     		b	.L70
 1715              	.L158:
 800:stepper.c     **** 						}
 801:stepper.c     **** 					} else { // Deceleration-only type
 802:stepper.c     ****             prep.ramp_type = RAMP_DECEL;
 1716              		.loc 1 802 0
 1717 0570 684B     		ldr	r3, .L174
 1718 0572 0222     		movs	r2, #2
 1719 0574 1A75     		strb	r2, [r3, #20]
 1720 0576 07E0     		b	.L70
 1721              	.L157:
 803:stepper.c     ****             // prep.decelerate_after = pl_block->millimeters;
 804:stepper.c     ****             // prep.maximum_speed = prep.current_speed;
 805:stepper.c     **** 					}
 806:stepper.c     **** 				} else { // Acceleration-only type
 807:stepper.c     **** 					prep.accelerate_until = 0.0;
 1722              		.loc 1 807 0
 1723 0578 664B     		ldr	r3, .L174
 1724 057a 4FF00002 		mov	r2, #0
 1725 057e 9A62     		str	r2, [r3, #40]	@ float
 808:stepper.c     **** 					// prep.decelerate_after = 0.0;
 809:stepper.c     **** 					prep.maximum_speed = prep.exit_speed;
 1726              		.loc 1 809 0
 1727 0580 644B     		ldr	r3, .L174
 1728 0582 5B6A     		ldr	r3, [r3, #36]	@ float
 1729 0584 634A     		ldr	r2, .L174
 1730 0586 1362     		str	r3, [r2, #32]	@ float
 1731              	.L70:
 1732              	.LBE6:
 810:stepper.c     **** 				}
 811:stepper.c     **** 			}
 812:stepper.c     ****       
 813:stepper.c     ****       #ifdef VARIABLE_SPINDLE
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 46


 814:stepper.c     ****         bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updat
 1733              		.loc 1 814 0
 1734 0588 644B     		ldr	r3, .L174+8
 1735 058a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1736 058c 43F00803 		orr	r3, r3, #8
 1737 0590 DAB2     		uxtb	r2, r3
 1738 0592 624B     		ldr	r3, .L174+8
 1739 0594 1A71     		strb	r2, [r3, #4]
 1740              	.L55:
 1741              	.LBE3:
 815:stepper.c     ****       #endif
 816:stepper.c     ****     }
 817:stepper.c     ****     
 818:stepper.c     ****     // Initialize new segment
 819:stepper.c     ****     segment_t *prep_segment = &segment_buffer[segment_buffer_head];
 1742              		.loc 1 819 0
 1743 0596 624B     		ldr	r3, .L174+12
 1744 0598 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1745 059a DB00     		lsls	r3, r3, #3
 1746 059c 614A     		ldr	r2, .L174+16
 1747 059e 1344     		add	r3, r3, r2
 1748 05a0 3B63     		str	r3, [r7, #48]
 820:stepper.c     **** 
 821:stepper.c     ****     // Set new segment to point to the current segment data block.
 822:stepper.c     ****     prep_segment->st_block_index = prep.st_block_index;
 1749              		.loc 1 822 0
 1750 05a2 5C4B     		ldr	r3, .L174
 1751 05a4 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1752 05a6 3B6B     		ldr	r3, [r7, #48]
 1753 05a8 1A71     		strb	r2, [r3, #4]
 823:stepper.c     **** 
 824:stepper.c     ****     /*------------------------------------------------------------------------------------
 825:stepper.c     ****         Compute the average velocity of this new segment by determining the total distance
 826:stepper.c     ****       traveled over the segment time DT_SEGMENT. The following code first attempts to create
 827:stepper.c     ****       a full segment based on the current ramp conditions. If the segment time is incomplete
 828:stepper.c     ****       when terminating at a ramp state change, the code will continue to loop through the
 829:stepper.c     ****       progressing ramp states to fill the remaining segment execution time. However, if
 830:stepper.c     ****       an incomplete segment terminates at the end of the velocity profile, the segment is
 831:stepper.c     ****       considered completed despite having a truncated execution time less than DT_SEGMENT.
 832:stepper.c     ****         The velocity profile is always assumed to progress through the ramp sequence:
 833:stepper.c     ****       acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
 834:stepper.c     ****       may range from zero to the length of the block. Velocity profiles can end either at
 835:stepper.c     ****       the end of planner block (typical) or mid-block at the end of a forced deceleration,
 836:stepper.c     ****       such as from a feed hold.
 837:stepper.c     ****     */
 838:stepper.c     ****     float dt_max = DT_SEGMENT; // Maximum segment time
 1754              		.loc 1 838 0
 1755 05aa 5F4B     		ldr	r3, .L174+20
 1756 05ac FB64     		str	r3, [r7, #76]	@ float
 839:stepper.c     ****     float dt = 0.0; // Initialize segment time
 1757              		.loc 1 839 0
 1758 05ae 4FF00003 		mov	r3, #0
 1759 05b2 BB64     		str	r3, [r7, #72]	@ float
 840:stepper.c     ****     float time_var = dt_max; // Time worker variable
 1760              		.loc 1 840 0
 1761 05b4 FB6C     		ldr	r3, [r7, #76]	@ float
 1762 05b6 7B64     		str	r3, [r7, #68]	@ float
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 47


 841:stepper.c     ****     float mm_var; // mm-Distance worker variable
 842:stepper.c     ****     float speed_var; // Speed worker variable
 843:stepper.c     ****     float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
 1763              		.loc 1 843 0
 1764 05b8 574B     		ldr	r3, .L174+4
 1765 05ba 1B68     		ldr	r3, [r3]
 1766 05bc 1B6A     		ldr	r3, [r3, #32]	@ float
 1767 05be 3B64     		str	r3, [r7, #64]	@ float
 844:stepper.c     ****     float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
 1768              		.loc 1 844 0
 1769 05c0 544B     		ldr	r3, .L174
 1770 05c2 1B69     		ldr	r3, [r3, #16]	@ float
 1771 05c4 1946     		mov	r1, r3
 1772 05c6 386C     		ldr	r0, [r7, #64]	@ float
 1773 05c8 FFF7FEFF 		bl	__aeabi_fsub
 1774 05cc 0346     		mov	r3, r0
 1775 05ce FB63     		str	r3, [r7, #60]	@ float
 845:stepper.c     ****     if (minimum_mm < 0.0) { minimum_mm = 0.0; }
 1776              		.loc 1 845 0
 1777 05d0 4FF00001 		mov	r1, #0
 1778 05d4 F86B     		ldr	r0, [r7, #60]	@ float
 1779 05d6 FFF7FEFF 		bl	__aeabi_fcmplt
 1780 05da 0346     		mov	r3, r0
 1781 05dc 002B     		cmp	r3, #0
 1782 05de 00D1     		bne	.L144
 1783 05e0 02E0     		b	.L89
 1784              	.L144:
 1785              		.loc 1 845 0 is_stmt 0 discriminator 1
 1786 05e2 4FF00003 		mov	r3, #0
 1787 05e6 FB63     		str	r3, [r7, #60]	@ float
 1788              	.L89:
 846:stepper.c     **** 
 847:stepper.c     ****     do {
 848:stepper.c     ****       switch (prep.ramp_type) {
 1789              		.loc 1 848 0 is_stmt 1
 1790 05e8 4A4B     		ldr	r3, .L174
 1791 05ea 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 1792 05ec 012B     		cmp	r3, #1
 1793 05ee 00F03481 		beq	.L92
 1794 05f2 032B     		cmp	r3, #3
 1795 05f4 03D0     		beq	.L93
 1796 05f6 002B     		cmp	r3, #0
 1797 05f8 00F09A80 		beq	.L94
 1798 05fc 5DE1     		b	.L161
 1799              	.L93:
 849:stepper.c     ****         case RAMP_DECEL_OVERRIDE:
 850:stepper.c     ****           speed_var = pl_block->acceleration*time_var;
 1800              		.loc 1 850 0
 1801 05fe 464B     		ldr	r3, .L174+4
 1802 0600 1B68     		ldr	r3, [r3]
 1803 0602 DB69     		ldr	r3, [r3, #28]	@ float
 1804 0604 796C     		ldr	r1, [r7, #68]	@ float
 1805 0606 1846     		mov	r0, r3
 1806 0608 FFF7FEFF 		bl	__aeabi_fmul
 1807 060c 0346     		mov	r3, r0
 1808 060e FB62     		str	r3, [r7, #44]	@ float
 851:stepper.c     ****           mm_var = time_var*(prep.current_speed - 0.5*speed_var);
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 48


 1809              		.loc 1 851 0
 1810 0610 786C     		ldr	r0, [r7, #68]	@ float
 1811 0612 FFF7FEFF 		bl	__aeabi_f2d
 1812 0616 0446     		mov	r4, r0
 1813 0618 0D46     		mov	r5, r1
 1814 061a 3E4B     		ldr	r3, .L174
 1815 061c DB69     		ldr	r3, [r3, #28]	@ float
 1816 061e 1846     		mov	r0, r3
 1817 0620 FFF7FEFF 		bl	__aeabi_f2d
 1818 0624 8046     		mov	r8, r0
 1819 0626 8946     		mov	r9, r1
 1820 0628 F86A     		ldr	r0, [r7, #44]	@ float
 1821 062a FFF7FEFF 		bl	__aeabi_f2d
 1822 062e 4FF00002 		mov	r2, #0
 1823 0632 3E4B     		ldr	r3, .L174+24
 1824 0634 FFF7FEFF 		bl	__aeabi_dmul
 1825 0638 0246     		mov	r2, r0
 1826 063a 0B46     		mov	r3, r1
 1827 063c 4046     		mov	r0, r8
 1828 063e 4946     		mov	r1, r9
 1829 0640 FFF7FEFF 		bl	__aeabi_dsub
 1830 0644 0246     		mov	r2, r0
 1831 0646 0B46     		mov	r3, r1
 1832 0648 2046     		mov	r0, r4
 1833 064a 2946     		mov	r1, r5
 1834 064c FFF7FEFF 		bl	__aeabi_dmul
 1835 0650 0346     		mov	r3, r0
 1836 0652 0C46     		mov	r4, r1
 1837 0654 1846     		mov	r0, r3
 1838 0656 2146     		mov	r1, r4
 1839 0658 FFF7FEFF 		bl	__aeabi_d2f
 1840 065c 0346     		mov	r3, r0
 1841 065e BB62     		str	r3, [r7, #40]	@ float
 852:stepper.c     ****           mm_remaining -= mm_var;
 1842              		.loc 1 852 0
 1843 0660 B96A     		ldr	r1, [r7, #40]	@ float
 1844 0662 386C     		ldr	r0, [r7, #64]	@ float
 1845 0664 FFF7FEFF 		bl	__aeabi_fsub
 1846 0668 0346     		mov	r3, r0
 1847 066a 3B64     		str	r3, [r7, #64]	@ float
 853:stepper.c     ****           if ((mm_remaining < prep.accelerate_until) || (mm_var <= 0)) {
 1848              		.loc 1 853 0
 1849 066c 294B     		ldr	r3, .L174
 1850 066e 9B6A     		ldr	r3, [r3, #40]	@ float
 1851 0670 396C     		ldr	r1, [r7, #64]	@ float
 1852 0672 1846     		mov	r0, r3
 1853 0674 FFF7FEFF 		bl	__aeabi_fcmpgt
 1854 0678 0346     		mov	r3, r0
 1855 067a 002B     		cmp	r3, #0
 1856 067c 07D1     		bne	.L95
 1857              		.loc 1 853 0 is_stmt 0 discriminator 1
 1858 067e 4FF00001 		mov	r1, #0
 1859 0682 B86A     		ldr	r0, [r7, #40]	@ float
 1860 0684 FFF7FEFF 		bl	__aeabi_fcmple
 1861 0688 0346     		mov	r3, r0
 1862 068a 002B     		cmp	r3, #0
 1863 068c 37D0     		beq	.L162
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 49


 1864              	.L95:
 854:stepper.c     ****             // Cruise or cruise-deceleration types only for deceleration override.
 855:stepper.c     ****             mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 1865              		.loc 1 855 0 is_stmt 1
 1866 068e 214B     		ldr	r3, .L174
 1867 0690 9B6A     		ldr	r3, [r3, #40]	@ float
 1868 0692 3B64     		str	r3, [r7, #64]	@ float
 856:stepper.c     ****             time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_sp
 1869              		.loc 1 856 0
 1870 0694 204B     		ldr	r3, .L174+4
 1871 0696 1B68     		ldr	r3, [r3]
 1872 0698 1B6A     		ldr	r3, [r3, #32]	@ float
 1873 069a 396C     		ldr	r1, [r7, #64]	@ float
 1874 069c 1846     		mov	r0, r3
 1875 069e FFF7FEFF 		bl	__aeabi_fsub
 1876 06a2 0346     		mov	r3, r0
 1877 06a4 1846     		mov	r0, r3
 1878 06a6 FFF7FEFF 		bl	__aeabi_f2d
 1879 06aa 0246     		mov	r2, r0
 1880 06ac 0B46     		mov	r3, r1
 1881 06ae FFF7FEFF 		bl	__aeabi_dadd
 1882 06b2 0346     		mov	r3, r0
 1883 06b4 0C46     		mov	r4, r1
 1884 06b6 2546     		mov	r5, r4
 1885 06b8 1C46     		mov	r4, r3
 1886 06ba 164B     		ldr	r3, .L174
 1887 06bc DA69     		ldr	r2, [r3, #28]	@ float
 1888 06be 154B     		ldr	r3, .L174
 1889 06c0 1B6A     		ldr	r3, [r3, #32]	@ float
 1890 06c2 1946     		mov	r1, r3
 1891 06c4 1046     		mov	r0, r2
 1892 06c6 FFF7FEFF 		bl	__aeabi_fadd
 1893 06ca 0346     		mov	r3, r0
 1894 06cc 1846     		mov	r0, r3
 1895 06ce FFF7FEFF 		bl	__aeabi_f2d
 1896 06d2 0246     		mov	r2, r0
 1897 06d4 0B46     		mov	r3, r1
 1898 06d6 2046     		mov	r0, r4
 1899 06d8 2946     		mov	r1, r5
 1900 06da FFF7FEFF 		bl	__aeabi_ddiv
 1901 06de 0346     		mov	r3, r0
 1902 06e0 0C46     		mov	r4, r1
 1903 06e2 1846     		mov	r0, r3
 1904 06e4 2146     		mov	r1, r4
 1905 06e6 FFF7FEFF 		bl	__aeabi_d2f
 1906 06ea 0346     		mov	r3, r0
 1907 06ec 7B64     		str	r3, [r7, #68]	@ float
 857:stepper.c     ****             prep.ramp_type = RAMP_CRUISE;
 1908              		.loc 1 857 0
 1909 06ee 094B     		ldr	r3, .L174
 1910 06f0 0122     		movs	r2, #1
 1911 06f2 1A75     		strb	r2, [r3, #20]
 858:stepper.c     ****             prep.current_speed = prep.maximum_speed;
 1912              		.loc 1 858 0
 1913 06f4 074B     		ldr	r3, .L174
 1914 06f6 1B6A     		ldr	r3, [r3, #32]	@ float
 1915 06f8 064A     		ldr	r2, .L174
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 50


 1916 06fa D361     		str	r3, [r2, #28]	@ float
 859:stepper.c     ****           } else { // Mid-deceleration override ramp.
 860:stepper.c     ****             prep.current_speed -= speed_var;
 861:stepper.c     ****           }
 862:stepper.c     ****           break;
 1917              		.loc 1 862 0
 1918 06fc 71E1     		b	.L99
 1919              	.L162:
 860:stepper.c     ****           }
 1920              		.loc 1 860 0
 1921 06fe 054B     		ldr	r3, .L174
 1922 0700 DB69     		ldr	r3, [r3, #28]	@ float
 1923 0702 F96A     		ldr	r1, [r7, #44]	@ float
 1924 0704 1846     		mov	r0, r3
 1925 0706 FFF7FEFF 		bl	__aeabi_fsub
 1926 070a 0346     		mov	r3, r0
 1927 070c 1A46     		mov	r2, r3
 1928 070e 014B     		ldr	r3, .L174
 1929 0710 DA61     		str	r2, [r3, #28]	@ float
 1930              		.loc 1 862 0
 1931 0712 66E1     		b	.L99
 1932              	.L175:
 1933              		.align	2
 1934              	.L174:
 1935 0714 CC000000 		.word	prep
 1936 0718 C4000000 		.word	pl_block
 1937 071c 00000000 		.word	sys
 1938 0720 BD000000 		.word	segment_buffer_head
 1939 0724 64000000 		.word	segment_buffer
 1940 0728 3EC32E39 		.word	959365950
 1941 072c 0000E03F 		.word	1071644672
 1942              	.L94:
 863:stepper.c     ****         case RAMP_ACCEL:
 864:stepper.c     ****           // NOTE: Acceleration ramp only computes during first do-while loop.
 865:stepper.c     ****           speed_var = pl_block->acceleration*time_var;
 1943              		.loc 1 865 0
 1944 0730 8F4B     		ldr	r3, .L176
 1945 0732 1B68     		ldr	r3, [r3]
 1946 0734 DB69     		ldr	r3, [r3, #28]	@ float
 1947 0736 796C     		ldr	r1, [r7, #68]	@ float
 1948 0738 1846     		mov	r0, r3
 1949 073a FFF7FEFF 		bl	__aeabi_fmul
 1950 073e 0346     		mov	r3, r0
 1951 0740 FB62     		str	r3, [r7, #44]	@ float
 866:stepper.c     ****           mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
 1952              		.loc 1 866 0
 1953 0742 386C     		ldr	r0, [r7, #64]	@ float
 1954 0744 FFF7FEFF 		bl	__aeabi_f2d
 1955 0748 0446     		mov	r4, r0
 1956 074a 0D46     		mov	r5, r1
 1957 074c 786C     		ldr	r0, [r7, #68]	@ float
 1958 074e FFF7FEFF 		bl	__aeabi_f2d
 1959 0752 8046     		mov	r8, r0
 1960 0754 8946     		mov	r9, r1
 1961 0756 874B     		ldr	r3, .L176+4
 1962 0758 DB69     		ldr	r3, [r3, #28]	@ float
 1963 075a 1846     		mov	r0, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 51


 1964 075c FFF7FEFF 		bl	__aeabi_f2d
 1965 0760 8246     		mov	r10, r0
 1966 0762 8B46     		mov	fp, r1
 1967 0764 F86A     		ldr	r0, [r7, #44]	@ float
 1968 0766 FFF7FEFF 		bl	__aeabi_f2d
 1969 076a 4FF00002 		mov	r2, #0
 1970 076e 824B     		ldr	r3, .L176+8
 1971 0770 FFF7FEFF 		bl	__aeabi_dmul
 1972 0774 0246     		mov	r2, r0
 1973 0776 0B46     		mov	r3, r1
 1974 0778 5046     		mov	r0, r10
 1975 077a 5946     		mov	r1, fp
 1976 077c FFF7FEFF 		bl	__aeabi_dadd
 1977 0780 0246     		mov	r2, r0
 1978 0782 0B46     		mov	r3, r1
 1979 0784 4046     		mov	r0, r8
 1980 0786 4946     		mov	r1, r9
 1981 0788 FFF7FEFF 		bl	__aeabi_dmul
 1982 078c 0246     		mov	r2, r0
 1983 078e 0B46     		mov	r3, r1
 1984 0790 2046     		mov	r0, r4
 1985 0792 2946     		mov	r1, r5
 1986 0794 FFF7FEFF 		bl	__aeabi_dsub
 1987 0798 0346     		mov	r3, r0
 1988 079a 0C46     		mov	r4, r1
 1989 079c 1846     		mov	r0, r3
 1990 079e 2146     		mov	r1, r4
 1991 07a0 FFF7FEFF 		bl	__aeabi_d2f
 1992 07a4 0346     		mov	r3, r0
 1993 07a6 3B64     		str	r3, [r7, #64]	@ float
 867:stepper.c     ****           if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 1994              		.loc 1 867 0
 1995 07a8 724B     		ldr	r3, .L176+4
 1996 07aa 9B6A     		ldr	r3, [r3, #40]	@ float
 1997 07ac 396C     		ldr	r1, [r7, #64]	@ float
 1998 07ae 1846     		mov	r0, r3
 1999 07b0 FFF7FEFF 		bl	__aeabi_fcmpgt
 2000 07b4 0346     		mov	r3, r0
 2001 07b6 002B     		cmp	r3, #0
 2002 07b8 44D0     		beq	.L163
 868:stepper.c     ****             // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
 869:stepper.c     ****             mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 2003              		.loc 1 869 0
 2004 07ba 6E4B     		ldr	r3, .L176+4
 2005 07bc 9B6A     		ldr	r3, [r3, #40]	@ float
 2006 07be 3B64     		str	r3, [r7, #64]	@ float
 870:stepper.c     ****             time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_sp
 2007              		.loc 1 870 0
 2008 07c0 6B4B     		ldr	r3, .L176
 2009 07c2 1B68     		ldr	r3, [r3]
 2010 07c4 1B6A     		ldr	r3, [r3, #32]	@ float
 2011 07c6 396C     		ldr	r1, [r7, #64]	@ float
 2012 07c8 1846     		mov	r0, r3
 2013 07ca FFF7FEFF 		bl	__aeabi_fsub
 2014 07ce 0346     		mov	r3, r0
 2015 07d0 1846     		mov	r0, r3
 2016 07d2 FFF7FEFF 		bl	__aeabi_f2d
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 52


 2017 07d6 0246     		mov	r2, r0
 2018 07d8 0B46     		mov	r3, r1
 2019 07da FFF7FEFF 		bl	__aeabi_dadd
 2020 07de 0346     		mov	r3, r0
 2021 07e0 0C46     		mov	r4, r1
 2022 07e2 2546     		mov	r5, r4
 2023 07e4 1C46     		mov	r4, r3
 2024 07e6 634B     		ldr	r3, .L176+4
 2025 07e8 DA69     		ldr	r2, [r3, #28]	@ float
 2026 07ea 624B     		ldr	r3, .L176+4
 2027 07ec 1B6A     		ldr	r3, [r3, #32]	@ float
 2028 07ee 1946     		mov	r1, r3
 2029 07f0 1046     		mov	r0, r2
 2030 07f2 FFF7FEFF 		bl	__aeabi_fadd
 2031 07f6 0346     		mov	r3, r0
 2032 07f8 1846     		mov	r0, r3
 2033 07fa FFF7FEFF 		bl	__aeabi_f2d
 2034 07fe 0246     		mov	r2, r0
 2035 0800 0B46     		mov	r3, r1
 2036 0802 2046     		mov	r0, r4
 2037 0804 2946     		mov	r1, r5
 2038 0806 FFF7FEFF 		bl	__aeabi_ddiv
 2039 080a 0346     		mov	r3, r0
 2040 080c 0C46     		mov	r4, r1
 2041 080e 1846     		mov	r0, r3
 2042 0810 2146     		mov	r1, r4
 2043 0812 FFF7FEFF 		bl	__aeabi_d2f
 2044 0816 0346     		mov	r3, r0
 2045 0818 7B64     		str	r3, [r7, #68]	@ float
 871:stepper.c     ****             if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
 2046              		.loc 1 871 0
 2047 081a 564B     		ldr	r3, .L176+4
 2048 081c DB6A     		ldr	r3, [r3, #44]	@ float
 2049 081e 396C     		ldr	r1, [r7, #64]	@ float
 2050 0820 1846     		mov	r0, r3
 2051 0822 FFF7FEFF 		bl	__aeabi_fcmpeq
 2052 0826 0346     		mov	r3, r0
 2053 0828 002B     		cmp	r3, #0
 2054 082a 03D0     		beq	.L164
 2055              		.loc 1 871 0 is_stmt 0 discriminator 1
 2056 082c 514B     		ldr	r3, .L176+4
 2057 082e 0222     		movs	r2, #2
 2058 0830 1A75     		strb	r2, [r3, #20]
 2059 0832 02E0     		b	.L104
 2060              	.L164:
 872:stepper.c     ****             else { prep.ramp_type = RAMP_CRUISE; }
 2061              		.loc 1 872 0 is_stmt 1
 2062 0834 4F4B     		ldr	r3, .L176+4
 2063 0836 0122     		movs	r2, #1
 2064 0838 1A75     		strb	r2, [r3, #20]
 2065              	.L104:
 873:stepper.c     ****             prep.current_speed = prep.maximum_speed;
 2066              		.loc 1 873 0
 2067 083a 4E4B     		ldr	r3, .L176+4
 2068 083c 1B6A     		ldr	r3, [r3, #32]	@ float
 2069 083e 4D4A     		ldr	r2, .L176+4
 2070 0840 D361     		str	r3, [r2, #28]	@ float
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 53


 874:stepper.c     ****           } else { // Acceleration only.
 875:stepper.c     ****             prep.current_speed += speed_var;
 876:stepper.c     ****           }
 877:stepper.c     ****           break;
 2071              		.loc 1 877 0
 2072 0842 CEE0     		b	.L99
 2073              	.L163:
 875:stepper.c     ****           }
 2074              		.loc 1 875 0
 2075 0844 4B4B     		ldr	r3, .L176+4
 2076 0846 DB69     		ldr	r3, [r3, #28]	@ float
 2077 0848 F96A     		ldr	r1, [r7, #44]	@ float
 2078 084a 1846     		mov	r0, r3
 2079 084c FFF7FEFF 		bl	__aeabi_fadd
 2080 0850 0346     		mov	r3, r0
 2081 0852 1A46     		mov	r2, r3
 2082 0854 474B     		ldr	r3, .L176+4
 2083 0856 DA61     		str	r2, [r3, #28]	@ float
 2084              		.loc 1 877 0
 2085 0858 C3E0     		b	.L99
 2086              	.L92:
 878:stepper.c     ****         case RAMP_CRUISE:
 879:stepper.c     ****           // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calc
 880:stepper.c     ****           // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not ch
 881:stepper.c     ****           //   prevent this, simply enforce a minimum speed threshold in the planner.
 882:stepper.c     ****           mm_var = mm_remaining - prep.maximum_speed*time_var;
 2087              		.loc 1 882 0
 2088 085a 464B     		ldr	r3, .L176+4
 2089 085c 1B6A     		ldr	r3, [r3, #32]	@ float
 2090 085e 796C     		ldr	r1, [r7, #68]	@ float
 2091 0860 1846     		mov	r0, r3
 2092 0862 FFF7FEFF 		bl	__aeabi_fmul
 2093 0866 0346     		mov	r3, r0
 2094 0868 1946     		mov	r1, r3
 2095 086a 386C     		ldr	r0, [r7, #64]	@ float
 2096 086c FFF7FEFF 		bl	__aeabi_fsub
 2097 0870 0346     		mov	r3, r0
 2098 0872 BB62     		str	r3, [r7, #40]	@ float
 883:stepper.c     ****           if (mm_var < prep.decelerate_after) { // End of cruise.
 2099              		.loc 1 883 0
 2100 0874 3F4B     		ldr	r3, .L176+4
 2101 0876 DB6A     		ldr	r3, [r3, #44]	@ float
 2102 0878 B96A     		ldr	r1, [r7, #40]	@ float
 2103 087a 1846     		mov	r0, r3
 2104 087c FFF7FEFF 		bl	__aeabi_fcmpgt
 2105 0880 0346     		mov	r3, r0
 2106 0882 002B     		cmp	r3, #0
 2107 0884 16D0     		beq	.L165
 884:stepper.c     ****             // Cruise-deceleration junction or end of block.
 885:stepper.c     ****             time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
 2108              		.loc 1 885 0
 2109 0886 3B4B     		ldr	r3, .L176+4
 2110 0888 DB6A     		ldr	r3, [r3, #44]	@ float
 2111 088a 1946     		mov	r1, r3
 2112 088c 386C     		ldr	r0, [r7, #64]	@ float
 2113 088e FFF7FEFF 		bl	__aeabi_fsub
 2114 0892 0346     		mov	r3, r0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 54


 2115 0894 1A46     		mov	r2, r3
 2116 0896 374B     		ldr	r3, .L176+4
 2117 0898 1B6A     		ldr	r3, [r3, #32]	@ float
 2118 089a 1946     		mov	r1, r3
 2119 089c 1046     		mov	r0, r2
 2120 089e FFF7FEFF 		bl	__aeabi_fdiv
 2121 08a2 0346     		mov	r3, r0
 2122 08a4 7B64     		str	r3, [r7, #68]	@ float
 886:stepper.c     ****             mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
 2123              		.loc 1 886 0
 2124 08a6 334B     		ldr	r3, .L176+4
 2125 08a8 DB6A     		ldr	r3, [r3, #44]	@ float
 2126 08aa 3B64     		str	r3, [r7, #64]	@ float
 887:stepper.c     ****             prep.ramp_type = RAMP_DECEL;
 2127              		.loc 1 887 0
 2128 08ac 314B     		ldr	r3, .L176+4
 2129 08ae 0222     		movs	r2, #2
 2130 08b0 1A75     		strb	r2, [r3, #20]
 888:stepper.c     ****           } else { // Cruising only.
 889:stepper.c     ****             mm_remaining = mm_var;
 890:stepper.c     ****           }
 891:stepper.c     ****           break;
 2131              		.loc 1 891 0
 2132 08b2 96E0     		b	.L99
 2133              	.L165:
 889:stepper.c     ****           }
 2134              		.loc 1 889 0
 2135 08b4 BB6A     		ldr	r3, [r7, #40]	@ float
 2136 08b6 3B64     		str	r3, [r7, #64]	@ float
 2137              		.loc 1 891 0
 2138 08b8 93E0     		b	.L99
 2139              	.L161:
 892:stepper.c     ****         default: // case RAMP_DECEL:
 893:stepper.c     ****           // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
 894:stepper.c     ****           speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
 2140              		.loc 1 894 0
 2141 08ba 2D4B     		ldr	r3, .L176
 2142 08bc 1B68     		ldr	r3, [r3]
 2143 08be DB69     		ldr	r3, [r3, #28]	@ float
 2144 08c0 796C     		ldr	r1, [r7, #68]	@ float
 2145 08c2 1846     		mov	r0, r3
 2146 08c4 FFF7FEFF 		bl	__aeabi_fmul
 2147 08c8 0346     		mov	r3, r0
 2148 08ca FB62     		str	r3, [r7, #44]	@ float
 895:stepper.c     ****           if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 2149              		.loc 1 895 0
 2150 08cc 294B     		ldr	r3, .L176+4
 2151 08ce DB69     		ldr	r3, [r3, #28]	@ float
 2152 08d0 F96A     		ldr	r1, [r7, #44]	@ float
 2153 08d2 1846     		mov	r0, r3
 2154 08d4 FFF7FEFF 		bl	__aeabi_fcmpgt
 2155 08d8 0346     		mov	r3, r0
 2156 08da 002B     		cmp	r3, #0
 2157 08dc 4ED0     		beq	.L109
 896:stepper.c     ****             // Compute distance from end of segment to end of block.
 897:stepper.c     ****             mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
 2158              		.loc 1 897 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 55


 2159 08de 386C     		ldr	r0, [r7, #64]	@ float
 2160 08e0 FFF7FEFF 		bl	__aeabi_f2d
 2161 08e4 0446     		mov	r4, r0
 2162 08e6 0D46     		mov	r5, r1
 2163 08e8 786C     		ldr	r0, [r7, #68]	@ float
 2164 08ea FFF7FEFF 		bl	__aeabi_f2d
 2165 08ee 8046     		mov	r8, r0
 2166 08f0 8946     		mov	r9, r1
 2167 08f2 204B     		ldr	r3, .L176+4
 2168 08f4 DB69     		ldr	r3, [r3, #28]	@ float
 2169 08f6 1846     		mov	r0, r3
 2170 08f8 FFF7FEFF 		bl	__aeabi_f2d
 2171 08fc 8246     		mov	r10, r0
 2172 08fe 8B46     		mov	fp, r1
 2173 0900 F86A     		ldr	r0, [r7, #44]	@ float
 2174 0902 FFF7FEFF 		bl	__aeabi_f2d
 2175 0906 4FF00002 		mov	r2, #0
 2176 090a 1B4B     		ldr	r3, .L176+8
 2177 090c FFF7FEFF 		bl	__aeabi_dmul
 2178 0910 0246     		mov	r2, r0
 2179 0912 0B46     		mov	r3, r1
 2180 0914 5046     		mov	r0, r10
 2181 0916 5946     		mov	r1, fp
 2182 0918 FFF7FEFF 		bl	__aeabi_dsub
 2183 091c 0246     		mov	r2, r0
 2184 091e 0B46     		mov	r3, r1
 2185 0920 4046     		mov	r0, r8
 2186 0922 4946     		mov	r1, r9
 2187 0924 FFF7FEFF 		bl	__aeabi_dmul
 2188 0928 0246     		mov	r2, r0
 2189 092a 0B46     		mov	r3, r1
 2190 092c 2046     		mov	r0, r4
 2191 092e 2946     		mov	r1, r5
 2192 0930 FFF7FEFF 		bl	__aeabi_dsub
 2193 0934 0346     		mov	r3, r0
 2194 0936 0C46     		mov	r4, r1
 2195 0938 1846     		mov	r0, r3
 2196 093a 2146     		mov	r1, r4
 2197 093c FFF7FEFF 		bl	__aeabi_d2f
 2198 0940 0346     		mov	r3, r0
 2199 0942 BB62     		str	r3, [r7, #40]	@ float
 898:stepper.c     ****             if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 2200              		.loc 1 898 0
 2201 0944 0B4B     		ldr	r3, .L176+4
 2202 0946 9B69     		ldr	r3, [r3, #24]	@ float
 2203 0948 B96A     		ldr	r1, [r7, #40]	@ float
 2204 094a 1846     		mov	r0, r3
 2205 094c FFF7FEFF 		bl	__aeabi_fcmplt
 2206 0950 0346     		mov	r3, r0
 2207 0952 002B     		cmp	r3, #0
 2208 0954 12D0     		beq	.L109
 899:stepper.c     ****               mm_remaining = mm_var;
 2209              		.loc 1 899 0
 2210 0956 BB6A     		ldr	r3, [r7, #40]	@ float
 2211 0958 3B64     		str	r3, [r7, #64]	@ float
 900:stepper.c     ****               prep.current_speed -= speed_var;
 2212              		.loc 1 900 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 56


 2213 095a 064B     		ldr	r3, .L176+4
 2214 095c DB69     		ldr	r3, [r3, #28]	@ float
 2215 095e F96A     		ldr	r1, [r7, #44]	@ float
 2216 0960 1846     		mov	r0, r3
 2217 0962 FFF7FEFF 		bl	__aeabi_fsub
 2218 0966 0346     		mov	r3, r0
 2219 0968 1A46     		mov	r2, r3
 2220 096a 024B     		ldr	r3, .L176+4
 2221 096c DA61     		str	r2, [r3, #28]	@ float
 901:stepper.c     ****               break; // Segment complete. Exit switch-case statement. Continue do-while loop.
 2222              		.loc 1 901 0
 2223 096e 38E0     		b	.L99
 2224              	.L177:
 2225              		.align	2
 2226              	.L176:
 2227 0970 C4000000 		.word	pl_block
 2228 0974 CC000000 		.word	prep
 2229 0978 0000E03F 		.word	1071644672
 2230              	.L109:
 902:stepper.c     ****             }
 903:stepper.c     ****           }
 904:stepper.c     ****           // Otherwise, at end of block or end of forced-deceleration.
 905:stepper.c     ****           time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
 2231              		.loc 1 905 0
 2232 097c A64B     		ldr	r3, .L178+8
 2233 097e 9B69     		ldr	r3, [r3, #24]	@ float
 2234 0980 1946     		mov	r1, r3
 2235 0982 386C     		ldr	r0, [r7, #64]	@ float
 2236 0984 FFF7FEFF 		bl	__aeabi_fsub
 2237 0988 0346     		mov	r3, r0
 2238 098a 1846     		mov	r0, r3
 2239 098c FFF7FEFF 		bl	__aeabi_f2d
 2240 0990 0246     		mov	r2, r0
 2241 0992 0B46     		mov	r3, r1
 2242 0994 FFF7FEFF 		bl	__aeabi_dadd
 2243 0998 0346     		mov	r3, r0
 2244 099a 0C46     		mov	r4, r1
 2245 099c 2546     		mov	r5, r4
 2246 099e 1C46     		mov	r4, r3
 2247 09a0 9D4B     		ldr	r3, .L178+8
 2248 09a2 DA69     		ldr	r2, [r3, #28]	@ float
 2249 09a4 9C4B     		ldr	r3, .L178+8
 2250 09a6 5B6A     		ldr	r3, [r3, #36]	@ float
 2251 09a8 1946     		mov	r1, r3
 2252 09aa 1046     		mov	r0, r2
 2253 09ac FFF7FEFF 		bl	__aeabi_fadd
 2254 09b0 0346     		mov	r3, r0
 2255 09b2 1846     		mov	r0, r3
 2256 09b4 FFF7FEFF 		bl	__aeabi_f2d
 2257 09b8 0246     		mov	r2, r0
 2258 09ba 0B46     		mov	r3, r1
 2259 09bc 2046     		mov	r0, r4
 2260 09be 2946     		mov	r1, r5
 2261 09c0 FFF7FEFF 		bl	__aeabi_ddiv
 2262 09c4 0346     		mov	r3, r0
 2263 09c6 0C46     		mov	r4, r1
 2264 09c8 1846     		mov	r0, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 57


 2265 09ca 2146     		mov	r1, r4
 2266 09cc FFF7FEFF 		bl	__aeabi_d2f
 2267 09d0 0346     		mov	r3, r0
 2268 09d2 7B64     		str	r3, [r7, #68]	@ float
 906:stepper.c     ****           mm_remaining = prep.mm_complete;
 2269              		.loc 1 906 0
 2270 09d4 904B     		ldr	r3, .L178+8
 2271 09d6 9B69     		ldr	r3, [r3, #24]	@ float
 2272 09d8 3B64     		str	r3, [r7, #64]	@ float
 907:stepper.c     ****           prep.current_speed = prep.exit_speed;
 2273              		.loc 1 907 0
 2274 09da 8F4B     		ldr	r3, .L178+8
 2275 09dc 5B6A     		ldr	r3, [r3, #36]	@ float
 2276 09de 8E4A     		ldr	r2, .L178+8
 2277 09e0 D361     		str	r3, [r2, #28]	@ float
 2278              	.L99:
 908:stepper.c     ****       }
 909:stepper.c     ****       dt += time_var; // Add computed ramp time to total segment time.
 2279              		.loc 1 909 0
 2280 09e2 796C     		ldr	r1, [r7, #68]	@ float
 2281 09e4 B86C     		ldr	r0, [r7, #72]	@ float
 2282 09e6 FFF7FEFF 		bl	__aeabi_fadd
 2283 09ea 0346     		mov	r3, r0
 2284 09ec BB64     		str	r3, [r7, #72]	@ float
 910:stepper.c     ****       if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
 2285              		.loc 1 910 0
 2286 09ee F96C     		ldr	r1, [r7, #76]	@ float
 2287 09f0 B86C     		ldr	r0, [r7, #72]	@ float
 2288 09f2 FFF7FEFF 		bl	__aeabi_fcmplt
 2289 09f6 0346     		mov	r3, r0
 2290 09f8 002B     		cmp	r3, #0
 2291 09fa 06D0     		beq	.L166
 2292              		.loc 1 910 0 is_stmt 0 discriminator 1
 2293 09fc B96C     		ldr	r1, [r7, #72]	@ float
 2294 09fe F86C     		ldr	r0, [r7, #76]	@ float
 2295 0a00 FFF7FEFF 		bl	__aeabi_fsub
 2296 0a04 0346     		mov	r3, r0
 2297 0a06 7B64     		str	r3, [r7, #68]	@ float
 2298 0a08 1DE0     		b	.L114
 2299              	.L166:
 911:stepper.c     ****       else {
 912:stepper.c     ****         if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 2300              		.loc 1 912 0 is_stmt 1
 2301 0a0a F96B     		ldr	r1, [r7, #60]	@ float
 2302 0a0c 386C     		ldr	r0, [r7, #64]	@ float
 2303 0a0e FFF7FEFF 		bl	__aeabi_fcmpgt
 2304 0a12 0346     		mov	r3, r0
 2305 0a14 002B     		cmp	r3, #0
 2306 0a16 00D1     		bne	.L151
 913:stepper.c     ****           // Increase segment time to ensure at least one step in segment. Override and loop
 914:stepper.c     ****           // through distance calculations until minimum_mm or mm_complete.
 915:stepper.c     ****           dt_max += DT_SEGMENT;
 916:stepper.c     ****           time_var = dt_max - dt;
 917:stepper.c     ****         } else {
 918:stepper.c     ****           break; // **Complete** Exit loop. Segment execution time maxed.
 2307              		.loc 1 918 0
 2308 0a18 1FE0     		b	.L117
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 58


 2309              	.L151:
 915:stepper.c     ****           time_var = dt_max - dt;
 2310              		.loc 1 915 0
 2311 0a1a F86C     		ldr	r0, [r7, #76]	@ float
 2312 0a1c FFF7FEFF 		bl	__aeabi_f2d
 2313 0a20 7BA3     		adr	r3, .L178
 2314 0a22 D3E90023 		ldrd	r2, [r3]
 2315 0a26 FFF7FEFF 		bl	__aeabi_dadd
 2316 0a2a 0346     		mov	r3, r0
 2317 0a2c 0C46     		mov	r4, r1
 2318 0a2e 1846     		mov	r0, r3
 2319 0a30 2146     		mov	r1, r4
 2320 0a32 FFF7FEFF 		bl	__aeabi_d2f
 2321 0a36 0346     		mov	r3, r0
 2322 0a38 FB64     		str	r3, [r7, #76]	@ float
 916:stepper.c     ****         } else {
 2323              		.loc 1 916 0
 2324 0a3a B96C     		ldr	r1, [r7, #72]	@ float
 2325 0a3c F86C     		ldr	r0, [r7, #76]	@ float
 2326 0a3e FFF7FEFF 		bl	__aeabi_fsub
 2327 0a42 0346     		mov	r3, r0
 2328 0a44 7B64     		str	r3, [r7, #68]	@ float
 2329              	.L114:
 919:stepper.c     ****         }
 920:stepper.c     ****       }
 921:stepper.c     ****     } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 2330              		.loc 1 921 0
 2331 0a46 744B     		ldr	r3, .L178+8
 2332 0a48 9B69     		ldr	r3, [r3, #24]	@ float
 2333 0a4a 396C     		ldr	r1, [r7, #64]	@ float
 2334 0a4c 1846     		mov	r0, r3
 2335 0a4e FFF7FEFF 		bl	__aeabi_fcmplt
 2336 0a52 0346     		mov	r3, r0
 2337 0a54 002B     		cmp	r3, #0
 2338 0a56 7FF4C7AD 		bne	.L89
 2339              	.L117:
 922:stepper.c     **** 
 923:stepper.c     ****     #ifdef VARIABLE_SPINDLE
 924:stepper.c     ****       /* -----------------------------------------------------------------------------------
 925:stepper.c     ****         Compute spindle speed PWM output for step segment
 926:stepper.c     ****       */
 927:stepper.c     ****       
 928:stepper.c     ****       if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PW
 2340              		.loc 1 928 0
 2341 0a5a 704B     		ldr	r3, .L178+12
 2342 0a5c 1B68     		ldr	r3, [r3]
 2343 0a5e 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2344 0a60 002B     		cmp	r3, #0
 2345 0a62 05D1     		bne	.L118
 2346              		.loc 1 928 0 is_stmt 0 discriminator 1
 2347 0a64 6E4B     		ldr	r3, .L178+16
 2348 0a66 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2349 0a68 03F00803 		and	r3, r3, #8
 2350 0a6c 002B     		cmp	r3, #0
 2351 0a6e 3AD0     		beq	.L119
 2352              	.L118:
 929:stepper.c     ****         if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 59


 2353              		.loc 1 929 0 is_stmt 1
 2354 0a70 6C4B     		ldr	r3, .L178+20
 2355 0a72 1B68     		ldr	r3, [r3]
 2356 0a74 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2357 0a76 03F03003 		and	r3, r3, #48
 2358 0a7a 002B     		cmp	r3, #0
 2359 0a7c 24D0     		beq	.L120
 2360              	.LBB7:
 930:stepper.c     ****           float rpm = pl_block->spindle_speed;
 2361              		.loc 1 930 0
 2362 0a7e 694B     		ldr	r3, .L178+20
 2363 0a80 1B68     		ldr	r3, [r3]
 2364 0a82 1B6B     		ldr	r3, [r3, #48]	@ float
 2365 0a84 BB63     		str	r3, [r7, #56]	@ float
 931:stepper.c     ****           // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser pow
 932:stepper.c     ****           if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
 2366              		.loc 1 932 0
 2367 0a86 654B     		ldr	r3, .L178+12
 2368 0a88 1B68     		ldr	r3, [r3]
 2369 0a8a 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2370 0a8c 002B     		cmp	r3, #0
 2371 0a8e 0ED0     		beq	.L121
 2372              		.loc 1 932 0 is_stmt 0 discriminator 1
 2373 0a90 614B     		ldr	r3, .L178+8
 2374 0a92 DA69     		ldr	r2, [r3, #28]	@ float
 2375 0a94 604B     		ldr	r3, .L178+8
 2376 0a96 1B6B     		ldr	r3, [r3, #48]	@ float
 2377 0a98 1946     		mov	r1, r3
 2378 0a9a 1046     		mov	r0, r2
 2379 0a9c FFF7FEFF 		bl	__aeabi_fmul
 2380 0aa0 0346     		mov	r3, r0
 2381 0aa2 1946     		mov	r1, r3
 2382 0aa4 B86B     		ldr	r0, [r7, #56]	@ float
 2383 0aa6 FFF7FEFF 		bl	__aeabi_fmul
 2384 0aaa 0346     		mov	r3, r0
 2385 0aac BB63     		str	r3, [r7, #56]	@ float
 2386              	.L121:
 933:stepper.c     ****           // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
 934:stepper.c     ****           // but this would be instantaneous only and during a motion. May not matter at all.
 935:stepper.c     ****           prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
 2387              		.loc 1 935 0 is_stmt 1
 2388 0aae B86B     		ldr	r0, [r7, #56]	@ float
 2389 0ab0 FFF7FEFF 		bl	__aeabi_f2iz
 2390 0ab4 0346     		mov	r3, r0
 2391 0ab6 1846     		mov	r0, r3
 2392 0ab8 FFF7FEFF 		bl	spindle_compute_pwm_value
 2393 0abc 0346     		mov	r3, r0
 2394 0abe DAB2     		uxtb	r2, r3
 2395 0ac0 554B     		ldr	r3, .L178+8
 2396 0ac2 83F83420 		strb	r2, [r3, #52]
 2397              	.LBE7:
 2398 0ac6 07E0     		b	.L122
 2399              	.L120:
 936:stepper.c     ****         } else { 
 937:stepper.c     ****           sys.spindle_speed = 0.0;
 2400              		.loc 1 937 0
 2401 0ac8 554B     		ldr	r3, .L178+16
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 60


 2402 0aca 4FF00002 		mov	r2, #0
 2403 0ace 1A61     		str	r2, [r3, #16]	@ float
 938:stepper.c     ****           prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
 2404              		.loc 1 938 0
 2405 0ad0 514B     		ldr	r3, .L178+8
 2406 0ad2 0022     		movs	r2, #0
 2407 0ad4 83F83420 		strb	r2, [r3, #52]
 2408              	.L122:
 939:stepper.c     ****         }
 940:stepper.c     ****         bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
 2409              		.loc 1 940 0
 2410 0ad8 514B     		ldr	r3, .L178+16
 2411 0ada 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2412 0adc 23F00803 		bic	r3, r3, #8
 2413 0ae0 DAB2     		uxtb	r2, r3
 2414 0ae2 4F4B     		ldr	r3, .L178+16
 2415 0ae4 1A71     		strb	r2, [r3, #4]
 2416              	.L119:
 941:stepper.c     ****       }
 942:stepper.c     ****       prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
 2417              		.loc 1 942 0
 2418 0ae6 4C4B     		ldr	r3, .L178+8
 2419 0ae8 93F83420 		ldrb	r2, [r3, #52]	@ zero_extendqisi2
 2420 0aec 3B6B     		ldr	r3, [r7, #48]
 2421 0aee 9A71     		strb	r2, [r3, #6]
 943:stepper.c     **** 
 944:stepper.c     ****     #endif
 945:stepper.c     ****     
 946:stepper.c     ****     /* -----------------------------------------------------------------------------------
 947:stepper.c     ****        Compute segment step rate, steps to execute, and apply necessary rate corrections.
 948:stepper.c     ****        NOTE: Steps are computed by direct scalar conversion of the millimeter distance
 949:stepper.c     ****        remaining in the block, rather than incrementally tallying the steps executed per
 950:stepper.c     ****        segment. This helps in removing floating point round-off issues of several additions.
 951:stepper.c     ****        However, since floats have only 7.2 significant digits, long moves with extremely
 952:stepper.c     ****        high step counts can exceed the precision of floats, which can lead to lost steps.
 953:stepper.c     ****        Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
 954:stepper.c     ****        supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
 955:stepper.c     ****     */
 956:stepper.c     ****     float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
 2422              		.loc 1 956 0
 2423 0af0 494B     		ldr	r3, .L178+8
 2424 0af2 DB68     		ldr	r3, [r3, #12]	@ float
 2425 0af4 396C     		ldr	r1, [r7, #64]	@ float
 2426 0af6 1846     		mov	r0, r3
 2427 0af8 FFF7FEFF 		bl	__aeabi_fmul
 2428 0afc 0346     		mov	r3, r0
 2429 0afe 7B62     		str	r3, [r7, #36]	@ float
 957:stepper.c     ****     float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
 2430              		.loc 1 957 0
 2431 0b00 786A     		ldr	r0, [r7, #36]	@ float
 2432 0b02 FFF7FEFF 		bl	__aeabi_f2d
 2433 0b06 0346     		mov	r3, r0
 2434 0b08 0C46     		mov	r4, r1
 2435 0b0a 1846     		mov	r0, r3
 2436 0b0c 2146     		mov	r1, r4
 2437 0b0e FFF7FEFF 		bl	ceil
 2438 0b12 0346     		mov	r3, r0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 61


 2439 0b14 0C46     		mov	r4, r1
 2440 0b16 1846     		mov	r0, r3
 2441 0b18 2146     		mov	r1, r4
 2442 0b1a FFF7FEFF 		bl	__aeabi_d2f
 2443 0b1e 0346     		mov	r3, r0
 2444 0b20 3B62     		str	r3, [r7, #32]	@ float
 958:stepper.c     ****     float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
 2445              		.loc 1 958 0
 2446 0b22 3D4B     		ldr	r3, .L178+8
 2447 0b24 9B68     		ldr	r3, [r3, #8]	@ float
 2448 0b26 1846     		mov	r0, r3
 2449 0b28 FFF7FEFF 		bl	__aeabi_f2d
 2450 0b2c 0346     		mov	r3, r0
 2451 0b2e 0C46     		mov	r4, r1
 2452 0b30 1846     		mov	r0, r3
 2453 0b32 2146     		mov	r1, r4
 2454 0b34 FFF7FEFF 		bl	ceil
 2455 0b38 0346     		mov	r3, r0
 2456 0b3a 0C46     		mov	r4, r1
 2457 0b3c 1846     		mov	r0, r3
 2458 0b3e 2146     		mov	r1, r4
 2459 0b40 FFF7FEFF 		bl	__aeabi_d2f
 2460 0b44 0346     		mov	r3, r0
 2461 0b46 FB61     		str	r3, [r7, #28]	@ float
 959:stepper.c     ****     prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to 
 2462              		.loc 1 959 0
 2463 0b48 396A     		ldr	r1, [r7, #32]	@ float
 2464 0b4a F869     		ldr	r0, [r7, #28]	@ float
 2465 0b4c FFF7FEFF 		bl	__aeabi_fsub
 2466 0b50 0346     		mov	r3, r0
 2467 0b52 1846     		mov	r0, r3
 2468 0b54 FFF7FEFF 		bl	__aeabi_f2uiz
 2469 0b58 0346     		mov	r3, r0
 2470 0b5a 9AB2     		uxth	r2, r3
 2471 0b5c 3B6B     		ldr	r3, [r7, #48]
 2472 0b5e 1A80     		strh	r2, [r3]	@ movhi
 960:stepper.c     **** 
 961:stepper.c     ****     // Bail if we are at the end of a feed hold and don't have a step to execute.
 962:stepper.c     ****     if (prep_segment->n_step == 0) {
 2473              		.loc 1 962 0
 2474 0b60 3B6B     		ldr	r3, [r7, #48]
 2475 0b62 1B88     		ldrh	r3, [r3]
 2476 0b64 002B     		cmp	r3, #0
 2477 0b66 0DD1     		bne	.L123
 963:stepper.c     ****       if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
 2478              		.loc 1 963 0
 2479 0b68 2D4B     		ldr	r3, .L178+16
 2480 0b6a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2481 0b6c 03F00203 		and	r3, r3, #2
 2482 0b70 002B     		cmp	r3, #0
 2483 0b72 07D0     		beq	.L123
 964:stepper.c     ****         // Less than one step to decelerate to zero speed, but already very close. AMASS
 965:stepper.c     ****         // requires full steps to execute. So, just bail.
 966:stepper.c     ****         bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 2484              		.loc 1 966 0
 2485 0b74 2A4B     		ldr	r3, .L178+16
 2486 0b76 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 62


 2487 0b78 43F00103 		orr	r3, r3, #1
 2488 0b7c DAB2     		uxtb	r2, r3
 2489 0b7e 284B     		ldr	r3, .L178+16
 2490 0b80 1A71     		strb	r2, [r3, #4]
 967:stepper.c     ****         #ifdef PARKING_ENABLE
 968:stepper.c     ****           if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HO
 969:stepper.c     ****         #endif
 970:stepper.c     ****         return; // Segment not generated, but current step data still retained.
 2491              		.loc 1 970 0
 2492 0b82 D1E0     		b	.L51
 2493              	.L123:
 971:stepper.c     ****       }
 972:stepper.c     ****     }
 973:stepper.c     **** 
 974:stepper.c     ****     // Compute segment step rate. Since steps are integers and mm distances traveled are not,
 975:stepper.c     ****     // the end of every segment can have a partial step of varying magnitudes that are not
 976:stepper.c     ****     // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To
 977:stepper.c     ****     // compensate, we track the time to execute the previous segment's partial step and simply
 978:stepper.c     ****     // apply it with the partial step distance to the current segment, so that it minutely
 979:stepper.c     ****     // adjusts the whole segment rate to keep step output exact. These rate adjustments are
 980:stepper.c     ****     // typically very small and do not adversely effect performance, but ensures that Grbl
 981:stepper.c     ****     // outputs the exact acceleration and velocity profiles as computed by the planner.
 982:stepper.c     ****     dt += prep.dt_remainder; // Apply previous segment partial step execute time
 2494              		.loc 1 982 0
 2495 0b84 244B     		ldr	r3, .L178+8
 2496 0b86 5B68     		ldr	r3, [r3, #4]	@ float
 2497 0b88 1946     		mov	r1, r3
 2498 0b8a B86C     		ldr	r0, [r7, #72]	@ float
 2499 0b8c FFF7FEFF 		bl	__aeabi_fadd
 2500 0b90 0346     		mov	r3, r0
 2501 0b92 BB64     		str	r3, [r7, #72]	@ float
 983:stepper.c     ****     float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step ra
 2502              		.loc 1 983 0
 2503 0b94 796A     		ldr	r1, [r7, #36]	@ float
 2504 0b96 F869     		ldr	r0, [r7, #28]	@ float
 2505 0b98 FFF7FEFF 		bl	__aeabi_fsub
 2506 0b9c 0346     		mov	r3, r0
 2507 0b9e 1946     		mov	r1, r3
 2508 0ba0 B86C     		ldr	r0, [r7, #72]	@ float
 2509 0ba2 FFF7FEFF 		bl	__aeabi_fdiv
 2510 0ba6 0346     		mov	r3, r0
 2511 0ba8 BB61     		str	r3, [r7, #24]	@ float
 984:stepper.c     **** 
 985:stepper.c     ****     // Compute CPU cycles per step for the prepped segment.
 986:stepper.c     ****     uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
 2512              		.loc 1 986 0
 2513 0baa 1F49     		ldr	r1, .L178+24
 2514 0bac B869     		ldr	r0, [r7, #24]	@ float
 2515 0bae FFF7FEFF 		bl	__aeabi_fmul
 2516 0bb2 0346     		mov	r3, r0
 2517 0bb4 1846     		mov	r0, r3
 2518 0bb6 FFF7FEFF 		bl	__aeabi_f2d
 2519 0bba 0346     		mov	r3, r0
 2520 0bbc 0C46     		mov	r4, r1
 2521 0bbe 1846     		mov	r0, r3
 2522 0bc0 2146     		mov	r1, r4
 2523 0bc2 FFF7FEFF 		bl	ceil
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 63


 2524 0bc6 0346     		mov	r3, r0
 2525 0bc8 0C46     		mov	r4, r1
 2526 0bca 1846     		mov	r0, r3
 2527 0bcc 2146     		mov	r1, r4
 2528 0bce FFF7FEFF 		bl	__aeabi_d2uiz
 2529 0bd2 0346     		mov	r3, r0
 2530 0bd4 7B63     		str	r3, [r7, #52]
 987:stepper.c     **** 
 988:stepper.c     ****     #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
 989:stepper.c     ****       // Compute step timing and multi-axis smoothing level.
 990:stepper.c     ****       // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
 991:stepper.c     ****       if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
 2531              		.loc 1 991 0
 2532 0bd6 7B6B     		ldr	r3, [r7, #52]
 2533 0bd8 40F6B732 		movw	r2, #2999
 2534 0bdc 9342     		cmp	r3, r2
 2535 0bde 03D8     		bhi	.L124
 2536              		.loc 1 991 0 is_stmt 0 discriminator 1
 2537 0be0 3B6B     		ldr	r3, [r7, #48]
 2538 0be2 0022     		movs	r2, #0
 2539 0be4 5A71     		strb	r2, [r3, #5]
 2540 0be6 34E0     		b	.L125
 2541              	.L124:
 992:stepper.c     ****       else {
 993:stepper.c     ****         if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
 2542              		.loc 1 993 0 is_stmt 1
 2543 0be8 7B6B     		ldr	r3, [r7, #52]
 2544 0bea 41F26F72 		movw	r2, #5999
 2545 0bee 9342     		cmp	r3, r2
 2546 0bf0 03D8     		bhi	.L126
 2547              		.loc 1 993 0 is_stmt 0 discriminator 1
 2548 0bf2 3B6B     		ldr	r3, [r7, #48]
 2549 0bf4 0122     		movs	r2, #1
 2550 0bf6 5A71     		strb	r2, [r3, #5]
 2551 0bf8 1BE0     		b	.L127
 2552              	.L126:
 994:stepper.c     ****         else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
 2553              		.loc 1 994 0 is_stmt 1
 2554 0bfa 7B6B     		ldr	r3, [r7, #52]
 2555 0bfc 42F6DF62 		movw	r2, #11999
 2556 0c00 9342     		cmp	r3, r2
 2557 0c02 13D8     		bhi	.L128
 2558              		.loc 1 994 0 is_stmt 0 discriminator 1
 2559 0c04 3B6B     		ldr	r3, [r7, #48]
 2560 0c06 0222     		movs	r2, #2
 2561 0c08 5A71     		strb	r2, [r3, #5]
 2562 0c0a 12E0     		b	.L127
 2563              	.L179:
 2564 0c0c AFF30080 		.align	3
 2565              	.L178:
 2566 0c10 A5E2ECC3 		.word	-1007885659
 2567 0c14 67D8253F 		.word	1059444839
 2568 0c18 CC000000 		.word	prep
 2569 0c1c C8000000 		.word	st_prep_block
 2570 0c20 00000000 		.word	sys
 2571 0c24 C4000000 		.word	pl_block
 2572 0c28 50A9AB4E 		.word	1319872848
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 64


 2573              	.L128:
 995:stepper.c     ****         else { prep_segment->amass_level = 3; }
 2574              		.loc 1 995 0 is_stmt 1
 2575 0c2c 3B6B     		ldr	r3, [r7, #48]
 2576 0c2e 0322     		movs	r2, #3
 2577 0c30 5A71     		strb	r2, [r3, #5]
 2578              	.L127:
 996:stepper.c     ****         cycles >>= prep_segment->amass_level;
 2579              		.loc 1 996 0
 2580 0c32 3B6B     		ldr	r3, [r7, #48]
 2581 0c34 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 2582 0c36 1A46     		mov	r2, r3
 2583 0c38 7B6B     		ldr	r3, [r7, #52]
 2584 0c3a D340     		lsrs	r3, r3, r2
 2585 0c3c 7B63     		str	r3, [r7, #52]
 997:stepper.c     ****         prep_segment->n_step <<= prep_segment->amass_level;
 2586              		.loc 1 997 0
 2587 0c3e 3B6B     		ldr	r3, [r7, #48]
 2588 0c40 1B88     		ldrh	r3, [r3]
 2589 0c42 1A46     		mov	r2, r3
 2590 0c44 3B6B     		ldr	r3, [r7, #48]
 2591 0c46 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 2592 0c48 02FA03F3 		lsl	r3, r2, r3
 2593 0c4c 9AB2     		uxth	r2, r3
 2594 0c4e 3B6B     		ldr	r3, [r7, #48]
 2595 0c50 1A80     		strh	r2, [r3]	@ movhi
 2596              	.L125:
 998:stepper.c     ****       }
 999:stepper.c     ****       if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16M
 2597              		.loc 1 999 0
 2598 0c52 7B6B     		ldr	r3, [r7, #52]
 2599 0c54 B3F5803F 		cmp	r3, #65536
 2600 0c58 04D2     		bcs	.L129
 2601              		.loc 1 999 0 is_stmt 0 discriminator 1
 2602 0c5a 7B6B     		ldr	r3, [r7, #52]
 2603 0c5c 9AB2     		uxth	r2, r3
 2604 0c5e 3B6B     		ldr	r3, [r7, #48]
 2605 0c60 5A80     		strh	r2, [r3, #2]	@ movhi
 2606 0c62 03E0     		b	.L130
 2607              	.L129:
1000:stepper.c     ****       else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
 2608              		.loc 1 1000 0 is_stmt 1
 2609 0c64 3B6B     		ldr	r3, [r7, #48]
 2610 0c66 4FF6FF72 		movw	r2, #65535
 2611 0c6a 5A80     		strh	r2, [r3, #2]	@ movhi
 2612              	.L130:
1001:stepper.c     ****     #else
1002:stepper.c     ****       // Compute step timing and timer prescalar for normal step generation.
1003:stepper.c     ****       if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)
1004:stepper.c     ****         prep_segment->prescaler = 1; // prescaler: 0
1005:stepper.c     ****         prep_segment->cycles_per_tick = cycles;
1006:stepper.c     ****       } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)
1007:stepper.c     ****         prep_segment->prescaler = 2; // prescaler: 8
1008:stepper.c     ****         prep_segment->cycles_per_tick = cycles >> 3;
1009:stepper.c     ****       } else {
1010:stepper.c     ****         prep_segment->prescaler = 3; // prescaler: 64
1011:stepper.c     ****         if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 65


1012:stepper.c     ****           prep_segment->cycles_per_tick =  cycles >> 6;
1013:stepper.c     ****         } else { // Just set the slowest speed possible. (Around 4 step/sec.)
1014:stepper.c     ****           prep_segment->cycles_per_tick = 0xffff;
1015:stepper.c     ****         }
1016:stepper.c     ****       }
1017:stepper.c     ****     #endif
1018:stepper.c     **** 
1019:stepper.c     ****     // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute i
1020:stepper.c     ****     segment_buffer_head = segment_next_head;
 2613              		.loc 1 1020 0
 2614 0c6c 304B     		ldr	r3, .L180
 2615 0c6e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2616 0c70 304B     		ldr	r3, .L180+4
 2617 0c72 1A70     		strb	r2, [r3]
1021:stepper.c     ****     if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
 2618              		.loc 1 1021 0
 2619 0c74 2E4B     		ldr	r3, .L180
 2620 0c76 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2621 0c78 0133     		adds	r3, r3, #1
 2622 0c7a DAB2     		uxtb	r2, r3
 2623 0c7c 2C4B     		ldr	r3, .L180
 2624 0c7e 1A70     		strb	r2, [r3]
 2625 0c80 2B4B     		ldr	r3, .L180
 2626 0c82 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2627 0c84 062B     		cmp	r3, #6
 2628 0c86 02D1     		bne	.L131
 2629              		.loc 1 1021 0 is_stmt 0 discriminator 1
 2630 0c88 294B     		ldr	r3, .L180
 2631 0c8a 0022     		movs	r2, #0
 2632 0c8c 1A70     		strb	r2, [r3]
 2633              	.L131:
1022:stepper.c     **** 
1023:stepper.c     ****     // Update the appropriate planner and segment data.
1024:stepper.c     ****     pl_block->millimeters = mm_remaining;
 2634              		.loc 1 1024 0 is_stmt 1
 2635 0c8e 2A4B     		ldr	r3, .L180+8
 2636 0c90 1B68     		ldr	r3, [r3]
 2637 0c92 3A6C     		ldr	r2, [r7, #64]	@ float
 2638 0c94 1A62     		str	r2, [r3, #32]	@ float
1025:stepper.c     ****     prep.steps_remaining = n_steps_remaining;
 2639              		.loc 1 1025 0
 2640 0c96 294A     		ldr	r2, .L180+12
 2641 0c98 3B6A     		ldr	r3, [r7, #32]	@ float
 2642 0c9a 9360     		str	r3, [r2, #8]	@ float
1026:stepper.c     ****     prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
 2643              		.loc 1 1026 0
 2644 0c9c 796A     		ldr	r1, [r7, #36]	@ float
 2645 0c9e 386A     		ldr	r0, [r7, #32]	@ float
 2646 0ca0 FFF7FEFF 		bl	__aeabi_fsub
 2647 0ca4 0346     		mov	r3, r0
 2648 0ca6 B969     		ldr	r1, [r7, #24]	@ float
 2649 0ca8 1846     		mov	r0, r3
 2650 0caa FFF7FEFF 		bl	__aeabi_fmul
 2651 0cae 0346     		mov	r3, r0
 2652 0cb0 1A46     		mov	r2, r3
 2653 0cb2 224B     		ldr	r3, .L180+12
 2654 0cb4 5A60     		str	r2, [r3, #4]	@ float
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 66


1027:stepper.c     **** 
1028:stepper.c     ****     // Check for exit conditions and flag to load next planner block.
1029:stepper.c     ****     if (mm_remaining == prep.mm_complete) {
 2655              		.loc 1 1029 0
 2656 0cb6 214B     		ldr	r3, .L180+12
 2657 0cb8 9B69     		ldr	r3, [r3, #24]	@ float
 2658 0cba 396C     		ldr	r1, [r7, #64]	@ float
 2659 0cbc 1846     		mov	r0, r3
 2660 0cbe FFF7FEFF 		bl	__aeabi_fcmpeq
 2661 0cc2 0346     		mov	r3, r0
 2662 0cc4 002B     		cmp	r3, #0
 2663 0cc6 00D1     		bne	.L152
 2664 0cc8 22E0     		b	.L54
 2665              	.L152:
1030:stepper.c     ****       // End of planner block or forced-termination. No more distance to be executed.
1031:stepper.c     ****       if (mm_remaining > 0.0) { // At end of forced-termination.
 2666              		.loc 1 1031 0
 2667 0cca 4FF00001 		mov	r1, #0
 2668 0cce 386C     		ldr	r0, [r7, #64]	@ float
 2669 0cd0 FFF7FEFF 		bl	__aeabi_fcmpgt
 2670 0cd4 0346     		mov	r3, r0
 2671 0cd6 002B     		cmp	r3, #0
 2672 0cd8 07D0     		beq	.L167
1032:stepper.c     ****         // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
1033:stepper.c     ****         // the segment queue, where realtime protocol will set new state upon receiving the
1034:stepper.c     ****         // cycle stop flag from the ISR. Prep_segment is blocked until then.
1035:stepper.c     ****         bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 2673              		.loc 1 1035 0
 2674 0cda 194B     		ldr	r3, .L180+16
 2675 0cdc 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2676 0cde 43F00103 		orr	r3, r3, #1
 2677 0ce2 DAB2     		uxtb	r2, r3
 2678 0ce4 164B     		ldr	r3, .L180+16
 2679 0ce6 1A71     		strb	r2, [r3, #4]
1036:stepper.c     ****         #ifdef PARKING_ENABLE
1037:stepper.c     ****           if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HO
1038:stepper.c     ****         #endif
1039:stepper.c     ****         return; // Bail!
 2680              		.loc 1 1039 0
 2681 0ce8 1EE0     		b	.L51
 2682              	.L167:
1040:stepper.c     ****       } else { // End of planner block
1041:stepper.c     ****         // The planner block is complete. All steps are set to be executed in the segment buffer.
1042:stepper.c     ****         if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 2683              		.loc 1 1042 0
 2684 0cea 154B     		ldr	r3, .L180+16
 2685 0cec 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2686 0cee 03F00403 		and	r3, r3, #4
 2687 0cf2 002B     		cmp	r3, #0
 2688 0cf4 07D0     		beq	.L135
1043:stepper.c     ****           bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 2689              		.loc 1 1043 0
 2690 0cf6 124B     		ldr	r3, .L180+16
 2691 0cf8 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2692 0cfa 43F00103 		orr	r3, r3, #1
 2693 0cfe DAB2     		uxtb	r2, r3
 2694 0d00 0F4B     		ldr	r3, .L180+16
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 67


 2695 0d02 1A71     		strb	r2, [r3, #4]
1044:stepper.c     ****           return;
 2696              		.loc 1 1044 0
 2697 0d04 10E0     		b	.L51
 2698              	.L135:
1045:stepper.c     ****         }
1046:stepper.c     ****         pl_block = NULL; // Set pointer to indicate check and load next planner block.
 2699              		.loc 1 1046 0
 2700 0d06 0C4B     		ldr	r3, .L180+8
 2701 0d08 0022     		movs	r2, #0
 2702 0d0a 1A60     		str	r2, [r3]
1047:stepper.c     ****         plan_discard_current_block();
 2703              		.loc 1 1047 0
 2704 0d0c FFF7FEFF 		bl	plan_discard_current_block
 2705              	.L54:
 2706              	.LBE2:
 651:stepper.c     **** 
 2707              		.loc 1 651 0
 2708 0d10 0C4B     		ldr	r3, .L180+20
 2709 0d12 1B78     		ldrb	r3, [r3]
 2710 0d14 DAB2     		uxtb	r2, r3
 2711 0d16 064B     		ldr	r3, .L180
 2712 0d18 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2713 0d1a 9A42     		cmp	r2, r3
 2714 0d1c 7FF47DA9 		bne	.L136
 2715 0d20 02E0     		b	.L51
 2716              	.L168:
 649:stepper.c     **** 
 2717              		.loc 1 649 0
 2718 0d22 00BF     		nop
 2719 0d24 00E0     		b	.L51
 2720              	.L169:
 2721              	.LBB9:
 2722              	.LBB8:
 659:stepper.c     **** 
 2723              		.loc 1 659 0
 2724 0d26 00BF     		nop
 2725              	.L51:
 2726              	.LBE8:
 2727              	.LBE9:
1048:stepper.c     ****       }
1049:stepper.c     ****     }
1050:stepper.c     **** 
1051:stepper.c     ****   }
1052:stepper.c     **** }
 2728              		.loc 1 1052 0
 2729 0d28 5837     		adds	r7, r7, #88
 2730              		.cfi_def_cfa_offset 32
 2731 0d2a BD46     		mov	sp, r7
 2732              		.cfi_def_cfa_register 13
 2733              		@ sp needed
 2734 0d2c BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 2735              	.L181:
 2736              		.align	2
 2737              	.L180:
 2738 0d30 BE000000 		.word	segment_next_head
 2739 0d34 BD000000 		.word	segment_buffer_head
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 68


 2740 0d38 C4000000 		.word	pl_block
 2741 0d3c CC000000 		.word	prep
 2742 0d40 00000000 		.word	sys
 2743 0d44 BC000000 		.word	segment_buffer_tail
 2744              		.cfi_endproc
 2745              	.LFE72:
 2746              		.size	st_prep_buffer, .-st_prep_buffer
 2747              		.section	.text.st_get_realtime_rate,"ax",%progbits
 2748              		.align	2
 2749              		.global	st_get_realtime_rate
 2750              		.thumb
 2751              		.thumb_func
 2752              		.type	st_get_realtime_rate, %function
 2753              	st_get_realtime_rate:
 2754              	.LFB73:
1053:stepper.c     **** 
1054:stepper.c     **** 
1055:stepper.c     **** // Called by realtime status reporting to fetch the current speed being executed. This value
1056:stepper.c     **** // however is not exactly the current speed, but the speed computed in the last step segment
1057:stepper.c     **** // in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
1058:stepper.c     **** // divided by the ACCELERATION TICKS PER SECOND in seconds.
1059:stepper.c     **** float st_get_realtime_rate()
1060:stepper.c     **** {
 2755              		.loc 1 1060 0
 2756              		.cfi_startproc
 2757              		@ args = 0, pretend = 0, frame = 0
 2758              		@ frame_needed = 1, uses_anonymous_args = 0
 2759              		@ link register save eliminated.
 2760 0000 80B4     		push	{r7}
 2761              		.cfi_def_cfa_offset 4
 2762              		.cfi_offset 7, -4
 2763 0002 00AF     		add	r7, sp, #0
 2764              		.cfi_def_cfa_register 7
1061:stepper.c     ****   if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
 2765              		.loc 1 1061 0
 2766 0004 074B     		ldr	r3, .L185
 2767 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2768 0008 03F07C03 		and	r3, r3, #124
 2769 000c 002B     		cmp	r3, #0
 2770 000e 02D0     		beq	.L183
1062:stepper.c     ****     return prep.current_speed;
 2771              		.loc 1 1062 0
 2772 0010 054B     		ldr	r3, .L185+4
 2773 0012 DB69     		ldr	r3, [r3, #28]	@ float
 2774 0014 01E0     		b	.L184
 2775              	.L183:
1063:stepper.c     ****   }
1064:stepper.c     ****   return 0.0f;
 2776              		.loc 1 1064 0
 2777 0016 4FF00003 		mov	r3, #0
 2778              	.L184:
1065:stepper.c     **** }
 2779              		.loc 1 1065 0
 2780 001a 1846     		mov	r0, r3
 2781 001c BD46     		mov	sp, r7
 2782              		.cfi_def_cfa_register 13
 2783              		@ sp needed
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 69


 2784 001e 80BC     		pop	{r7}
 2785              		.cfi_restore 7
 2786              		.cfi_def_cfa_offset 0
 2787 0020 7047     		bx	lr
 2788              	.L186:
 2789 0022 00BF     		.align	2
 2790              	.L185:
 2791 0024 00000000 		.word	sys
 2792 0028 CC000000 		.word	prep
 2793              		.cfi_endproc
 2794              	.LFE73:
 2795              		.size	st_get_realtime_rate, .-st_get_realtime_rate
 2796              		.text
 2797              	.Letext0:
 2798              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 2799              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 2800              		.file 4 "settings.h"
 2801              		.file 5 "system.h"
 2802              		.file 6 "planner.h"
 2803              		.file 7 "Generated_Source\\PSoC5/core_cm3.h"
 2804              		.section	.debug_info,"",%progbits
 2805              	.Ldebug_info0:
 2806 0000 93090000 		.4byte	0x993
 2807 0004 0400     		.2byte	0x4
 2808 0006 00000000 		.4byte	.Ldebug_abbrev0
 2809 000a 04       		.byte	0x4
 2810 000b 01       		.uleb128 0x1
 2811 000c 58000000 		.4byte	.LASF150
 2812 0010 0C       		.byte	0xc
 2813 0011 43040000 		.4byte	.LASF151
 2814 0015 1B050000 		.4byte	.LASF152
 2815 0019 30000000 		.4byte	.Ldebug_ranges0+0x30
 2816 001d 00000000 		.4byte	0
 2817 0021 00000000 		.4byte	.Ldebug_line0
 2818 0025 02       		.uleb128 0x2
 2819 0026 01       		.byte	0x1
 2820 0027 06       		.byte	0x6
 2821 0028 8B010000 		.4byte	.LASF0
 2822 002c 03       		.uleb128 0x3
 2823 002d 37000000 		.4byte	.LASF3
 2824 0031 02       		.byte	0x2
 2825 0032 1D       		.byte	0x1d
 2826 0033 37000000 		.4byte	0x37
 2827 0037 02       		.uleb128 0x2
 2828 0038 01       		.byte	0x1
 2829 0039 08       		.byte	0x8
 2830 003a 06060000 		.4byte	.LASF1
 2831 003e 02       		.uleb128 0x2
 2832 003f 02       		.byte	0x2
 2833 0040 05       		.byte	0x5
 2834 0041 00000000 		.4byte	.LASF2
 2835 0045 03       		.uleb128 0x3
 2836 0046 82020000 		.4byte	.LASF4
 2837 004a 02       		.byte	0x2
 2838 004b 2B       		.byte	0x2b
 2839 004c 50000000 		.4byte	0x50
 2840 0050 02       		.uleb128 0x2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 70


 2841 0051 02       		.byte	0x2
 2842 0052 07       		.byte	0x7
 2843 0053 8F070000 		.4byte	.LASF5
 2844 0057 03       		.uleb128 0x3
 2845 0058 F4060000 		.4byte	.LASF6
 2846 005c 02       		.byte	0x2
 2847 005d 3F       		.byte	0x3f
 2848 005e 62000000 		.4byte	0x62
 2849 0062 02       		.uleb128 0x2
 2850 0063 04       		.byte	0x4
 2851 0064 05       		.byte	0x5
 2852 0065 03020000 		.4byte	.LASF7
 2853 0069 03       		.uleb128 0x3
 2854 006a B6020000 		.4byte	.LASF8
 2855 006e 02       		.byte	0x2
 2856 006f 41       		.byte	0x41
 2857 0070 74000000 		.4byte	0x74
 2858 0074 02       		.uleb128 0x2
 2859 0075 04       		.byte	0x4
 2860 0076 07       		.byte	0x7
 2861 0077 62030000 		.4byte	.LASF9
 2862 007b 02       		.uleb128 0x2
 2863 007c 08       		.byte	0x8
 2864 007d 05       		.byte	0x5
 2865 007e 7D010000 		.4byte	.LASF10
 2866 0082 02       		.uleb128 0x2
 2867 0083 08       		.byte	0x8
 2868 0084 07       		.byte	0x7
 2869 0085 FB000000 		.4byte	.LASF11
 2870 0089 04       		.uleb128 0x4
 2871 008a 04       		.byte	0x4
 2872 008b 05       		.byte	0x5
 2873 008c 696E7400 		.ascii	"int\000"
 2874 0090 02       		.uleb128 0x2
 2875 0091 04       		.byte	0x4
 2876 0092 07       		.byte	0x7
 2877 0093 4C030000 		.4byte	.LASF12
 2878 0097 03       		.uleb128 0x3
 2879 0098 00080000 		.4byte	.LASF13
 2880 009c 03       		.byte	0x3
 2881 009d 18       		.byte	0x18
 2882 009e 2C000000 		.4byte	0x2c
 2883 00a2 03       		.uleb128 0x3
 2884 00a3 59030000 		.4byte	.LASF14
 2885 00a7 03       		.byte	0x3
 2886 00a8 24       		.byte	0x24
 2887 00a9 45000000 		.4byte	0x45
 2888 00ad 03       		.uleb128 0x3
 2889 00ae FE050000 		.4byte	.LASF15
 2890 00b2 03       		.byte	0x3
 2891 00b3 2C       		.byte	0x2c
 2892 00b4 57000000 		.4byte	0x57
 2893 00b8 03       		.uleb128 0x3
 2894 00b9 B6060000 		.4byte	.LASF16
 2895 00bd 03       		.byte	0x3
 2896 00be 30       		.byte	0x30
 2897 00bf 69000000 		.4byte	0x69
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 71


 2898 00c3 02       		.uleb128 0x2
 2899 00c4 04       		.byte	0x4
 2900 00c5 04       		.byte	0x4
 2901 00c6 C0050000 		.4byte	.LASF17
 2902 00ca 02       		.uleb128 0x2
 2903 00cb 08       		.byte	0x8
 2904 00cc 04       		.byte	0x4
 2905 00cd 0B090000 		.4byte	.LASF18
 2906 00d1 02       		.uleb128 0x2
 2907 00d2 01       		.byte	0x1
 2908 00d3 08       		.byte	0x8
 2909 00d4 E2060000 		.4byte	.LASF19
 2910 00d8 02       		.uleb128 0x2
 2911 00d9 08       		.byte	0x8
 2912 00da 04       		.byte	0x4
 2913 00db C3040000 		.4byte	.LASF20
 2914 00df 02       		.uleb128 0x2
 2915 00e0 04       		.byte	0x4
 2916 00e1 07       		.byte	0x7
 2917 00e2 BA040000 		.4byte	.LASF21
 2918 00e6 05       		.uleb128 0x5
 2919 00e7 97000000 		.4byte	0x97
 2920 00eb 06       		.uleb128 0x6
 2921 00ec 5C       		.byte	0x5c
 2922 00ed 04       		.byte	0x4
 2923 00ee 4F       		.byte	0x4f
 2924 00ef D8010000 		.4byte	0x1d8
 2925 00f3 07       		.uleb128 0x7
 2926 00f4 8D080000 		.4byte	.LASF22
 2927 00f8 04       		.byte	0x4
 2928 00f9 51       		.byte	0x51
 2929 00fa D8010000 		.4byte	0x1d8
 2930 00fe 00       		.byte	0
 2931 00ff 07       		.uleb128 0x7
 2932 0100 1E060000 		.4byte	.LASF23
 2933 0104 04       		.byte	0x4
 2934 0105 52       		.byte	0x52
 2935 0106 D8010000 		.4byte	0x1d8
 2936 010a 0C       		.byte	0xc
 2937 010b 07       		.uleb128 0x7
 2938 010c FE080000 		.4byte	.LASF24
 2939 0110 04       		.byte	0x4
 2940 0111 53       		.byte	0x53
 2941 0112 D8010000 		.4byte	0x1d8
 2942 0116 18       		.byte	0x18
 2943 0117 07       		.uleb128 0x7
 2944 0118 FE060000 		.4byte	.LASF25
 2945 011c 04       		.byte	0x4
 2946 011d 54       		.byte	0x54
 2947 011e D8010000 		.4byte	0x1d8
 2948 0122 24       		.byte	0x24
 2949 0123 07       		.uleb128 0x7
 2950 0124 9C050000 		.4byte	.LASF26
 2951 0128 04       		.byte	0x4
 2952 0129 57       		.byte	0x57
 2953 012a 97000000 		.4byte	0x97
 2954 012e 30       		.byte	0x30
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 72


 2955 012f 07       		.uleb128 0x7
 2956 0130 EF070000 		.4byte	.LASF27
 2957 0134 04       		.byte	0x4
 2958 0135 58       		.byte	0x58
 2959 0136 97000000 		.4byte	0x97
 2960 013a 31       		.byte	0x31
 2961 013b 07       		.uleb128 0x7
 2962 013c 4D040000 		.4byte	.LASF28
 2963 0140 04       		.byte	0x4
 2964 0141 59       		.byte	0x59
 2965 0142 97000000 		.4byte	0x97
 2966 0146 32       		.byte	0x32
 2967 0147 07       		.uleb128 0x7
 2968 0148 97010000 		.4byte	.LASF29
 2969 014c 04       		.byte	0x4
 2970 014d 5A       		.byte	0x5a
 2971 014e 97000000 		.4byte	0x97
 2972 0152 33       		.byte	0x33
 2973 0153 07       		.uleb128 0x7
 2974 0154 D5010000 		.4byte	.LASF30
 2975 0158 04       		.byte	0x4
 2976 0159 5B       		.byte	0x5b
 2977 015a 97000000 		.4byte	0x97
 2978 015e 34       		.byte	0x34
 2979 015f 07       		.uleb128 0x7
 2980 0160 58010000 		.4byte	.LASF31
 2981 0164 04       		.byte	0x4
 2982 0165 5C       		.byte	0x5c
 2983 0166 C3000000 		.4byte	0xc3
 2984 016a 38       		.byte	0x38
 2985 016b 07       		.uleb128 0x7
 2986 016c 1D080000 		.4byte	.LASF32
 2987 0170 04       		.byte	0x4
 2988 0171 5D       		.byte	0x5d
 2989 0172 C3000000 		.4byte	0xc3
 2990 0176 3C       		.byte	0x3c
 2991 0177 07       		.uleb128 0x7
 2992 0178 F5010000 		.4byte	.LASF33
 2993 017c 04       		.byte	0x4
 2994 017d 5F       		.byte	0x5f
 2995 017e C3000000 		.4byte	0xc3
 2996 0182 40       		.byte	0x40
 2997 0183 07       		.uleb128 0x7
 2998 0184 1A020000 		.4byte	.LASF34
 2999 0188 04       		.byte	0x4
 3000 0189 60       		.byte	0x60
 3001 018a C3000000 		.4byte	0xc3
 3002 018e 44       		.byte	0x44
 3003 018f 07       		.uleb128 0x7
 3004 0190 2B080000 		.4byte	.LASF35
 3005 0194 04       		.byte	0x4
 3006 0195 62       		.byte	0x62
 3007 0196 97000000 		.4byte	0x97
 3008 019a 48       		.byte	0x48
 3009 019b 07       		.uleb128 0x7
 3010 019c F0040000 		.4byte	.LASF36
 3011 01a0 04       		.byte	0x4
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 73


 3012 01a1 64       		.byte	0x64
 3013 01a2 97000000 		.4byte	0x97
 3014 01a6 49       		.byte	0x49
 3015 01a7 07       		.uleb128 0x7
 3016 01a8 A5020000 		.4byte	.LASF37
 3017 01ac 04       		.byte	0x4
 3018 01ad 65       		.byte	0x65
 3019 01ae C3000000 		.4byte	0xc3
 3020 01b2 4C       		.byte	0x4c
 3021 01b3 07       		.uleb128 0x7
 3022 01b4 4B060000 		.4byte	.LASF38
 3023 01b8 04       		.byte	0x4
 3024 01b9 66       		.byte	0x66
 3025 01ba C3000000 		.4byte	0xc3
 3026 01be 50       		.byte	0x50
 3027 01bf 07       		.uleb128 0x7
 3028 01c0 26010000 		.4byte	.LASF39
 3029 01c4 04       		.byte	0x4
 3030 01c5 67       		.byte	0x67
 3031 01c6 A2000000 		.4byte	0xa2
 3032 01ca 54       		.byte	0x54
 3033 01cb 07       		.uleb128 0x7
 3034 01cc 36020000 		.4byte	.LASF40
 3035 01d0 04       		.byte	0x4
 3036 01d1 68       		.byte	0x68
 3037 01d2 C3000000 		.4byte	0xc3
 3038 01d6 58       		.byte	0x58
 3039 01d7 00       		.byte	0
 3040 01d8 08       		.uleb128 0x8
 3041 01d9 C3000000 		.4byte	0xc3
 3042 01dd E8010000 		.4byte	0x1e8
 3043 01e1 09       		.uleb128 0x9
 3044 01e2 DF000000 		.4byte	0xdf
 3045 01e6 02       		.byte	0x2
 3046 01e7 00       		.byte	0
 3047 01e8 03       		.uleb128 0x3
 3048 01e9 5D040000 		.4byte	.LASF41
 3049 01ed 04       		.byte	0x4
 3050 01ee 69       		.byte	0x69
 3051 01ef EB000000 		.4byte	0xeb
 3052 01f3 06       		.uleb128 0x6
 3053 01f4 14       		.byte	0x14
 3054 01f5 05       		.byte	0x5
 3055 01f6 81       		.byte	0x81
 3056 01f7 A4020000 		.4byte	0x2a4
 3057 01fb 07       		.uleb128 0x7
 3058 01fc FD010000 		.4byte	.LASF42
 3059 0200 05       		.byte	0x5
 3060 0201 82       		.byte	0x82
 3061 0202 97000000 		.4byte	0x97
 3062 0206 00       		.byte	0
 3063 0207 07       		.uleb128 0x7
 3064 0208 29070000 		.4byte	.LASF43
 3065 020c 05       		.byte	0x5
 3066 020d 83       		.byte	0x83
 3067 020e 97000000 		.4byte	0x97
 3068 0212 01       		.byte	0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 74


 3069 0213 07       		.uleb128 0x7
 3070 0214 67080000 		.4byte	.LASF44
 3071 0218 05       		.byte	0x5
 3072 0219 84       		.byte	0x84
 3073 021a 97000000 		.4byte	0x97
 3074 021e 02       		.byte	0x2
 3075 021f 07       		.uleb128 0x7
 3076 0220 6D060000 		.4byte	.LASF45
 3077 0224 05       		.byte	0x5
 3078 0225 85       		.byte	0x85
 3079 0226 97000000 		.4byte	0x97
 3080 022a 03       		.byte	0x3
 3081 022b 07       		.uleb128 0x7
 3082 022c E5020000 		.4byte	.LASF46
 3083 0230 05       		.byte	0x5
 3084 0231 86       		.byte	0x86
 3085 0232 97000000 		.4byte	0x97
 3086 0236 04       		.byte	0x4
 3087 0237 07       		.uleb128 0x7
 3088 0238 5F070000 		.4byte	.LASF47
 3089 023c 05       		.byte	0x5
 3090 023d 87       		.byte	0x87
 3091 023e 97000000 		.4byte	0x97
 3092 0242 05       		.byte	0x5
 3093 0243 07       		.uleb128 0x7
 3094 0244 78060000 		.4byte	.LASF48
 3095 0248 05       		.byte	0x5
 3096 0249 88       		.byte	0x88
 3097 024a 97000000 		.4byte	0x97
 3098 024e 06       		.byte	0x6
 3099 024f 07       		.uleb128 0x7
 3100 0250 05030000 		.4byte	.LASF49
 3101 0254 05       		.byte	0x5
 3102 0255 89       		.byte	0x89
 3103 0256 97000000 		.4byte	0x97
 3104 025a 07       		.byte	0x7
 3105 025b 07       		.uleb128 0x7
 3106 025c CF040000 		.4byte	.LASF50
 3107 0260 05       		.byte	0x5
 3108 0261 8A       		.byte	0x8a
 3109 0262 97000000 		.4byte	0x97
 3110 0266 08       		.byte	0x8
 3111 0267 07       		.uleb128 0x7
 3112 0268 A4060000 		.4byte	.LASF51
 3113 026c 05       		.byte	0x5
 3114 026d 8B       		.byte	0x8b
 3115 026e 97000000 		.4byte	0x97
 3116 0272 09       		.byte	0x9
 3117 0273 07       		.uleb128 0x7
 3118 0274 C1070000 		.4byte	.LASF52
 3119 0278 05       		.byte	0x5
 3120 0279 8C       		.byte	0x8c
 3121 027a 97000000 		.4byte	0x97
 3122 027e 0A       		.byte	0xa
 3123 027f 07       		.uleb128 0x7
 3124 0280 AB080000 		.4byte	.LASF53
 3125 0284 05       		.byte	0x5
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 75


 3126 0285 8D       		.byte	0x8d
 3127 0286 97000000 		.4byte	0x97
 3128 028a 0B       		.byte	0xb
 3129 028b 07       		.uleb128 0x7
 3130 028c 57020000 		.4byte	.LASF54
 3131 0290 05       		.byte	0x5
 3132 0291 8E       		.byte	0x8e
 3133 0292 97000000 		.4byte	0x97
 3134 0296 0C       		.byte	0xc
 3135 0297 07       		.uleb128 0x7
 3136 0298 BE080000 		.4byte	.LASF55
 3137 029c 05       		.byte	0x5
 3138 029d 90       		.byte	0x90
 3139 029e C3000000 		.4byte	0xc3
 3140 02a2 10       		.byte	0x10
 3141 02a3 00       		.byte	0
 3142 02a4 03       		.uleb128 0x3
 3143 02a5 DC050000 		.4byte	.LASF56
 3144 02a9 05       		.byte	0x5
 3145 02aa 92       		.byte	0x92
 3146 02ab F3010000 		.4byte	0x1f3
 3147 02af 06       		.uleb128 0x6
 3148 02b0 34       		.byte	0x34
 3149 02b1 06       		.byte	0x6
 3150 02b2 39       		.byte	0x39
 3151 02b3 48030000 		.4byte	0x348
 3152 02b7 07       		.uleb128 0x7
 3153 02b8 D9080000 		.4byte	.LASF57
 3154 02bc 06       		.byte	0x6
 3155 02bd 3C       		.byte	0x3c
 3156 02be 48030000 		.4byte	0x348
 3157 02c2 00       		.byte	0
 3158 02c3 07       		.uleb128 0x7
 3159 02c4 9A080000 		.4byte	.LASF58
 3160 02c8 06       		.byte	0x6
 3161 02c9 3D       		.byte	0x3d
 3162 02ca B8000000 		.4byte	0xb8
 3163 02ce 0C       		.byte	0xc
 3164 02cf 07       		.uleb128 0x7
 3165 02d0 09070000 		.4byte	.LASF59
 3166 02d4 06       		.byte	0x6
 3167 02d5 3E       		.byte	0x3e
 3168 02d6 97000000 		.4byte	0x97
 3169 02da 10       		.byte	0x10
 3170 02db 07       		.uleb128 0x7
 3171 02dc 89060000 		.4byte	.LASF60
 3172 02e0 06       		.byte	0x6
 3173 02e1 41       		.byte	0x41
 3174 02e2 97000000 		.4byte	0x97
 3175 02e6 11       		.byte	0x11
 3176 02e7 07       		.uleb128 0x7
 3177 02e8 0A000000 		.4byte	.LASF61
 3178 02ec 06       		.byte	0x6
 3179 02ed 48       		.byte	0x48
 3180 02ee C3000000 		.4byte	0xc3
 3181 02f2 14       		.byte	0x14
 3182 02f3 07       		.uleb128 0x7
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 76


 3183 02f4 1A000000 		.4byte	.LASF62
 3184 02f8 06       		.byte	0x6
 3185 02f9 49       		.byte	0x49
 3186 02fa C3000000 		.4byte	0xc3
 3187 02fe 18       		.byte	0x18
 3188 02ff 07       		.uleb128 0x7
 3189 0300 FE080000 		.4byte	.LASF24
 3190 0304 06       		.byte	0x6
 3191 0305 4B       		.byte	0x4b
 3192 0306 C3000000 		.4byte	0xc3
 3193 030a 1C       		.byte	0x1c
 3194 030b 07       		.uleb128 0x7
 3195 030c B5070000 		.4byte	.LASF63
 3196 0310 06       		.byte	0x6
 3197 0311 4C       		.byte	0x4c
 3198 0312 C3000000 		.4byte	0xc3
 3199 0316 20       		.byte	0x20
 3200 0317 07       		.uleb128 0x7
 3201 0318 BE030000 		.4byte	.LASF64
 3202 031c 06       		.byte	0x6
 3203 031d 50       		.byte	0x50
 3204 031e C3000000 		.4byte	0xc3
 3205 0322 24       		.byte	0x24
 3206 0323 07       		.uleb128 0x7
 3207 0324 F3080000 		.4byte	.LASF65
 3208 0328 06       		.byte	0x6
 3209 0329 51       		.byte	0x51
 3210 032a C3000000 		.4byte	0xc3
 3211 032e 28       		.byte	0x28
 3212 032f 07       		.uleb128 0x7
 3213 0330 8A030000 		.4byte	.LASF66
 3214 0334 06       		.byte	0x6
 3215 0335 52       		.byte	0x52
 3216 0336 C3000000 		.4byte	0xc3
 3217 033a 2C       		.byte	0x2c
 3218 033b 07       		.uleb128 0x7
 3219 033c BE080000 		.4byte	.LASF55
 3220 0340 06       		.byte	0x6
 3221 0341 56       		.byte	0x56
 3222 0342 C3000000 		.4byte	0xc3
 3223 0346 30       		.byte	0x30
 3224 0347 00       		.byte	0
 3225 0348 08       		.uleb128 0x8
 3226 0349 B8000000 		.4byte	0xb8
 3227 034d 58030000 		.4byte	0x358
 3228 0351 09       		.uleb128 0x9
 3229 0352 DF000000 		.4byte	0xdf
 3230 0356 02       		.byte	0x2
 3231 0357 00       		.byte	0
 3232 0358 03       		.uleb128 0x3
 3233 0359 AD040000 		.4byte	.LASF67
 3234 035d 06       		.byte	0x6
 3235 035e 58       		.byte	0x58
 3236 035f AF020000 		.4byte	0x2af
 3237 0363 06       		.uleb128 0x6
 3238 0364 14       		.byte	0x14
 3239 0365 01       		.byte	0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 77


 3240 0366 3E       		.byte	0x3e
 3241 0367 9C030000 		.4byte	0x39c
 3242 036b 07       		.uleb128 0x7
 3243 036c D9080000 		.4byte	.LASF57
 3244 0370 01       		.byte	0x1
 3245 0371 3F       		.byte	0x3f
 3246 0372 48030000 		.4byte	0x348
 3247 0376 00       		.byte	0
 3248 0377 07       		.uleb128 0x7
 3249 0378 9A080000 		.4byte	.LASF58
 3250 037c 01       		.byte	0x1
 3251 037d 40       		.byte	0x40
 3252 037e B8000000 		.4byte	0xb8
 3253 0382 0C       		.byte	0xc
 3254 0383 07       		.uleb128 0x7
 3255 0384 09070000 		.4byte	.LASF59
 3256 0388 01       		.byte	0x1
 3257 0389 41       		.byte	0x41
 3258 038a 97000000 		.4byte	0x97
 3259 038e 10       		.byte	0x10
 3260 038f 07       		.uleb128 0x7
 3261 0390 87050000 		.4byte	.LASF68
 3262 0394 01       		.byte	0x1
 3263 0395 43       		.byte	0x43
 3264 0396 97000000 		.4byte	0x97
 3265 039a 11       		.byte	0x11
 3266 039b 00       		.byte	0
 3267 039c 03       		.uleb128 0x3
 3268 039d 41000000 		.4byte	.LASF69
 3269 03a1 01       		.byte	0x1
 3270 03a2 45       		.byte	0x45
 3271 03a3 63030000 		.4byte	0x363
 3272 03a7 06       		.uleb128 0x6
 3273 03a8 08       		.byte	0x8
 3274 03a9 01       		.byte	0x1
 3275 03aa 4C       		.byte	0x4c
 3276 03ab EC030000 		.4byte	0x3ec
 3277 03af 07       		.uleb128 0x7
 3278 03b0 9A030000 		.4byte	.LASF70
 3279 03b4 01       		.byte	0x1
 3280 03b5 4D       		.byte	0x4d
 3281 03b6 A2000000 		.4byte	0xa2
 3282 03ba 00       		.byte	0
 3283 03bb 07       		.uleb128 0x7
 3284 03bc 6F070000 		.4byte	.LASF71
 3285 03c0 01       		.byte	0x1
 3286 03c1 4E       		.byte	0x4e
 3287 03c2 A2000000 		.4byte	0xa2
 3288 03c6 02       		.byte	0x2
 3289 03c7 07       		.uleb128 0x7
 3290 03c8 04040000 		.4byte	.LASF72
 3291 03cc 01       		.byte	0x1
 3292 03cd 4F       		.byte	0x4f
 3293 03ce 97000000 		.4byte	0x97
 3294 03d2 04       		.byte	0x4
 3295 03d3 07       		.uleb128 0x7
 3296 03d4 2A030000 		.4byte	.LASF73
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 78


 3297 03d8 01       		.byte	0x1
 3298 03d9 51       		.byte	0x51
 3299 03da 97000000 		.4byte	0x97
 3300 03de 05       		.byte	0x5
 3301 03df 07       		.uleb128 0x7
 3302 03e0 C6050000 		.4byte	.LASF74
 3303 03e4 01       		.byte	0x1
 3304 03e5 56       		.byte	0x56
 3305 03e6 97000000 		.4byte	0x97
 3306 03ea 06       		.byte	0x6
 3307 03eb 00       		.byte	0
 3308 03ec 03       		.uleb128 0x3
 3309 03ed 5C060000 		.4byte	.LASF75
 3310 03f1 01       		.byte	0x1
 3311 03f2 58       		.byte	0x58
 3312 03f3 A7030000 		.4byte	0x3a7
 3313 03f7 06       		.uleb128 0x6
 3314 03f8 28       		.byte	0x28
 3315 03f9 01       		.byte	0x1
 3316 03fa 5C       		.byte	0x5c
 3317 03fb 90040000 		.4byte	0x490
 3318 03ff 07       		.uleb128 0x7
 3319 0400 6A050000 		.4byte	.LASF76
 3320 0404 01       		.byte	0x1
 3321 0405 5E       		.byte	0x5e
 3322 0406 B8000000 		.4byte	0xb8
 3323 040a 00       		.byte	0
 3324 040b 07       		.uleb128 0x7
 3325 040c 74050000 		.4byte	.LASF77
 3326 0410 01       		.byte	0x1
 3327 0411 5F       		.byte	0x5f
 3328 0412 B8000000 		.4byte	0xb8
 3329 0416 04       		.byte	0x4
 3330 0417 07       		.uleb128 0x7
 3331 0418 87040000 		.4byte	.LASF78
 3332 041c 01       		.byte	0x1
 3333 041d 60       		.byte	0x60
 3334 041e B8000000 		.4byte	0xb8
 3335 0422 08       		.byte	0x8
 3336 0423 07       		.uleb128 0x7
 3337 0424 EC030000 		.4byte	.LASF79
 3338 0428 01       		.byte	0x1
 3339 0429 6F       		.byte	0x6f
 3340 042a 97000000 		.4byte	0x97
 3341 042e 0C       		.byte	0xc
 3342 042f 07       		.uleb128 0x7
 3343 0430 7F070000 		.4byte	.LASF80
 3344 0434 01       		.byte	0x1
 3345 0435 70       		.byte	0x70
 3346 0436 97000000 		.4byte	0x97
 3347 043a 0D       		.byte	0xd
 3348 043b 07       		.uleb128 0x7
 3349 043c B9010000 		.4byte	.LASF81
 3350 0440 01       		.byte	0x1
 3351 0441 71       		.byte	0x71
 3352 0442 97000000 		.4byte	0x97
 3353 0446 0E       		.byte	0xe
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 79


 3354 0447 07       		.uleb128 0x7
 3355 0448 4C000000 		.4byte	.LASF82
 3356 044c 01       		.byte	0x1
 3357 044d 72       		.byte	0x72
 3358 044e 97000000 		.4byte	0x97
 3359 0452 0F       		.byte	0xf
 3360 0453 07       		.uleb128 0x7
 3361 0454 D9080000 		.4byte	.LASF57
 3362 0458 01       		.byte	0x1
 3363 0459 74       		.byte	0x74
 3364 045a 48030000 		.4byte	0x348
 3365 045e 10       		.byte	0x10
 3366 045f 07       		.uleb128 0x7
 3367 0460 9A020000 		.4byte	.LASF83
 3368 0464 01       		.byte	0x1
 3369 0465 77       		.byte	0x77
 3370 0466 A2000000 		.4byte	0xa2
 3371 046a 1C       		.byte	0x1c
 3372 046b 07       		.uleb128 0x7
 3373 046c AD030000 		.4byte	.LASF84
 3374 0470 01       		.byte	0x1
 3375 0471 78       		.byte	0x78
 3376 0472 97000000 		.4byte	0x97
 3377 0476 1E       		.byte	0x1e
 3378 0477 07       		.uleb128 0x7
 3379 0478 F9030000 		.4byte	.LASF85
 3380 047c 01       		.byte	0x1
 3381 047d 79       		.byte	0x79
 3382 047e 90040000 		.4byte	0x490
 3383 0482 20       		.byte	0x20
 3384 0483 07       		.uleb128 0x7
 3385 0484 8D020000 		.4byte	.LASF86
 3386 0488 01       		.byte	0x1
 3387 0489 7A       		.byte	0x7a
 3388 048a 96040000 		.4byte	0x496
 3389 048e 24       		.byte	0x24
 3390 048f 00       		.byte	0
 3391 0490 0A       		.uleb128 0xa
 3392 0491 04       		.byte	0x4
 3393 0492 9C030000 		.4byte	0x39c
 3394 0496 0A       		.uleb128 0xa
 3395 0497 04       		.byte	0x4
 3396 0498 EC030000 		.4byte	0x3ec
 3397 049c 03       		.uleb128 0x3
 3398 049d 6F080000 		.4byte	.LASF87
 3399 04a1 01       		.byte	0x1
 3400 04a2 7B       		.byte	0x7b
 3401 04a3 F7030000 		.4byte	0x3f7
 3402 04a7 06       		.uleb128 0x6
 3403 04a8 38       		.byte	0x38
 3404 04a9 01       		.byte	0x1
 3405 04aa 91       		.byte	0x91
 3406 04ab 64050000 		.4byte	0x564
 3407 04af 07       		.uleb128 0x7
 3408 04b0 04040000 		.4byte	.LASF72
 3409 04b4 01       		.byte	0x1
 3410 04b5 92       		.byte	0x92
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 80


 3411 04b6 97000000 		.4byte	0x97
 3412 04ba 00       		.byte	0
 3413 04bb 07       		.uleb128 0x7
 3414 04bc 19030000 		.4byte	.LASF88
 3415 04c0 01       		.byte	0x1
 3416 04c1 93       		.byte	0x93
 3417 04c2 97000000 		.4byte	0x97
 3418 04c6 01       		.byte	0x1
 3419 04c7 07       		.uleb128 0x7
 3420 04c8 E7060000 		.4byte	.LASF89
 3421 04cc 01       		.byte	0x1
 3422 04cd 95       		.byte	0x95
 3423 04ce C3000000 		.4byte	0xc3
 3424 04d2 04       		.byte	0x4
 3425 04d3 07       		.uleb128 0x7
 3426 04d4 DC030000 		.4byte	.LASF90
 3427 04d8 01       		.byte	0x1
 3428 04d9 96       		.byte	0x96
 3429 04da C3000000 		.4byte	0xc3
 3430 04de 08       		.byte	0x8
 3431 04df 07       		.uleb128 0x7
 3432 04e0 BF060000 		.4byte	.LASF91
 3433 04e4 01       		.byte	0x1
 3434 04e5 97       		.byte	0x97
 3435 04e6 C3000000 		.4byte	0xc3
 3436 04ea 0C       		.byte	0xc
 3437 04eb 07       		.uleb128 0x7
 3438 04ec 93060000 		.4byte	.LASF92
 3439 04f0 01       		.byte	0x1
 3440 04f1 98       		.byte	0x98
 3441 04f2 C3000000 		.4byte	0xc3
 3442 04f6 10       		.byte	0x10
 3443 04f7 07       		.uleb128 0x7
 3444 04f8 14060000 		.4byte	.LASF93
 3445 04fc 01       		.byte	0x1
 3446 04fd A1       		.byte	0xa1
 3447 04fe 97000000 		.4byte	0x97
 3448 0502 14       		.byte	0x14
 3449 0503 07       		.uleb128 0x7
 3450 0504 91040000 		.4byte	.LASF94
 3451 0508 01       		.byte	0x1
 3452 0509 A2       		.byte	0xa2
 3453 050a C3000000 		.4byte	0xc3
 3454 050e 18       		.byte	0x18
 3455 050f 07       		.uleb128 0x7
 3456 0510 0C020000 		.4byte	.LASF95
 3457 0514 01       		.byte	0x1
 3458 0515 A4       		.byte	0xa4
 3459 0516 C3000000 		.4byte	0xc3
 3460 051a 1C       		.byte	0x1c
 3461 051b 07       		.uleb128 0x7
 3462 051c A2070000 		.4byte	.LASF96
 3463 0520 01       		.byte	0x1
 3464 0521 A5       		.byte	0xa5
 3465 0522 C3000000 		.4byte	0xc3
 3466 0526 20       		.byte	0x20
 3467 0527 07       		.uleb128 0x7
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 81


 3468 0528 D2070000 		.4byte	.LASF97
 3469 052c 01       		.byte	0x1
 3470 052d A6       		.byte	0xa6
 3471 052e C3000000 		.4byte	0xc3
 3472 0532 24       		.byte	0x24
 3473 0533 07       		.uleb128 0x7
 3474 0534 18070000 		.4byte	.LASF98
 3475 0538 01       		.byte	0x1
 3476 0539 A7       		.byte	0xa7
 3477 053a C3000000 		.4byte	0xc3
 3478 053e 28       		.byte	0x28
 3479 053f 07       		.uleb128 0x7
 3480 0540 AF050000 		.4byte	.LASF99
 3481 0544 01       		.byte	0x1
 3482 0545 A8       		.byte	0xa8
 3483 0546 C3000000 		.4byte	0xc3
 3484 054a 2C       		.byte	0x2c
 3485 054b 07       		.uleb128 0x7
 3486 054c 43030000 		.4byte	.LASF100
 3487 0550 01       		.byte	0x1
 3488 0551 AB       		.byte	0xab
 3489 0552 C3000000 		.4byte	0xc3
 3490 0556 30       		.byte	0x30
 3491 0557 07       		.uleb128 0x7
 3492 0558 22020000 		.4byte	.LASF101
 3493 055c 01       		.byte	0x1
 3494 055d AC       		.byte	0xac
 3495 055e 97000000 		.4byte	0x97
 3496 0562 34       		.byte	0x34
 3497 0563 00       		.byte	0
 3498 0564 03       		.uleb128 0x3
 3499 0565 C6010000 		.4byte	.LASF102
 3500 0569 01       		.byte	0x1
 3501 056a AE       		.byte	0xae
 3502 056b A7040000 		.4byte	0x4a7
 3503 056f 0B       		.uleb128 0xb
 3504 0570 82080000 		.4byte	.LASF104
 3505 0574 01       		.byte	0x1
 3506 0575 DB       		.byte	0xdb
 3507 0576 00000000 		.4byte	.LFB64
 3508 057a 44000000 		.4byte	.LFE64-.LFB64
 3509 057e 01       		.uleb128 0x1
 3510 057f 9C       		.byte	0x9c
 3511 0580 0C       		.uleb128 0xc
 3512 0581 E5040000 		.4byte	.LASF106
 3513 0585 01       		.byte	0x1
 3514 0586 F5       		.byte	0xf5
 3515 0587 00000000 		.4byte	.LFB65
 3516 058b 68000000 		.4byte	.LFE65-.LFB65
 3517 058f 01       		.uleb128 0x1
 3518 0590 9C       		.byte	0x9c
 3519 0591 A4050000 		.4byte	0x5a4
 3520 0595 0D       		.uleb128 0xd
 3521 0596 D2050000 		.4byte	.LASF108
 3522 059a 01       		.byte	0x1
 3523 059b FE       		.byte	0xfe
 3524 059c A4050000 		.4byte	0x5a4
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 82


 3525 05a0 02       		.uleb128 0x2
 3526 05a1 91       		.byte	0x91
 3527 05a2 77       		.sleb128 -9
 3528 05a3 00       		.byte	0
 3529 05a4 02       		.uleb128 0x2
 3530 05a5 01       		.byte	0x1
 3531 05a6 02       		.byte	0x2
 3532 05a7 F8050000 		.4byte	.LASF103
 3533 05ab 0E       		.uleb128 0xe
 3534 05ac 6B010000 		.4byte	.LASF105
 3535 05b0 01       		.byte	0x1
 3536 05b1 3D01     		.2byte	0x13d
 3537 05b3 00000000 		.4byte	.LFB66
 3538 05b7 00030000 		.4byte	.LFE66-.LFB66
 3539 05bb 01       		.uleb128 0x1
 3540 05bc 9C       		.byte	0x9c
 3541 05bd 0F       		.uleb128 0xf
 3542 05be 45080000 		.4byte	.LASF107
 3543 05c2 01       		.byte	0x1
 3544 05c3 1002     		.2byte	0x210
 3545 05c5 00000000 		.4byte	.LFB67
 3546 05c9 94000000 		.4byte	.LFE67-.LFB67
 3547 05cd 01       		.uleb128 0x1
 3548 05ce 9C       		.byte	0x9c
 3549 05cf E3050000 		.4byte	0x5e3
 3550 05d3 10       		.uleb128 0x10
 3551 05d4 69647800 		.ascii	"idx\000"
 3552 05d8 01       		.byte	0x1
 3553 05d9 1202     		.2byte	0x212
 3554 05db 97000000 		.4byte	0x97
 3555 05df 02       		.uleb128 0x2
 3556 05e0 91       		.byte	0x91
 3557 05e1 77       		.sleb128 -9
 3558 05e2 00       		.byte	0
 3559 05e3 0E       		.uleb128 0xe
 3560 05e4 79080000 		.4byte	.LASF109
 3561 05e8 01       		.byte	0x1
 3562 05e9 1D02     		.2byte	0x21d
 3563 05eb 00000000 		.4byte	.LFB68
 3564 05ef 94000000 		.4byte	.LFE68-.LFB68
 3565 05f3 01       		.uleb128 0x1
 3566 05f4 9C       		.byte	0x9c
 3567 05f5 0E       		.uleb128 0xe
 3568 05f6 E8010000 		.4byte	.LASF110
 3569 05fa 01       		.byte	0x1
 3570 05fb 3802     		.2byte	0x238
 3571 05fd 00000000 		.4byte	.LFB69
 3572 0601 18000000 		.4byte	.LFE69-.LFB69
 3573 0605 01       		.uleb128 0x1
 3574 0606 9C       		.byte	0x9c
 3575 0607 0E       		.uleb128 0xe
 3576 0608 3F070000 		.4byte	.LASF111
 3577 060c 01       		.byte	0x1
 3578 060d 4002     		.2byte	0x240
 3579 060f 00000000 		.4byte	.LFB70
 3580 0613 44000000 		.4byte	.LFE70-.LFB70
 3581 0617 01       		.uleb128 0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 83


 3582 0618 9C       		.byte	0x9c
 3583 0619 11       		.uleb128 0x11
 3584 061a 12010000 		.4byte	.LASF153
 3585 061e 01       		.byte	0x1
 3586 061f 4B02     		.2byte	0x24b
 3587 0621 97000000 		.4byte	0x97
 3588 0625 00000000 		.4byte	.LFB71
 3589 0629 26000000 		.4byte	.LFE71-.LFB71
 3590 062d 01       		.uleb128 0x1
 3591 062e 9C       		.byte	0x9c
 3592 062f 43060000 		.4byte	0x643
 3593 0633 12       		.uleb128 0x12
 3594 0634 A1030000 		.4byte	.LASF154
 3595 0638 01       		.byte	0x1
 3596 0639 4B02     		.2byte	0x24b
 3597 063b 97000000 		.4byte	0x97
 3598 063f 02       		.uleb128 0x2
 3599 0640 91       		.byte	0x91
 3600 0641 77       		.sleb128 -9
 3601 0642 00       		.byte	0
 3602 0643 0F       		.uleb128 0xf
 3603 0644 74030000 		.4byte	.LASF112
 3604 0648 01       		.byte	0x1
 3605 0649 8602     		.2byte	0x286
 3606 064b 00000000 		.4byte	.LFB72
 3607 064f 480D0000 		.4byte	.LFE72-.LFB72
 3608 0653 01       		.uleb128 0x1
 3609 0654 9C       		.byte	0x9c
 3610 0655 E1070000 		.4byte	0x7e1
 3611 0659 13       		.uleb128 0x13
 3612 065a 00000000 		.4byte	.Ldebug_ranges0+0
 3613 065e 14       		.uleb128 0x14
 3614 065f 36030000 		.4byte	.LASF113
 3615 0663 01       		.byte	0x1
 3616 0664 3303     		.2byte	0x333
 3617 0666 96040000 		.4byte	0x496
 3618 066a 03       		.uleb128 0x3
 3619 066b 91       		.byte	0x91
 3620 066c B87F     		.sleb128 -72
 3621 066e 14       		.uleb128 0x14
 3622 066f D5030000 		.4byte	.LASF114
 3623 0673 01       		.byte	0x1
 3624 0674 4603     		.2byte	0x346
 3625 0676 C3000000 		.4byte	0xc3
 3626 067a 02       		.uleb128 0x2
 3627 067b 91       		.byte	0x91
 3628 067c 54       		.sleb128 -44
 3629 067d 10       		.uleb128 0x10
 3630 067e 647400   		.ascii	"dt\000"
 3631 0681 01       		.byte	0x1
 3632 0682 4703     		.2byte	0x347
 3633 0684 C3000000 		.4byte	0xc3
 3634 0688 02       		.uleb128 0x2
 3635 0689 91       		.byte	0x91
 3636 068a 50       		.sleb128 -48
 3637 068b 14       		.uleb128 0x14
 3638 068c 10030000 		.4byte	.LASF115
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 84


 3639 0690 01       		.byte	0x1
 3640 0691 4803     		.2byte	0x348
 3641 0693 C3000000 		.4byte	0xc3
 3642 0697 02       		.uleb128 0x2
 3643 0698 91       		.byte	0x91
 3644 0699 4C       		.sleb128 -52
 3645 069a 14       		.uleb128 0x14
 3646 069b 83030000 		.4byte	.LASF116
 3647 069f 01       		.byte	0x1
 3648 06a0 4903     		.2byte	0x349
 3649 06a2 C3000000 		.4byte	0xc3
 3650 06a6 03       		.uleb128 0x3
 3651 06a7 91       		.byte	0x91
 3652 06a8 B07F     		.sleb128 -80
 3653 06aa 14       		.uleb128 0x14
 3654 06ab 78020000 		.4byte	.LASF117
 3655 06af 01       		.byte	0x1
 3656 06b0 4A03     		.2byte	0x34a
 3657 06b2 C3000000 		.4byte	0xc3
 3658 06b6 03       		.uleb128 0x3
 3659 06b7 91       		.byte	0x91
 3660 06b8 B47F     		.sleb128 -76
 3661 06ba 14       		.uleb128 0x14
 3662 06bb CC080000 		.4byte	.LASF118
 3663 06bf 01       		.byte	0x1
 3664 06c0 4B03     		.2byte	0x34b
 3665 06c2 C3000000 		.4byte	0xc3
 3666 06c6 02       		.uleb128 0x2
 3667 06c7 91       		.byte	0x91
 3668 06c8 48       		.sleb128 -56
 3669 06c9 14       		.uleb128 0x14
 3670 06ca AE010000 		.4byte	.LASF119
 3671 06ce 01       		.byte	0x1
 3672 06cf 4C03     		.2byte	0x34c
 3673 06d1 C3000000 		.4byte	0xc3
 3674 06d5 02       		.uleb128 0x2
 3675 06d6 91       		.byte	0x91
 3676 06d7 44       		.sleb128 -60
 3677 06d8 14       		.uleb128 0x14
 3678 06d9 31080000 		.4byte	.LASF120
 3679 06dd 01       		.byte	0x1
 3680 06de BC03     		.2byte	0x3bc
 3681 06e0 C3000000 		.4byte	0xc3
 3682 06e4 03       		.uleb128 0x3
 3683 06e5 91       		.byte	0x91
 3684 06e6 AC7F     		.sleb128 -84
 3685 06e8 14       		.uleb128 0x14
 3686 06e9 DD070000 		.4byte	.LASF121
 3687 06ed 01       		.byte	0x1
 3688 06ee BD03     		.2byte	0x3bd
 3689 06f0 C3000000 		.4byte	0xc3
 3690 06f4 03       		.uleb128 0x3
 3691 06f5 91       		.byte	0x91
 3692 06f6 A87F     		.sleb128 -88
 3693 06f8 14       		.uleb128 0x14
 3694 06f9 CB060000 		.4byte	.LASF122
 3695 06fd 01       		.byte	0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 85


 3696 06fe BE03     		.2byte	0x3be
 3697 0700 C3000000 		.4byte	0xc3
 3698 0704 03       		.uleb128 0x3
 3699 0705 91       		.byte	0x91
 3700 0706 A47F     		.sleb128 -92
 3701 0708 14       		.uleb128 0x14
 3702 0709 43030000 		.4byte	.LASF100
 3703 070d 01       		.byte	0x1
 3704 070e D703     		.2byte	0x3d7
 3705 0710 C3000000 		.4byte	0xc3
 3706 0714 03       		.uleb128 0x3
 3707 0715 91       		.byte	0x91
 3708 0716 A07F     		.sleb128 -96
 3709 0718 14       		.uleb128 0x14
 3710 0719 66060000 		.4byte	.LASF123
 3711 071d 01       		.byte	0x1
 3712 071e DA03     		.2byte	0x3da
 3713 0720 B8000000 		.4byte	0xb8
 3714 0724 03       		.uleb128 0x3
 3715 0725 91       		.byte	0x91
 3716 0726 BC7F     		.sleb128 -68
 3717 0728 15       		.uleb128 0x15
 3718 0729 18000000 		.4byte	.Ldebug_ranges0+0x18
 3719 072d C6070000 		.4byte	0x7c6
 3720 0731 14       		.uleb128 0x14
 3721 0732 0F050000 		.4byte	.LASF124
 3722 0736 01       		.byte	0x1
 3723 0737 D902     		.2byte	0x2d9
 3724 0739 C3000000 		.4byte	0xc3
 3725 073d 03       		.uleb128 0x3
 3726 073e 91       		.byte	0x91
 3727 073f 9C7F     		.sleb128 -100
 3728 0741 16       		.uleb128 0x16
 3729 0742 64000000 		.4byte	.LBB4
 3730 0746 74010000 		.4byte	.LBE4-.LBB4
 3731 074a 5E070000 		.4byte	0x75e
 3732 074e 10       		.uleb128 0x10
 3733 074f 69647800 		.ascii	"idx\000"
 3734 0753 01       		.byte	0x1
 3735 0754 A902     		.2byte	0x2a9
 3736 0756 97000000 		.4byte	0x97
 3737 075a 02       		.uleb128 0x2
 3738 075b 91       		.byte	0x91
 3739 075c 5F       		.sleb128 -33
 3740 075d 00       		.byte	0
 3741 075e 16       		.uleb128 0x16
 3742 075f 00020000 		.4byte	.LBB5
 3743 0763 BC000000 		.4byte	.LBE5-.LBB5
 3744 0767 7C070000 		.4byte	0x77c
 3745 076b 14       		.uleb128 0x14
 3746 076c DA040000 		.4byte	.LASF125
 3747 0770 01       		.byte	0x1
 3748 0771 DF02     		.2byte	0x2df
 3749 0773 C3000000 		.4byte	0xc3
 3750 0777 03       		.uleb128 0x3
 3751 0778 91       		.byte	0x91
 3752 0779 987F     		.sleb128 -104
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 86


 3753 077b 00       		.byte	0
 3754 077c 17       		.uleb128 0x17
 3755 077d BC020000 		.4byte	.LBB6
 3756 0781 CC020000 		.4byte	.LBE6-.LBB6
 3757 0785 14       		.uleb128 0x14
 3758 0786 00050000 		.4byte	.LASF126
 3759 078a 01       		.byte	0x1
 3760 078b EC02     		.2byte	0x2ec
 3761 078d C3000000 		.4byte	0xc3
 3762 0791 02       		.uleb128 0x2
 3763 0792 91       		.byte	0x91
 3764 0793 58       		.sleb128 -40
 3765 0794 14       		.uleb128 0x14
 3766 0795 6A020000 		.4byte	.LASF127
 3767 0799 01       		.byte	0x1
 3768 079a ED02     		.2byte	0x2ed
 3769 079c C3000000 		.4byte	0xc3
 3770 07a0 03       		.uleb128 0x3
 3771 07a1 91       		.byte	0x91
 3772 07a2 947F     		.sleb128 -108
 3773 07a4 14       		.uleb128 0x14
 3774 07a5 12090000 		.4byte	.LASF128
 3775 07a9 01       		.byte	0x1
 3776 07aa F602     		.2byte	0x2f6
 3777 07ac C3000000 		.4byte	0xc3
 3778 07b0 03       		.uleb128 0x3
 3779 07b1 91       		.byte	0x91
 3780 07b2 907F     		.sleb128 -112
 3781 07b4 14       		.uleb128 0x14
 3782 07b5 E5050000 		.4byte	.LASF129
 3783 07b9 01       		.byte	0x1
 3784 07ba F702     		.2byte	0x2f7
 3785 07bc C3000000 		.4byte	0xc3
 3786 07c0 03       		.uleb128 0x3
 3787 07c1 91       		.byte	0x91
 3788 07c2 8C7F     		.sleb128 -116
 3789 07c4 00       		.byte	0
 3790 07c5 00       		.byte	0
 3791 07c6 17       		.uleb128 0x17
 3792 07c7 7E0A0000 		.4byte	.LBB7
 3793 07cb 48000000 		.4byte	.LBE7-.LBB7
 3794 07cf 10       		.uleb128 0x10
 3795 07d0 72706D00 		.ascii	"rpm\000"
 3796 07d4 01       		.byte	0x1
 3797 07d5 A203     		.2byte	0x3a2
 3798 07d7 C3000000 		.4byte	0xc3
 3799 07db 02       		.uleb128 0x2
 3800 07dc 91       		.byte	0x91
 3801 07dd 40       		.sleb128 -64
 3802 07de 00       		.byte	0
 3803 07df 00       		.byte	0
 3804 07e0 00       		.byte	0
 3805 07e1 18       		.uleb128 0x18
 3806 07e2 E6000000 		.4byte	.LASF155
 3807 07e6 01       		.byte	0x1
 3808 07e7 2304     		.2byte	0x423
 3809 07e9 C3000000 		.4byte	0xc3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 87


 3810 07ed 00000000 		.4byte	.LFB73
 3811 07f1 2C000000 		.4byte	.LFE73-.LFB73
 3812 07f5 01       		.uleb128 0x1
 3813 07f6 9C       		.byte	0x9c
 3814 07f7 08       		.uleb128 0x8
 3815 07f8 9C030000 		.4byte	0x39c
 3816 07fc 07080000 		.4byte	0x807
 3817 0800 09       		.uleb128 0x9
 3818 0801 DF000000 		.4byte	0xdf
 3819 0805 04       		.byte	0x4
 3820 0806 00       		.byte	0
 3821 0807 0D       		.uleb128 0xd
 3822 0808 9D040000 		.4byte	.LASF130
 3823 080c 01       		.byte	0x1
 3824 080d 46       		.byte	0x46
 3825 080e F7070000 		.4byte	0x7f7
 3826 0812 05       		.uleb128 0x5
 3827 0813 03       		.byte	0x3
 3828 0814 00000000 		.4byte	st_block_buffer
 3829 0818 08       		.uleb128 0x8
 3830 0819 EC030000 		.4byte	0x3ec
 3831 081d 28080000 		.4byte	0x828
 3832 0821 09       		.uleb128 0x9
 3833 0822 DF000000 		.4byte	0xdf
 3834 0826 05       		.byte	0x5
 3835 0827 00       		.byte	0
 3836 0828 0D       		.uleb128 0xd
 3837 0829 49010000 		.4byte	.LASF131
 3838 082d 01       		.byte	0x1
 3839 082e 59       		.byte	0x59
 3840 082f 18080000 		.4byte	0x818
 3841 0833 05       		.uleb128 0x5
 3842 0834 03       		.byte	0x3
 3843 0835 64000000 		.4byte	segment_buffer
 3844 0839 19       		.uleb128 0x19
 3845 083a 737400   		.ascii	"st\000"
 3846 083d 01       		.byte	0x1
 3847 083e 7C       		.byte	0x7c
 3848 083f 9C040000 		.4byte	0x49c
 3849 0843 05       		.uleb128 0x5
 3850 0844 03       		.byte	0x3
 3851 0845 94000000 		.4byte	st
 3852 0849 0D       		.uleb128 0xd
 3853 084a 13040000 		.4byte	.LASF132
 3854 084e 01       		.byte	0x1
 3855 084f 7F       		.byte	0x7f
 3856 0850 E6000000 		.4byte	0xe6
 3857 0854 05       		.uleb128 0x5
 3858 0855 03       		.byte	0x3
 3859 0856 BC000000 		.4byte	segment_buffer_tail
 3860 085a 0D       		.uleb128 0xd
 3861 085b DF080000 		.4byte	.LASF133
 3862 085f 01       		.byte	0x1
 3863 0860 80       		.byte	0x80
 3864 0861 97000000 		.4byte	0x97
 3865 0865 05       		.uleb128 0x5
 3866 0866 03       		.byte	0x3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 88


 3867 0867 BD000000 		.4byte	segment_buffer_head
 3868 086b 0D       		.uleb128 0xd
 3869 086c 27060000 		.4byte	.LASF134
 3870 0870 01       		.byte	0x1
 3871 0871 81       		.byte	0x81
 3872 0872 97000000 		.4byte	0x97
 3873 0876 05       		.uleb128 0x5
 3874 0877 03       		.byte	0x3
 3875 0878 BE000000 		.4byte	segment_next_head
 3876 087c 0D       		.uleb128 0xd
 3877 087d C1020000 		.4byte	.LASF135
 3878 0881 01       		.byte	0x1
 3879 0882 84       		.byte	0x84
 3880 0883 97000000 		.4byte	0x97
 3881 0887 05       		.uleb128 0x5
 3882 0888 03       		.byte	0x3
 3883 0889 BF000000 		.4byte	step_port_invert_mask
 3884 088d 0D       		.uleb128 0xd
 3885 088e 08080000 		.4byte	.LASF136
 3886 0892 01       		.byte	0x1
 3887 0893 85       		.byte	0x85
 3888 0894 97000000 		.4byte	0x97
 3889 0898 05       		.uleb128 0x5
 3890 0899 03       		.byte	0x3
 3891 089a C0000000 		.4byte	dir_port_invert_mask
 3892 089e 0D       		.uleb128 0xd
 3893 089f D0010000 		.4byte	.LASF137
 3894 08a3 01       		.byte	0x1
 3895 08a4 88       		.byte	0x88
 3896 08a5 E6000000 		.4byte	0xe6
 3897 08a9 05       		.uleb128 0x5
 3898 08aa 03       		.byte	0x3
 3899 08ab C1000000 		.4byte	busy
 3900 08af 0D       		.uleb128 0xd
 3901 08b0 2E000000 		.4byte	.LASF138
 3902 08b4 01       		.byte	0x1
 3903 08b5 8C       		.byte	0x8c
 3904 08b6 C0080000 		.4byte	0x8c0
 3905 08ba 05       		.uleb128 0x5
 3906 08bb 03       		.byte	0x3
 3907 08bc C4000000 		.4byte	pl_block
 3908 08c0 0A       		.uleb128 0xa
 3909 08c1 04       		.byte	0x4
 3910 08c2 58030000 		.4byte	0x358
 3911 08c6 0D       		.uleb128 0xd
 3912 08c7 D7020000 		.4byte	.LASF139
 3913 08cb 01       		.byte	0x1
 3914 08cc 8D       		.byte	0x8d
 3915 08cd 90040000 		.4byte	0x490
 3916 08d1 05       		.uleb128 0x5
 3917 08d2 03       		.byte	0x3
 3918 08d3 C8000000 		.4byte	st_prep_block
 3919 08d7 0D       		.uleb128 0xd
 3920 08d8 B0070000 		.4byte	.LASF140
 3921 08dc 01       		.byte	0x1
 3922 08dd AF       		.byte	0xaf
 3923 08de 64050000 		.4byte	0x564
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 89


 3924 08e2 05       		.uleb128 0x5
 3925 08e3 03       		.byte	0x3
 3926 08e4 CC000000 		.4byte	prep
 3927 08e8 1A       		.uleb128 0x1a
 3928 08e9 3C010000 		.4byte	.LASF141
 3929 08ed 07       		.byte	0x7
 3930 08ee 1207     		.2byte	0x712
 3931 08f0 F4080000 		.4byte	0x8f4
 3932 08f4 05       		.uleb128 0x5
 3933 08f5 AD000000 		.4byte	0xad
 3934 08f9 1B       		.uleb128 0x1b
 3935 08fa 7E050000 		.4byte	.LASF142
 3936 08fe 04       		.byte	0x4
 3937 08ff 6A       		.byte	0x6a
 3938 0900 E8010000 		.4byte	0x1e8
 3939 0904 1C       		.uleb128 0x1c
 3940 0905 73797300 		.ascii	"sys\000"
 3941 0909 05       		.byte	0x5
 3942 090a 93       		.byte	0x93
 3943 090b A4020000 		.4byte	0x2a4
 3944 090f 08       		.uleb128 0x8
 3945 0910 AD000000 		.4byte	0xad
 3946 0914 1F090000 		.4byte	0x91f
 3947 0918 09       		.uleb128 0x9
 3948 0919 DF000000 		.4byte	0xdf
 3949 091d 02       		.byte	0x2
 3950 091e 00       		.byte	0
 3951 091f 1D       		.uleb128 0x1d
 3952 0920 5D050000 		.4byte	.LASF143
 3953 0924 05       		.byte	0x5
 3954 0925 96       		.byte	0x96
 3955 0926 0F090000 		.4byte	0x90f
 3956 092a 05       		.uleb128 0x5
 3957 092b 03       		.byte	0x3
 3958 092c 00000000 		.4byte	sys_position
 3959 0930 1D       		.uleb128 0x1d
 3960 0931 F2020000 		.4byte	.LASF144
 3961 0935 05       		.byte	0x5
 3962 0936 97       		.byte	0x97
 3963 0937 0F090000 		.4byte	0x90f
 3964 093b 05       		.uleb128 0x5
 3965 093c 03       		.byte	0x3
 3966 093d 00000000 		.4byte	sys_probe_position
 3967 0941 1D       		.uleb128 0x1d
 3968 0942 2F070000 		.4byte	.LASF145
 3969 0946 05       		.byte	0x5
 3970 0947 99       		.byte	0x99
 3971 0948 E6000000 		.4byte	0xe6
 3972 094c 05       		.uleb128 0x5
 3973 094d 03       		.byte	0x3
 3974 094e 00000000 		.4byte	sys_probe_state
 3975 0952 1D       		.uleb128 0x1d
 3976 0953 45020000 		.4byte	.LASF146
 3977 0957 05       		.byte	0x5
 3978 0958 9A       		.byte	0x9a
 3979 0959 E6000000 		.4byte	0xe6
 3980 095d 05       		.uleb128 0x5
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 90


 3981 095e 03       		.byte	0x3
 3982 095f 00000000 		.4byte	sys_rt_exec_state
 3983 0963 1D       		.uleb128 0x1d
 3984 0964 39060000 		.4byte	.LASF147
 3985 0968 05       		.byte	0x5
 3986 0969 9B       		.byte	0x9b
 3987 096a E6000000 		.4byte	0xe6
 3988 096e 05       		.uleb128 0x5
 3989 096f 03       		.byte	0x3
 3990 0970 00000000 		.4byte	sys_rt_exec_alarm
 3991 0974 1D       		.uleb128 0x1d
 3992 0975 27040000 		.4byte	.LASF148
 3993 0979 05       		.byte	0x5
 3994 097a 9C       		.byte	0x9c
 3995 097b E6000000 		.4byte	0xe6
 3996 097f 05       		.uleb128 0x5
 3997 0980 03       		.byte	0x3
 3998 0981 00000000 		.4byte	sys_rt_exec_motion_override
 3999 0985 1D       		.uleb128 0x1d
 4000 0986 68040000 		.4byte	.LASF149
 4001 098a 05       		.byte	0x5
 4002 098b 9D       		.byte	0x9d
 4003 098c E6000000 		.4byte	0xe6
 4004 0990 05       		.uleb128 0x5
 4005 0991 03       		.byte	0x3
 4006 0992 00000000 		.4byte	sys_rt_exec_accessory_override
 4007 0996 00       		.byte	0
 4008              		.section	.debug_abbrev,"",%progbits
 4009              	.Ldebug_abbrev0:
 4010 0000 01       		.uleb128 0x1
 4011 0001 11       		.uleb128 0x11
 4012 0002 01       		.byte	0x1
 4013 0003 25       		.uleb128 0x25
 4014 0004 0E       		.uleb128 0xe
 4015 0005 13       		.uleb128 0x13
 4016 0006 0B       		.uleb128 0xb
 4017 0007 03       		.uleb128 0x3
 4018 0008 0E       		.uleb128 0xe
 4019 0009 1B       		.uleb128 0x1b
 4020 000a 0E       		.uleb128 0xe
 4021 000b 55       		.uleb128 0x55
 4022 000c 17       		.uleb128 0x17
 4023 000d 11       		.uleb128 0x11
 4024 000e 01       		.uleb128 0x1
 4025 000f 10       		.uleb128 0x10
 4026 0010 17       		.uleb128 0x17
 4027 0011 00       		.byte	0
 4028 0012 00       		.byte	0
 4029 0013 02       		.uleb128 0x2
 4030 0014 24       		.uleb128 0x24
 4031 0015 00       		.byte	0
 4032 0016 0B       		.uleb128 0xb
 4033 0017 0B       		.uleb128 0xb
 4034 0018 3E       		.uleb128 0x3e
 4035 0019 0B       		.uleb128 0xb
 4036 001a 03       		.uleb128 0x3
 4037 001b 0E       		.uleb128 0xe
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 91


 4038 001c 00       		.byte	0
 4039 001d 00       		.byte	0
 4040 001e 03       		.uleb128 0x3
 4041 001f 16       		.uleb128 0x16
 4042 0020 00       		.byte	0
 4043 0021 03       		.uleb128 0x3
 4044 0022 0E       		.uleb128 0xe
 4045 0023 3A       		.uleb128 0x3a
 4046 0024 0B       		.uleb128 0xb
 4047 0025 3B       		.uleb128 0x3b
 4048 0026 0B       		.uleb128 0xb
 4049 0027 49       		.uleb128 0x49
 4050 0028 13       		.uleb128 0x13
 4051 0029 00       		.byte	0
 4052 002a 00       		.byte	0
 4053 002b 04       		.uleb128 0x4
 4054 002c 24       		.uleb128 0x24
 4055 002d 00       		.byte	0
 4056 002e 0B       		.uleb128 0xb
 4057 002f 0B       		.uleb128 0xb
 4058 0030 3E       		.uleb128 0x3e
 4059 0031 0B       		.uleb128 0xb
 4060 0032 03       		.uleb128 0x3
 4061 0033 08       		.uleb128 0x8
 4062 0034 00       		.byte	0
 4063 0035 00       		.byte	0
 4064 0036 05       		.uleb128 0x5
 4065 0037 35       		.uleb128 0x35
 4066 0038 00       		.byte	0
 4067 0039 49       		.uleb128 0x49
 4068 003a 13       		.uleb128 0x13
 4069 003b 00       		.byte	0
 4070 003c 00       		.byte	0
 4071 003d 06       		.uleb128 0x6
 4072 003e 13       		.uleb128 0x13
 4073 003f 01       		.byte	0x1
 4074 0040 0B       		.uleb128 0xb
 4075 0041 0B       		.uleb128 0xb
 4076 0042 3A       		.uleb128 0x3a
 4077 0043 0B       		.uleb128 0xb
 4078 0044 3B       		.uleb128 0x3b
 4079 0045 0B       		.uleb128 0xb
 4080 0046 01       		.uleb128 0x1
 4081 0047 13       		.uleb128 0x13
 4082 0048 00       		.byte	0
 4083 0049 00       		.byte	0
 4084 004a 07       		.uleb128 0x7
 4085 004b 0D       		.uleb128 0xd
 4086 004c 00       		.byte	0
 4087 004d 03       		.uleb128 0x3
 4088 004e 0E       		.uleb128 0xe
 4089 004f 3A       		.uleb128 0x3a
 4090 0050 0B       		.uleb128 0xb
 4091 0051 3B       		.uleb128 0x3b
 4092 0052 0B       		.uleb128 0xb
 4093 0053 49       		.uleb128 0x49
 4094 0054 13       		.uleb128 0x13
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 92


 4095 0055 38       		.uleb128 0x38
 4096 0056 0B       		.uleb128 0xb
 4097 0057 00       		.byte	0
 4098 0058 00       		.byte	0
 4099 0059 08       		.uleb128 0x8
 4100 005a 01       		.uleb128 0x1
 4101 005b 01       		.byte	0x1
 4102 005c 49       		.uleb128 0x49
 4103 005d 13       		.uleb128 0x13
 4104 005e 01       		.uleb128 0x1
 4105 005f 13       		.uleb128 0x13
 4106 0060 00       		.byte	0
 4107 0061 00       		.byte	0
 4108 0062 09       		.uleb128 0x9
 4109 0063 21       		.uleb128 0x21
 4110 0064 00       		.byte	0
 4111 0065 49       		.uleb128 0x49
 4112 0066 13       		.uleb128 0x13
 4113 0067 2F       		.uleb128 0x2f
 4114 0068 0B       		.uleb128 0xb
 4115 0069 00       		.byte	0
 4116 006a 00       		.byte	0
 4117 006b 0A       		.uleb128 0xa
 4118 006c 0F       		.uleb128 0xf
 4119 006d 00       		.byte	0
 4120 006e 0B       		.uleb128 0xb
 4121 006f 0B       		.uleb128 0xb
 4122 0070 49       		.uleb128 0x49
 4123 0071 13       		.uleb128 0x13
 4124 0072 00       		.byte	0
 4125 0073 00       		.byte	0
 4126 0074 0B       		.uleb128 0xb
 4127 0075 2E       		.uleb128 0x2e
 4128 0076 00       		.byte	0
 4129 0077 3F       		.uleb128 0x3f
 4130 0078 19       		.uleb128 0x19
 4131 0079 03       		.uleb128 0x3
 4132 007a 0E       		.uleb128 0xe
 4133 007b 3A       		.uleb128 0x3a
 4134 007c 0B       		.uleb128 0xb
 4135 007d 3B       		.uleb128 0x3b
 4136 007e 0B       		.uleb128 0xb
 4137 007f 11       		.uleb128 0x11
 4138 0080 01       		.uleb128 0x1
 4139 0081 12       		.uleb128 0x12
 4140 0082 06       		.uleb128 0x6
 4141 0083 40       		.uleb128 0x40
 4142 0084 18       		.uleb128 0x18
 4143 0085 9642     		.uleb128 0x2116
 4144 0087 19       		.uleb128 0x19
 4145 0088 00       		.byte	0
 4146 0089 00       		.byte	0
 4147 008a 0C       		.uleb128 0xc
 4148 008b 2E       		.uleb128 0x2e
 4149 008c 01       		.byte	0x1
 4150 008d 3F       		.uleb128 0x3f
 4151 008e 19       		.uleb128 0x19
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 93


 4152 008f 03       		.uleb128 0x3
 4153 0090 0E       		.uleb128 0xe
 4154 0091 3A       		.uleb128 0x3a
 4155 0092 0B       		.uleb128 0xb
 4156 0093 3B       		.uleb128 0x3b
 4157 0094 0B       		.uleb128 0xb
 4158 0095 11       		.uleb128 0x11
 4159 0096 01       		.uleb128 0x1
 4160 0097 12       		.uleb128 0x12
 4161 0098 06       		.uleb128 0x6
 4162 0099 40       		.uleb128 0x40
 4163 009a 18       		.uleb128 0x18
 4164 009b 9642     		.uleb128 0x2116
 4165 009d 19       		.uleb128 0x19
 4166 009e 01       		.uleb128 0x1
 4167 009f 13       		.uleb128 0x13
 4168 00a0 00       		.byte	0
 4169 00a1 00       		.byte	0
 4170 00a2 0D       		.uleb128 0xd
 4171 00a3 34       		.uleb128 0x34
 4172 00a4 00       		.byte	0
 4173 00a5 03       		.uleb128 0x3
 4174 00a6 0E       		.uleb128 0xe
 4175 00a7 3A       		.uleb128 0x3a
 4176 00a8 0B       		.uleb128 0xb
 4177 00a9 3B       		.uleb128 0x3b
 4178 00aa 0B       		.uleb128 0xb
 4179 00ab 49       		.uleb128 0x49
 4180 00ac 13       		.uleb128 0x13
 4181 00ad 02       		.uleb128 0x2
 4182 00ae 18       		.uleb128 0x18
 4183 00af 00       		.byte	0
 4184 00b0 00       		.byte	0
 4185 00b1 0E       		.uleb128 0xe
 4186 00b2 2E       		.uleb128 0x2e
 4187 00b3 00       		.byte	0
 4188 00b4 3F       		.uleb128 0x3f
 4189 00b5 19       		.uleb128 0x19
 4190 00b6 03       		.uleb128 0x3
 4191 00b7 0E       		.uleb128 0xe
 4192 00b8 3A       		.uleb128 0x3a
 4193 00b9 0B       		.uleb128 0xb
 4194 00ba 3B       		.uleb128 0x3b
 4195 00bb 05       		.uleb128 0x5
 4196 00bc 11       		.uleb128 0x11
 4197 00bd 01       		.uleb128 0x1
 4198 00be 12       		.uleb128 0x12
 4199 00bf 06       		.uleb128 0x6
 4200 00c0 40       		.uleb128 0x40
 4201 00c1 18       		.uleb128 0x18
 4202 00c2 9642     		.uleb128 0x2116
 4203 00c4 19       		.uleb128 0x19
 4204 00c5 00       		.byte	0
 4205 00c6 00       		.byte	0
 4206 00c7 0F       		.uleb128 0xf
 4207 00c8 2E       		.uleb128 0x2e
 4208 00c9 01       		.byte	0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 94


 4209 00ca 3F       		.uleb128 0x3f
 4210 00cb 19       		.uleb128 0x19
 4211 00cc 03       		.uleb128 0x3
 4212 00cd 0E       		.uleb128 0xe
 4213 00ce 3A       		.uleb128 0x3a
 4214 00cf 0B       		.uleb128 0xb
 4215 00d0 3B       		.uleb128 0x3b
 4216 00d1 05       		.uleb128 0x5
 4217 00d2 11       		.uleb128 0x11
 4218 00d3 01       		.uleb128 0x1
 4219 00d4 12       		.uleb128 0x12
 4220 00d5 06       		.uleb128 0x6
 4221 00d6 40       		.uleb128 0x40
 4222 00d7 18       		.uleb128 0x18
 4223 00d8 9642     		.uleb128 0x2116
 4224 00da 19       		.uleb128 0x19
 4225 00db 01       		.uleb128 0x1
 4226 00dc 13       		.uleb128 0x13
 4227 00dd 00       		.byte	0
 4228 00de 00       		.byte	0
 4229 00df 10       		.uleb128 0x10
 4230 00e0 34       		.uleb128 0x34
 4231 00e1 00       		.byte	0
 4232 00e2 03       		.uleb128 0x3
 4233 00e3 08       		.uleb128 0x8
 4234 00e4 3A       		.uleb128 0x3a
 4235 00e5 0B       		.uleb128 0xb
 4236 00e6 3B       		.uleb128 0x3b
 4237 00e7 05       		.uleb128 0x5
 4238 00e8 49       		.uleb128 0x49
 4239 00e9 13       		.uleb128 0x13
 4240 00ea 02       		.uleb128 0x2
 4241 00eb 18       		.uleb128 0x18
 4242 00ec 00       		.byte	0
 4243 00ed 00       		.byte	0
 4244 00ee 11       		.uleb128 0x11
 4245 00ef 2E       		.uleb128 0x2e
 4246 00f0 01       		.byte	0x1
 4247 00f1 03       		.uleb128 0x3
 4248 00f2 0E       		.uleb128 0xe
 4249 00f3 3A       		.uleb128 0x3a
 4250 00f4 0B       		.uleb128 0xb
 4251 00f5 3B       		.uleb128 0x3b
 4252 00f6 05       		.uleb128 0x5
 4253 00f7 27       		.uleb128 0x27
 4254 00f8 19       		.uleb128 0x19
 4255 00f9 49       		.uleb128 0x49
 4256 00fa 13       		.uleb128 0x13
 4257 00fb 11       		.uleb128 0x11
 4258 00fc 01       		.uleb128 0x1
 4259 00fd 12       		.uleb128 0x12
 4260 00fe 06       		.uleb128 0x6
 4261 00ff 40       		.uleb128 0x40
 4262 0100 18       		.uleb128 0x18
 4263 0101 9742     		.uleb128 0x2117
 4264 0103 19       		.uleb128 0x19
 4265 0104 01       		.uleb128 0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 95


 4266 0105 13       		.uleb128 0x13
 4267 0106 00       		.byte	0
 4268 0107 00       		.byte	0
 4269 0108 12       		.uleb128 0x12
 4270 0109 05       		.uleb128 0x5
 4271 010a 00       		.byte	0
 4272 010b 03       		.uleb128 0x3
 4273 010c 0E       		.uleb128 0xe
 4274 010d 3A       		.uleb128 0x3a
 4275 010e 0B       		.uleb128 0xb
 4276 010f 3B       		.uleb128 0x3b
 4277 0110 05       		.uleb128 0x5
 4278 0111 49       		.uleb128 0x49
 4279 0112 13       		.uleb128 0x13
 4280 0113 02       		.uleb128 0x2
 4281 0114 18       		.uleb128 0x18
 4282 0115 00       		.byte	0
 4283 0116 00       		.byte	0
 4284 0117 13       		.uleb128 0x13
 4285 0118 0B       		.uleb128 0xb
 4286 0119 01       		.byte	0x1
 4287 011a 55       		.uleb128 0x55
 4288 011b 17       		.uleb128 0x17
 4289 011c 00       		.byte	0
 4290 011d 00       		.byte	0
 4291 011e 14       		.uleb128 0x14
 4292 011f 34       		.uleb128 0x34
 4293 0120 00       		.byte	0
 4294 0121 03       		.uleb128 0x3
 4295 0122 0E       		.uleb128 0xe
 4296 0123 3A       		.uleb128 0x3a
 4297 0124 0B       		.uleb128 0xb
 4298 0125 3B       		.uleb128 0x3b
 4299 0126 05       		.uleb128 0x5
 4300 0127 49       		.uleb128 0x49
 4301 0128 13       		.uleb128 0x13
 4302 0129 02       		.uleb128 0x2
 4303 012a 18       		.uleb128 0x18
 4304 012b 00       		.byte	0
 4305 012c 00       		.byte	0
 4306 012d 15       		.uleb128 0x15
 4307 012e 0B       		.uleb128 0xb
 4308 012f 01       		.byte	0x1
 4309 0130 55       		.uleb128 0x55
 4310 0131 17       		.uleb128 0x17
 4311 0132 01       		.uleb128 0x1
 4312 0133 13       		.uleb128 0x13
 4313 0134 00       		.byte	0
 4314 0135 00       		.byte	0
 4315 0136 16       		.uleb128 0x16
 4316 0137 0B       		.uleb128 0xb
 4317 0138 01       		.byte	0x1
 4318 0139 11       		.uleb128 0x11
 4319 013a 01       		.uleb128 0x1
 4320 013b 12       		.uleb128 0x12
 4321 013c 06       		.uleb128 0x6
 4322 013d 01       		.uleb128 0x1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 96


 4323 013e 13       		.uleb128 0x13
 4324 013f 00       		.byte	0
 4325 0140 00       		.byte	0
 4326 0141 17       		.uleb128 0x17
 4327 0142 0B       		.uleb128 0xb
 4328 0143 01       		.byte	0x1
 4329 0144 11       		.uleb128 0x11
 4330 0145 01       		.uleb128 0x1
 4331 0146 12       		.uleb128 0x12
 4332 0147 06       		.uleb128 0x6
 4333 0148 00       		.byte	0
 4334 0149 00       		.byte	0
 4335 014a 18       		.uleb128 0x18
 4336 014b 2E       		.uleb128 0x2e
 4337 014c 00       		.byte	0
 4338 014d 3F       		.uleb128 0x3f
 4339 014e 19       		.uleb128 0x19
 4340 014f 03       		.uleb128 0x3
 4341 0150 0E       		.uleb128 0xe
 4342 0151 3A       		.uleb128 0x3a
 4343 0152 0B       		.uleb128 0xb
 4344 0153 3B       		.uleb128 0x3b
 4345 0154 05       		.uleb128 0x5
 4346 0155 49       		.uleb128 0x49
 4347 0156 13       		.uleb128 0x13
 4348 0157 11       		.uleb128 0x11
 4349 0158 01       		.uleb128 0x1
 4350 0159 12       		.uleb128 0x12
 4351 015a 06       		.uleb128 0x6
 4352 015b 40       		.uleb128 0x40
 4353 015c 18       		.uleb128 0x18
 4354 015d 9742     		.uleb128 0x2117
 4355 015f 19       		.uleb128 0x19
 4356 0160 00       		.byte	0
 4357 0161 00       		.byte	0
 4358 0162 19       		.uleb128 0x19
 4359 0163 34       		.uleb128 0x34
 4360 0164 00       		.byte	0
 4361 0165 03       		.uleb128 0x3
 4362 0166 08       		.uleb128 0x8
 4363 0167 3A       		.uleb128 0x3a
 4364 0168 0B       		.uleb128 0xb
 4365 0169 3B       		.uleb128 0x3b
 4366 016a 0B       		.uleb128 0xb
 4367 016b 49       		.uleb128 0x49
 4368 016c 13       		.uleb128 0x13
 4369 016d 02       		.uleb128 0x2
 4370 016e 18       		.uleb128 0x18
 4371 016f 00       		.byte	0
 4372 0170 00       		.byte	0
 4373 0171 1A       		.uleb128 0x1a
 4374 0172 34       		.uleb128 0x34
 4375 0173 00       		.byte	0
 4376 0174 03       		.uleb128 0x3
 4377 0175 0E       		.uleb128 0xe
 4378 0176 3A       		.uleb128 0x3a
 4379 0177 0B       		.uleb128 0xb
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 97


 4380 0178 3B       		.uleb128 0x3b
 4381 0179 05       		.uleb128 0x5
 4382 017a 49       		.uleb128 0x49
 4383 017b 13       		.uleb128 0x13
 4384 017c 3F       		.uleb128 0x3f
 4385 017d 19       		.uleb128 0x19
 4386 017e 3C       		.uleb128 0x3c
 4387 017f 19       		.uleb128 0x19
 4388 0180 00       		.byte	0
 4389 0181 00       		.byte	0
 4390 0182 1B       		.uleb128 0x1b
 4391 0183 34       		.uleb128 0x34
 4392 0184 00       		.byte	0
 4393 0185 03       		.uleb128 0x3
 4394 0186 0E       		.uleb128 0xe
 4395 0187 3A       		.uleb128 0x3a
 4396 0188 0B       		.uleb128 0xb
 4397 0189 3B       		.uleb128 0x3b
 4398 018a 0B       		.uleb128 0xb
 4399 018b 49       		.uleb128 0x49
 4400 018c 13       		.uleb128 0x13
 4401 018d 3F       		.uleb128 0x3f
 4402 018e 19       		.uleb128 0x19
 4403 018f 3C       		.uleb128 0x3c
 4404 0190 19       		.uleb128 0x19
 4405 0191 00       		.byte	0
 4406 0192 00       		.byte	0
 4407 0193 1C       		.uleb128 0x1c
 4408 0194 34       		.uleb128 0x34
 4409 0195 00       		.byte	0
 4410 0196 03       		.uleb128 0x3
 4411 0197 08       		.uleb128 0x8
 4412 0198 3A       		.uleb128 0x3a
 4413 0199 0B       		.uleb128 0xb
 4414 019a 3B       		.uleb128 0x3b
 4415 019b 0B       		.uleb128 0xb
 4416 019c 49       		.uleb128 0x49
 4417 019d 13       		.uleb128 0x13
 4418 019e 3F       		.uleb128 0x3f
 4419 019f 19       		.uleb128 0x19
 4420 01a0 3C       		.uleb128 0x3c
 4421 01a1 19       		.uleb128 0x19
 4422 01a2 00       		.byte	0
 4423 01a3 00       		.byte	0
 4424 01a4 1D       		.uleb128 0x1d
 4425 01a5 34       		.uleb128 0x34
 4426 01a6 00       		.byte	0
 4427 01a7 03       		.uleb128 0x3
 4428 01a8 0E       		.uleb128 0xe
 4429 01a9 3A       		.uleb128 0x3a
 4430 01aa 0B       		.uleb128 0xb
 4431 01ab 3B       		.uleb128 0x3b
 4432 01ac 0B       		.uleb128 0xb
 4433 01ad 49       		.uleb128 0x49
 4434 01ae 13       		.uleb128 0x13
 4435 01af 3F       		.uleb128 0x3f
 4436 01b0 19       		.uleb128 0x19
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 98


 4437 01b1 02       		.uleb128 0x2
 4438 01b2 18       		.uleb128 0x18
 4439 01b3 00       		.byte	0
 4440 01b4 00       		.byte	0
 4441 01b5 00       		.byte	0
 4442              		.section	.debug_aranges,"",%progbits
 4443 0000 64000000 		.4byte	0x64
 4444 0004 0200     		.2byte	0x2
 4445 0006 00000000 		.4byte	.Ldebug_info0
 4446 000a 04       		.byte	0x4
 4447 000b 00       		.byte	0
 4448 000c 0000     		.2byte	0
 4449 000e 0000     		.2byte	0
 4450 0010 00000000 		.4byte	.LFB64
 4451 0014 44000000 		.4byte	.LFE64-.LFB64
 4452 0018 00000000 		.4byte	.LFB65
 4453 001c 68000000 		.4byte	.LFE65-.LFB65
 4454 0020 00000000 		.4byte	.LFB66
 4455 0024 00030000 		.4byte	.LFE66-.LFB66
 4456 0028 00000000 		.4byte	.LFB67
 4457 002c 94000000 		.4byte	.LFE67-.LFB67
 4458 0030 00000000 		.4byte	.LFB68
 4459 0034 94000000 		.4byte	.LFE68-.LFB68
 4460 0038 00000000 		.4byte	.LFB69
 4461 003c 18000000 		.4byte	.LFE69-.LFB69
 4462 0040 00000000 		.4byte	.LFB70
 4463 0044 44000000 		.4byte	.LFE70-.LFB70
 4464 0048 00000000 		.4byte	.LFB71
 4465 004c 26000000 		.4byte	.LFE71-.LFB71
 4466 0050 00000000 		.4byte	.LFB72
 4467 0054 480D0000 		.4byte	.LFE72-.LFB72
 4468 0058 00000000 		.4byte	.LFB73
 4469 005c 2C000000 		.4byte	.LFE73-.LFB73
 4470 0060 00000000 		.4byte	0
 4471 0064 00000000 		.4byte	0
 4472              		.section	.debug_ranges,"",%progbits
 4473              	.Ldebug_ranges0:
 4474 0000 1A000000 		.4byte	.LBB2
 4475 0004 100D0000 		.4byte	.LBE2
 4476 0008 260D0000 		.4byte	.LBB9
 4477 000c 280D0000 		.4byte	.LBE9
 4478 0010 00000000 		.4byte	0
 4479 0014 00000000 		.4byte	0
 4480 0018 24000000 		.4byte	.LBB3
 4481 001c 96050000 		.4byte	.LBE3
 4482 0020 260D0000 		.4byte	.LBB8
 4483 0024 280D0000 		.4byte	.LBE8
 4484 0028 00000000 		.4byte	0
 4485 002c 00000000 		.4byte	0
 4486 0030 00000000 		.4byte	.LFB64
 4487 0034 44000000 		.4byte	.LFE64
 4488 0038 00000000 		.4byte	.LFB65
 4489 003c 68000000 		.4byte	.LFE65
 4490 0040 00000000 		.4byte	.LFB66
 4491 0044 00030000 		.4byte	.LFE66
 4492 0048 00000000 		.4byte	.LFB67
 4493 004c 94000000 		.4byte	.LFE67
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 99


 4494 0050 00000000 		.4byte	.LFB68
 4495 0054 94000000 		.4byte	.LFE68
 4496 0058 00000000 		.4byte	.LFB69
 4497 005c 18000000 		.4byte	.LFE69
 4498 0060 00000000 		.4byte	.LFB70
 4499 0064 44000000 		.4byte	.LFE70
 4500 0068 00000000 		.4byte	.LFB71
 4501 006c 26000000 		.4byte	.LFE71
 4502 0070 00000000 		.4byte	.LFB72
 4503 0074 480D0000 		.4byte	.LFE72
 4504 0078 00000000 		.4byte	.LFB73
 4505 007c 2C000000 		.4byte	.LFE73
 4506 0080 00000000 		.4byte	0
 4507 0084 00000000 		.4byte	0
 4508              		.section	.debug_line,"",%progbits
 4509              	.Ldebug_line0:
 4510 0000 29040000 		.section	.debug_str,"MS",%progbits,1
 4510      02006901 
 4510      00000201 
 4510      FB0E0D00 
 4510      01010101 
 4511              	.LASF2:
 4512 0000 73686F72 		.ascii	"short int\000"
 4512      7420696E 
 4512      7400
 4513              	.LASF61:
 4514 000a 656E7472 		.ascii	"entry_speed_sqr\000"
 4514      795F7370 
 4514      6565645F 
 4514      73717200 
 4515              	.LASF62:
 4516 001a 6D61785F 		.ascii	"max_entry_speed_sqr\000"
 4516      656E7472 
 4516      795F7370 
 4516      6565645F 
 4516      73717200 
 4517              	.LASF138:
 4518 002e 706C5F62 		.ascii	"pl_block\000"
 4518      6C6F636B 
 4518      00
 4519              	.LASF3:
 4520 0037 5F5F7569 		.ascii	"__uint8_t\000"
 4520      6E74385F 
 4520      7400
 4521              	.LASF69:
 4522 0041 73745F62 		.ascii	"st_block_t\000"
 4522      6C6F636B 
 4522      5F7400
 4523              	.LASF82:
 4524 004c 6469725F 		.ascii	"dir_outbits\000"
 4524      6F757462 
 4524      69747300 
 4525              	.LASF150:
 4526 0058 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 4526      43313120 
 4526      352E342E 
 4526      31203230 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 100


 4526      31363036 
 4527 008b 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 4527      20726576 
 4527      6973696F 
 4527      6E203233 
 4527      37373135 
 4528 00be 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 4528      66756E63 
 4528      74696F6E 
 4528      2D736563 
 4528      74696F6E 
 4529              	.LASF155:
 4530 00e6 73745F67 		.ascii	"st_get_realtime_rate\000"
 4530      65745F72 
 4530      65616C74 
 4530      696D655F 
 4530      72617465 
 4531              	.LASF11:
 4532 00fb 6C6F6E67 		.ascii	"long long unsigned int\000"
 4532      206C6F6E 
 4532      6720756E 
 4532      7369676E 
 4532      65642069 
 4533              	.LASF153:
 4534 0112 73745F6E 		.ascii	"st_next_block_index\000"
 4534      6578745F 
 4534      626C6F63 
 4534      6B5F696E 
 4534      64657800 
 4535              	.LASF39:
 4536 0126 686F6D69 		.ascii	"homing_debounce_delay\000"
 4536      6E675F64 
 4536      65626F75 
 4536      6E63655F 
 4536      64656C61 
 4537              	.LASF141:
 4538 013c 49544D5F 		.ascii	"ITM_RxBuffer\000"
 4538      52784275 
 4538      66666572 
 4538      00
 4539              	.LASF131:
 4540 0149 7365676D 		.ascii	"segment_buffer\000"
 4540      656E745F 
 4540      62756666 
 4540      657200
 4541              	.LASF31:
 4542 0158 6A756E63 		.ascii	"junction_deviation\000"
 4542      74696F6E 
 4542      5F646576 
 4542      69617469 
 4542      6F6E00
 4543              	.LASF105:
 4544 016b 73746570 		.ascii	"stepper_timer_isr\000"
 4544      7065725F 
 4544      74696D65 
 4544      725F6973 
 4544      7200
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 101


 4545              	.LASF10:
 4546 017d 6C6F6E67 		.ascii	"long long int\000"
 4546      206C6F6E 
 4546      6720696E 
 4546      7400
 4547              	.LASF0:
 4548 018b 7369676E 		.ascii	"signed char\000"
 4548      65642063 
 4548      68617200 
 4549              	.LASF29:
 4550 0197 73746570 		.ascii	"stepper_idle_lock_time\000"
 4550      7065725F 
 4550      69646C65 
 4550      5F6C6F63 
 4550      6B5F7469 
 4551              	.LASF119:
 4552 01ae 6D696E69 		.ascii	"minimum_mm\000"
 4552      6D756D5F 
 4552      6D6D00
 4553              	.LASF81:
 4554 01b9 73746570 		.ascii	"step_outbits\000"
 4554      5F6F7574 
 4554      62697473 
 4554      00
 4555              	.LASF102:
 4556 01c6 73745F70 		.ascii	"st_prep_t\000"
 4556      7265705F 
 4556      7400
 4557              	.LASF137:
 4558 01d0 62757379 		.ascii	"busy\000"
 4558      00
 4559              	.LASF30:
 4560 01d5 73746174 		.ascii	"status_report_mask\000"
 4560      75735F72 
 4560      65706F72 
 4560      745F6D61 
 4560      736B00
 4561              	.LASF110:
 4562 01e8 73746570 		.ascii	"stepper_init\000"
 4562      7065725F 
 4562      696E6974 
 4562      00
 4563              	.LASF33:
 4564 01f5 72706D5F 		.ascii	"rpm_max\000"
 4564      6D617800 
 4565              	.LASF42:
 4566 01fd 73746174 		.ascii	"state\000"
 4566      6500
 4567              	.LASF7:
 4568 0203 6C6F6E67 		.ascii	"long int\000"
 4568      20696E74 
 4568      00
 4569              	.LASF95:
 4570 020c 63757272 		.ascii	"current_speed\000"
 4570      656E745F 
 4570      73706565 
 4570      6400
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 102


 4571              	.LASF34:
 4572 021a 72706D5F 		.ascii	"rpm_min\000"
 4572      6D696E00 
 4573              	.LASF101:
 4574 0222 63757272 		.ascii	"current_spindle_pwm\000"
 4574      656E745F 
 4574      7370696E 
 4574      646C655F 
 4574      70776D00 
 4575              	.LASF40:
 4576 0236 686F6D69 		.ascii	"homing_pulloff\000"
 4576      6E675F70 
 4576      756C6C6F 
 4576      666600
 4577              	.LASF146:
 4578 0245 7379735F 		.ascii	"sys_rt_exec_state\000"
 4578      72745F65 
 4578      7865635F 
 4578      73746174 
 4578      6500
 4579              	.LASF54:
 4580 0257 7265706F 		.ascii	"report_wco_counter\000"
 4580      72745F77 
 4580      636F5F63 
 4580      6F756E74 
 4580      657200
 4581              	.LASF127:
 4582 026a 6E6F6D69 		.ascii	"nominal_speed\000"
 4582      6E616C5F 
 4582      73706565 
 4582      6400
 4583              	.LASF117:
 4584 0278 73706565 		.ascii	"speed_var\000"
 4584      645F7661 
 4584      7200
 4585              	.LASF4:
 4586 0282 5F5F7569 		.ascii	"__uint16_t\000"
 4586      6E743136 
 4586      5F7400
 4587              	.LASF86:
 4588 028d 65786563 		.ascii	"exec_segment\000"
 4588      5F736567 
 4588      6D656E74 
 4588      00
 4589              	.LASF83:
 4590 029a 73746570 		.ascii	"step_count\000"
 4590      5F636F75 
 4590      6E7400
 4591              	.LASF37:
 4592 02a5 686F6D69 		.ascii	"homing_feed_rate\000"
 4592      6E675F66 
 4592      6565645F 
 4592      72617465 
 4592      00
 4593              	.LASF8:
 4594 02b6 5F5F7569 		.ascii	"__uint32_t\000"
 4594      6E743332 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 103


 4594      5F7400
 4595              	.LASF135:
 4596 02c1 73746570 		.ascii	"step_port_invert_mask\000"
 4596      5F706F72 
 4596      745F696E 
 4596      76657274 
 4596      5F6D6173 
 4597              	.LASF139:
 4598 02d7 73745F70 		.ascii	"st_prep_block\000"
 4598      7265705F 
 4598      626C6F63 
 4598      6B00
 4599              	.LASF46:
 4600 02e5 73746570 		.ascii	"step_control\000"
 4600      5F636F6E 
 4600      74726F6C 
 4600      00
 4601              	.LASF144:
 4602 02f2 7379735F 		.ascii	"sys_probe_position\000"
 4602      70726F62 
 4602      655F706F 
 4602      73697469 
 4602      6F6E00
 4603              	.LASF49:
 4604 0305 665F6F76 		.ascii	"f_override\000"
 4604      65727269 
 4604      646500
 4605              	.LASF115:
 4606 0310 74696D65 		.ascii	"time_var\000"
 4606      5F766172 
 4606      00
 4607              	.LASF88:
 4608 0319 72656361 		.ascii	"recalculate_flag\000"
 4608      6C63756C 
 4608      6174655F 
 4608      666C6167 
 4608      00
 4609              	.LASF73:
 4610 032a 616D6173 		.ascii	"amass_level\000"
 4610      735F6C65 
 4610      76656C00 
 4611              	.LASF113:
 4612 0336 70726570 		.ascii	"prep_segment\000"
 4612      5F736567 
 4612      6D656E74 
 4612      00
 4613              	.LASF100:
 4614 0343 696E765F 		.ascii	"inv_rate\000"
 4614      72617465 
 4614      00
 4615              	.LASF12:
 4616 034c 756E7369 		.ascii	"unsigned int\000"
 4616      676E6564 
 4616      20696E74 
 4616      00
 4617              	.LASF14:
 4618 0359 75696E74 		.ascii	"uint16_t\000"
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 104


 4618      31365F74 
 4618      00
 4619              	.LASF9:
 4620 0362 6C6F6E67 		.ascii	"long unsigned int\000"
 4620      20756E73 
 4620      69676E65 
 4620      6420696E 
 4620      7400
 4621              	.LASF112:
 4622 0374 73745F70 		.ascii	"st_prep_buffer\000"
 4622      7265705F 
 4622      62756666 
 4622      657200
 4623              	.LASF116:
 4624 0383 6D6D5F76 		.ascii	"mm_var\000"
 4624      617200
 4625              	.LASF66:
 4626 038a 70726F67 		.ascii	"programmed_rate\000"
 4626      72616D6D 
 4626      65645F72 
 4626      61746500 
 4627              	.LASF70:
 4628 039a 6E5F7374 		.ascii	"n_step\000"
 4628      657000
 4629              	.LASF154:
 4630 03a1 626C6F63 		.ascii	"block_index\000"
 4630      6B5F696E 
 4630      64657800 
 4631              	.LASF84:
 4632 03ad 65786563 		.ascii	"exec_block_index\000"
 4632      5F626C6F 
 4632      636B5F69 
 4632      6E646578 
 4632      00
 4633              	.LASF64:
 4634 03be 6D61785F 		.ascii	"max_junction_speed_sqr\000"
 4634      6A756E63 
 4634      74696F6E 
 4634      5F737065 
 4634      65645F73 
 4635              	.LASF114:
 4636 03d5 64745F6D 		.ascii	"dt_max\000"
 4636      617800
 4637              	.LASF90:
 4638 03dc 73746570 		.ascii	"steps_remaining\000"
 4638      735F7265 
 4638      6D61696E 
 4638      696E6700 
 4639              	.LASF79:
 4640 03ec 65786563 		.ascii	"execute_step\000"
 4640      7574655F 
 4640      73746570 
 4640      00
 4641              	.LASF85:
 4642 03f9 65786563 		.ascii	"exec_block\000"
 4642      5F626C6F 
 4642      636B00
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 105


 4643              	.LASF72:
 4644 0404 73745F62 		.ascii	"st_block_index\000"
 4644      6C6F636B 
 4644      5F696E64 
 4644      657800
 4645              	.LASF132:
 4646 0413 7365676D 		.ascii	"segment_buffer_tail\000"
 4646      656E745F 
 4646      62756666 
 4646      65725F74 
 4646      61696C00 
 4647              	.LASF148:
 4648 0427 7379735F 		.ascii	"sys_rt_exec_motion_override\000"
 4648      72745F65 
 4648      7865635F 
 4648      6D6F7469 
 4648      6F6E5F6F 
 4649              	.LASF151:
 4650 0443 73746570 		.ascii	"stepper.c\000"
 4650      7065722E 
 4650      6300
 4651              	.LASF28:
 4652 044d 6469725F 		.ascii	"dir_invert_mask\000"
 4652      696E7665 
 4652      72745F6D 
 4652      61736B00 
 4653              	.LASF41:
 4654 045d 73657474 		.ascii	"settings_t\000"
 4654      696E6773 
 4654      5F7400
 4655              	.LASF149:
 4656 0468 7379735F 		.ascii	"sys_rt_exec_accessory_override\000"
 4656      72745F65 
 4656      7865635F 
 4656      61636365 
 4656      73736F72 
 4657              	.LASF78:
 4658 0487 636F756E 		.ascii	"counter_z\000"
 4658      7465725F 
 4658      7A00
 4659              	.LASF94:
 4660 0491 6D6D5F63 		.ascii	"mm_complete\000"
 4660      6F6D706C 
 4660      65746500 
 4661              	.LASF130:
 4662 049d 73745F62 		.ascii	"st_block_buffer\000"
 4662      6C6F636B 
 4662      5F627566 
 4662      66657200 
 4663              	.LASF67:
 4664 04ad 706C616E 		.ascii	"plan_block_t\000"
 4664      5F626C6F 
 4664      636B5F74 
 4664      00
 4665              	.LASF21:
 4666 04ba 73697A65 		.ascii	"sizetype\000"
 4666      74797065 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 106


 4666      00
 4667              	.LASF20:
 4668 04c3 6C6F6E67 		.ascii	"long double\000"
 4668      20646F75 
 4668      626C6500 
 4669              	.LASF50:
 4670 04cf 725F6F76 		.ascii	"r_override\000"
 4670      65727269 
 4670      646500
 4671              	.LASF125:
 4672 04da 64656365 		.ascii	"decel_dist\000"
 4672      6C5F6469 
 4672      737400
 4673              	.LASF106:
 4674 04e5 73745F67 		.ascii	"st_go_idle\000"
 4674      6F5F6964 
 4674      6C6500
 4675              	.LASF36:
 4676 04f0 686F6D69 		.ascii	"homing_dir_mask\000"
 4676      6E675F64 
 4676      69725F6D 
 4676      61736B00 
 4677              	.LASF126:
 4678 0500 65786974 		.ascii	"exit_speed_sqr\000"
 4678      5F737065 
 4678      65645F73 
 4678      717200
 4679              	.LASF124:
 4680 050f 696E765F 		.ascii	"inv_2_accel\000"
 4680      325F6163 
 4680      63656C00 
 4681              	.LASF152:
 4682 051b 433A5C55 		.ascii	"C:\\Users\\barto\\Dropbox\\PSoC\\Grbl_USB_Native\\G"
 4682      73657273 
 4682      5C626172 
 4682      746F5C44 
 4682      726F7062 
 4683 0548 72626C5F 		.ascii	"rbl_USB_Native.cydsn\000"
 4683      5553425F 
 4683      4E617469 
 4683      76652E63 
 4683      7964736E 
 4684              	.LASF143:
 4685 055d 7379735F 		.ascii	"sys_position\000"
 4685      706F7369 
 4685      74696F6E 
 4685      00
 4686              	.LASF76:
 4687 056a 636F756E 		.ascii	"counter_x\000"
 4687      7465725F 
 4687      7800
 4688              	.LASF77:
 4689 0574 636F756E 		.ascii	"counter_y\000"
 4689      7465725F 
 4689      7900
 4690              	.LASF142:
 4691 057e 73657474 		.ascii	"settings\000"
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 107


 4691      696E6773 
 4691      00
 4692              	.LASF68:
 4693 0587 69735F70 		.ascii	"is_pwm_rate_adjusted\000"
 4693      776D5F72 
 4693      6174655F 
 4693      61646A75 
 4693      73746564 
 4694              	.LASF26:
 4695 059c 70756C73 		.ascii	"pulse_microseconds\000"
 4695      655F6D69 
 4695      63726F73 
 4695      65636F6E 
 4695      647300
 4696              	.LASF99:
 4697 05af 64656365 		.ascii	"decelerate_after\000"
 4697      6C657261 
 4697      74655F61 
 4697      66746572 
 4697      00
 4698              	.LASF17:
 4699 05c0 666C6F61 		.ascii	"float\000"
 4699      7400
 4700              	.LASF74:
 4701 05c6 7370696E 		.ascii	"spindle_pwm\000"
 4701      646C655F 
 4701      70776D00 
 4702              	.LASF108:
 4703 05d2 70696E5F 		.ascii	"pin_state\000"
 4703      73746174 
 4703      6500
 4704              	.LASF56:
 4705 05dc 73797374 		.ascii	"system_t\000"
 4705      656D5F74 
 4705      00
 4706              	.LASF129:
 4707 05e5 696E7465 		.ascii	"intersect_distance\000"
 4707      72736563 
 4707      745F6469 
 4707      7374616E 
 4707      636500
 4708              	.LASF103:
 4709 05f8 5F426F6F 		.ascii	"_Bool\000"
 4709      6C00
 4710              	.LASF15:
 4711 05fe 696E7433 		.ascii	"int32_t\000"
 4711      325F7400 
 4712              	.LASF1:
 4713 0606 756E7369 		.ascii	"unsigned char\000"
 4713      676E6564 
 4713      20636861 
 4713      7200
 4714              	.LASF93:
 4715 0614 72616D70 		.ascii	"ramp_type\000"
 4715      5F747970 
 4715      6500
 4716              	.LASF23:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 108


 4717 061e 6D61785F 		.ascii	"max_rate\000"
 4717      72617465 
 4717      00
 4718              	.LASF134:
 4719 0627 7365676D 		.ascii	"segment_next_head\000"
 4719      656E745F 
 4719      6E657874 
 4719      5F686561 
 4719      6400
 4720              	.LASF147:
 4721 0639 7379735F 		.ascii	"sys_rt_exec_alarm\000"
 4721      72745F65 
 4721      7865635F 
 4721      616C6172 
 4721      6D00
 4722              	.LASF38:
 4723 064b 686F6D69 		.ascii	"homing_seek_rate\000"
 4723      6E675F73 
 4723      65656B5F 
 4723      72617465 
 4723      00
 4724              	.LASF75:
 4725 065c 7365676D 		.ascii	"segment_t\000"
 4725      656E745F 
 4725      7400
 4726              	.LASF123:
 4727 0666 6379636C 		.ascii	"cycles\000"
 4727      657300
 4728              	.LASF45:
 4729 066d 736F6674 		.ascii	"soft_limit\000"
 4729      5F6C696D 
 4729      697400
 4730              	.LASF48:
 4731 0678 686F6D69 		.ascii	"homing_axis_lock\000"
 4731      6E675F61 
 4731      7869735F 
 4731      6C6F636B 
 4731      00
 4732              	.LASF60:
 4733 0689 636F6E64 		.ascii	"condition\000"
 4733      6974696F 
 4733      6E00
 4734              	.LASF92:
 4735 0693 7265715F 		.ascii	"req_mm_increment\000"
 4735      6D6D5F69 
 4735      6E637265 
 4735      6D656E74 
 4735      00
 4736              	.LASF51:
 4737 06a4 7370696E 		.ascii	"spindle_speed_ovr\000"
 4737      646C655F 
 4737      73706565 
 4737      645F6F76 
 4737      7200
 4738              	.LASF16:
 4739 06b6 75696E74 		.ascii	"uint32_t\000"
 4739      33325F74 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 109


 4739      00
 4740              	.LASF91:
 4741 06bf 73746570 		.ascii	"step_per_mm\000"
 4741      5F706572 
 4741      5F6D6D00 
 4742              	.LASF122:
 4743 06cb 6C617374 		.ascii	"last_n_steps_remaining\000"
 4743      5F6E5F73 
 4743      74657073 
 4743      5F72656D 
 4743      61696E69 
 4744              	.LASF19:
 4745 06e2 63686172 		.ascii	"char\000"
 4745      00
 4746              	.LASF89:
 4747 06e7 64745F72 		.ascii	"dt_remainder\000"
 4747      656D6169 
 4747      6E646572 
 4747      00
 4748              	.LASF6:
 4749 06f4 5F5F696E 		.ascii	"__int32_t\000"
 4749      7433325F 
 4749      7400
 4750              	.LASF25:
 4751 06fe 6D61785F 		.ascii	"max_travel\000"
 4751      74726176 
 4751      656C00
 4752              	.LASF59:
 4753 0709 64697265 		.ascii	"direction_bits\000"
 4753      6374696F 
 4753      6E5F6269 
 4753      747300
 4754              	.LASF98:
 4755 0718 61636365 		.ascii	"accelerate_until\000"
 4755      6C657261 
 4755      74655F75 
 4755      6E74696C 
 4755      00
 4756              	.LASF43:
 4757 0729 61626F72 		.ascii	"abort\000"
 4757      7400
 4758              	.LASF145:
 4759 072f 7379735F 		.ascii	"sys_probe_state\000"
 4759      70726F62 
 4759      655F7374 
 4759      61746500 
 4760              	.LASF111:
 4761 073f 73745F75 		.ascii	"st_update_plan_block_parameters\000"
 4761      70646174 
 4761      655F706C 
 4761      616E5F62 
 4761      6C6F636B 
 4762              	.LASF47:
 4763 075f 70726F62 		.ascii	"probe_succeeded\000"
 4763      655F7375 
 4763      63636565 
 4763      64656400 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 110


 4764              	.LASF71:
 4765 076f 6379636C 		.ascii	"cycles_per_tick\000"
 4765      65735F70 
 4765      65725F74 
 4765      69636B00 
 4766              	.LASF80:
 4767 077f 73746570 		.ascii	"step_pulse_time\000"
 4767      5F70756C 
 4767      73655F74 
 4767      696D6500 
 4768              	.LASF5:
 4769 078f 73686F72 		.ascii	"short unsigned int\000"
 4769      7420756E 
 4769      7369676E 
 4769      65642069 
 4769      6E7400
 4770              	.LASF96:
 4771 07a2 6D617869 		.ascii	"maximum_speed\000"
 4771      6D756D5F 
 4771      73706565 
 4771      6400
 4772              	.LASF140:
 4773 07b0 70726570 		.ascii	"prep\000"
 4773      00
 4774              	.LASF63:
 4775 07b5 6D696C6C 		.ascii	"millimeters\000"
 4775      696D6574 
 4775      65727300 
 4776              	.LASF52:
 4777 07c1 7370696E 		.ascii	"spindle_stop_ovr\000"
 4777      646C655F 
 4777      73746F70 
 4777      5F6F7672 
 4777      00
 4778              	.LASF97:
 4779 07d2 65786974 		.ascii	"exit_speed\000"
 4779      5F737065 
 4779      656400
 4780              	.LASF121:
 4781 07dd 6E5F7374 		.ascii	"n_steps_remaining\000"
 4781      6570735F 
 4781      72656D61 
 4781      696E696E 
 4781      6700
 4782              	.LASF27:
 4783 07ef 73746570 		.ascii	"step_invert_mask\000"
 4783      5F696E76 
 4783      6572745F 
 4783      6D61736B 
 4783      00
 4784              	.LASF13:
 4785 0800 75696E74 		.ascii	"uint8_t\000"
 4785      385F7400 
 4786              	.LASF136:
 4787 0808 6469725F 		.ascii	"dir_port_invert_mask\000"
 4787      706F7274 
 4787      5F696E76 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 111


 4787      6572745F 
 4787      6D61736B 
 4788              	.LASF32:
 4789 081d 6172635F 		.ascii	"arc_tolerance\000"
 4789      746F6C65 
 4789      72616E63 
 4789      6500
 4790              	.LASF35:
 4791 082b 666C6167 		.ascii	"flags\000"
 4791      7300
 4792              	.LASF120:
 4793 0831 73746570 		.ascii	"step_dist_remaining\000"
 4793      5F646973 
 4793      745F7265 
 4793      6D61696E 
 4793      696E6700 
 4794              	.LASF107:
 4795 0845 73745F67 		.ascii	"st_generate_step_dir_invert_masks\000"
 4795      656E6572 
 4795      6174655F 
 4795      73746570 
 4795      5F646972 
 4796              	.LASF44:
 4797 0867 73757370 		.ascii	"suspend\000"
 4797      656E6400 
 4798              	.LASF87:
 4799 086f 73746570 		.ascii	"stepper_t\000"
 4799      7065725F 
 4799      7400
 4800              	.LASF109:
 4801 0879 73745F72 		.ascii	"st_reset\000"
 4801      65736574 
 4801      00
 4802              	.LASF104:
 4803 0882 73745F77 		.ascii	"st_wake_up\000"
 4803      616B655F 
 4803      757000
 4804              	.LASF22:
 4805 088d 73746570 		.ascii	"steps_per_mm\000"
 4805      735F7065 
 4805      725F6D6D 
 4805      00
 4806              	.LASF58:
 4807 089a 73746570 		.ascii	"step_event_count\000"
 4807      5F657665 
 4807      6E745F63 
 4807      6F756E74 
 4807      00
 4808              	.LASF53:
 4809 08ab 7265706F 		.ascii	"report_ovr_counter\000"
 4809      72745F6F 
 4809      76725F63 
 4809      6F756E74 
 4809      657200
 4810              	.LASF55:
 4811 08be 7370696E 		.ascii	"spindle_speed\000"
 4811      646C655F 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccVAGGoa.s 			page 112


 4811      73706565 
 4811      6400
 4812              	.LASF118:
 4813 08cc 6D6D5F72 		.ascii	"mm_remaining\000"
 4813      656D6169 
 4813      6E696E67 
 4813      00
 4814              	.LASF57:
 4815 08d9 73746570 		.ascii	"steps\000"
 4815      7300
 4816              	.LASF133:
 4817 08df 7365676D 		.ascii	"segment_buffer_head\000"
 4817      656E745F 
 4817      62756666 
 4817      65725F68 
 4817      65616400 
 4818              	.LASF65:
 4819 08f3 72617069 		.ascii	"rapid_rate\000"
 4819      645F7261 
 4819      746500
 4820              	.LASF24:
 4821 08fe 61636365 		.ascii	"acceleration\000"
 4821      6C657261 
 4821      74696F6E 
 4821      00
 4822              	.LASF18:
 4823 090b 646F7562 		.ascii	"double\000"
 4823      6C6500
 4824              	.LASF128:
 4825 0912 6E6F6D69 		.ascii	"nominal_speed_sqr\000"
 4825      6E616C5F 
 4825      73706565 
 4825      645F7371 
 4825      7200
 4826              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
