ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"gcode.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	sys_position,12,4
  20              		.comm	sys_probe_position,12,4
  21              		.comm	sys_probe_state,1,1
  22              		.comm	sys_rt_exec_state,1,1
  23              		.comm	sys_rt_exec_alarm,1,1
  24              		.comm	sys_rt_exec_motion_override,1,1
  25              		.comm	sys_rt_exec_accessory_override,1,1
  26              		.comm	gc_state,68,4
  27              		.comm	gc_block,64,4
  28              		.section	.text.gc_init,"ax",%progbits
  29              		.align	2
  30              		.global	gc_init
  31              		.thumb
  32              		.thumb_func
  33              		.type	gc_init, %function
  34              	gc_init:
  35              	.LFB64:
  36              		.file 1 "gcode.c"
   1:gcode.c       **** /*
   2:gcode.c       ****   gcode.c - rs274/ngc parser.
   3:gcode.c       ****   Part of Grbl
   4:gcode.c       **** 
   5:gcode.c       ****   Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
   6:gcode.c       ****   Copyright (c) 2009-2011 Simen Svale Skogsrud
   7:gcode.c       ****       Updated For PSoC 2017-2018 Barton Dring buildlog.net
   8:gcode.c       **** 
   9:gcode.c       ****   Grbl is free software: you can redistribute it and/or modify
  10:gcode.c       ****   it under the terms of the GNU General Public License as published by
  11:gcode.c       ****   the Free Software Foundation, either version 3 of the License, or
  12:gcode.c       ****   (at your option) any later version.
  13:gcode.c       **** 
  14:gcode.c       ****   Grbl is distributed in the hope that it will be useful,
  15:gcode.c       ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:gcode.c       ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:gcode.c       ****   GNU General Public License for more details.
  18:gcode.c       **** 
  19:gcode.c       ****   You should have received a copy of the GNU General Public License
  20:gcode.c       ****   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  21:gcode.c       **** */
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 2


  22:gcode.c       **** 
  23:gcode.c       **** #include "grbl.h"
  24:gcode.c       **** 
  25:gcode.c       **** // NOTE: Max line number is defined by the g-code standard to be 99999. It seems to be an
  26:gcode.c       **** // arbitrary value, and some GUIs may require more. So we increased it based on a max safe
  27:gcode.c       **** // value when converting a float (7.2 digit precision)s to an integer.
  28:gcode.c       **** #define MAX_LINE_NUMBER 10000000
  29:gcode.c       **** #define MAX_TOOL_NUMBER 255 // Limited by max unsigned 8-bit value
  30:gcode.c       **** 
  31:gcode.c       **** #define AXIS_COMMAND_NONE 0
  32:gcode.c       **** #define AXIS_COMMAND_NON_MODAL 1
  33:gcode.c       **** #define AXIS_COMMAND_MOTION_MODE 2
  34:gcode.c       **** #define AXIS_COMMAND_TOOL_LENGTH_OFFSET 3 // *Undefined but required
  35:gcode.c       **** 
  36:gcode.c       **** // Declare gc extern struct
  37:gcode.c       **** parser_state_t gc_state;
  38:gcode.c       **** parser_block_t gc_block;
  39:gcode.c       **** 
  40:gcode.c       **** #define FAIL(status) return(status);
  41:gcode.c       **** 
  42:gcode.c       **** 
  43:gcode.c       **** void gc_init()
  44:gcode.c       **** {
  37              		.loc 1 44 0
  38              		.cfi_startproc
  39              		@ args = 0, pretend = 0, frame = 0
  40              		@ frame_needed = 1, uses_anonymous_args = 0
  41 0000 80B5     		push	{r7, lr}
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 7, -8
  44              		.cfi_offset 14, -4
  45 0002 00AF     		add	r7, sp, #0
  46              		.cfi_def_cfa_register 7
  45:gcode.c       ****   memset(&gc_state, 0, sizeof(parser_state_t));
  47              		.loc 1 45 0
  48 0004 4422     		movs	r2, #68
  49 0006 0021     		movs	r1, #0
  50 0008 0848     		ldr	r0, .L4
  51 000a FFF7FEFF 		bl	memset
  46:gcode.c       **** 
  47:gcode.c       ****   // Load default G54 coordinate system.
  48:gcode.c       ****   if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
  52              		.loc 1 48 0
  53 000e 074B     		ldr	r3, .L4
  54 0010 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
  55 0012 0749     		ldr	r1, .L4+4
  56 0014 1846     		mov	r0, r3
  57 0016 FFF7FEFF 		bl	settings_read_coord_data
  58 001a 0346     		mov	r3, r0
  59 001c 002B     		cmp	r3, #0
  60 001e 02D1     		bne	.L3
  49:gcode.c       ****     report_status_message(STATUS_SETTING_READ_FAIL);
  61              		.loc 1 49 0
  62 0020 0720     		movs	r0, #7
  63 0022 FFF7FEFF 		bl	report_status_message
  64              	.L3:
  50:gcode.c       ****   }
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 3


  51:gcode.c       **** }
  65              		.loc 1 51 0
  66 0026 00BF     		nop
  67 0028 80BD     		pop	{r7, pc}
  68              	.L5:
  69 002a 00BF     		.align	2
  70              	.L4:
  71 002c 00000000 		.word	gc_state
  72 0030 28000000 		.word	gc_state+40
  73              		.cfi_endproc
  74              	.LFE64:
  75              		.size	gc_init, .-gc_init
  76              		.section	.text.gc_sync_position,"ax",%progbits
  77              		.align	2
  78              		.global	gc_sync_position
  79              		.thumb
  80              		.thumb_func
  81              		.type	gc_sync_position, %function
  82              	gc_sync_position:
  83              	.LFB65:
  52:gcode.c       **** 
  53:gcode.c       **** 
  54:gcode.c       **** // Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
  55:gcode.c       **** // limit pull-off routines.
  56:gcode.c       **** void gc_sync_position()
  57:gcode.c       **** {
  84              		.loc 1 57 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 1, uses_anonymous_args = 0
  88 0000 80B5     		push	{r7, lr}
  89              		.cfi_def_cfa_offset 8
  90              		.cfi_offset 7, -8
  91              		.cfi_offset 14, -4
  92 0002 00AF     		add	r7, sp, #0
  93              		.cfi_def_cfa_register 7
  58:gcode.c       ****   system_convert_array_steps_to_mpos(gc_state.position,sys_position);
  94              		.loc 1 58 0
  95 0004 0249     		ldr	r1, .L7
  96 0006 0348     		ldr	r0, .L7+4
  97 0008 FFF7FEFF 		bl	system_convert_array_steps_to_mpos
  59:gcode.c       **** }
  98              		.loc 1 59 0
  99 000c 00BF     		nop
 100 000e 80BD     		pop	{r7, pc}
 101              	.L8:
 102              		.align	2
 103              	.L7:
 104 0010 00000000 		.word	sys_position
 105 0014 1C000000 		.word	gc_state+28
 106              		.cfi_endproc
 107              	.LFE65:
 108              		.size	gc_sync_position, .-gc_sync_position
 109              		.global	__aeabi_f2d
 110              		.global	__aeabi_d2uiz
 111              		.global	__aeabi_i2f
 112              		.global	__aeabi_fsub
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 4


 113              		.global	__aeabi_fmul
 114              		.global	__aeabi_d2iz
 115              		.global	__aeabi_fcmpgt
 116              		.global	__aeabi_fcmplt
 117              		.global	__aeabi_dmul
 118              		.global	__aeabi_d2f
 119              		.global	__aeabi_fadd
 120              		.global	__aeabi_fcmpeq
 121              		.global	__aeabi_dsub
 122              		.global	__aeabi_ddiv
 123              		.global	__aeabi_dcmpgt
 124              		.section	.text.gc_execute_line,"ax",%progbits
 125              		.align	2
 126              		.global	gc_execute_line
 127              		.thumb
 128              		.thumb_func
 129              		.type	gc_execute_line, %function
 130              	gc_execute_line:
 131              	.LFB66:
  60:gcode.c       **** 
  61:gcode.c       **** 
  62:gcode.c       **** // Executes one line of 0-terminated G-Code. The line is assumed to contain only uppercase
  63:gcode.c       **** // characters and signed floating point values (no whitespace). Comments and block delete
  64:gcode.c       **** // characters have been removed. In this function, all units and positions are converted and
  65:gcode.c       **** // exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
  66:gcode.c       **** // coordinates, respectively.
  67:gcode.c       **** uint8_t gc_execute_line(char *line)
  68:gcode.c       **** {
 132              		.loc 1 68 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 88
 135              		@ frame_needed = 1, uses_anonymous_args = 0
 136 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 137              		.cfi_def_cfa_offset 28
 138              		.cfi_offset 4, -28
 139              		.cfi_offset 5, -24
 140              		.cfi_offset 6, -20
 141              		.cfi_offset 7, -16
 142              		.cfi_offset 8, -12
 143              		.cfi_offset 9, -8
 144              		.cfi_offset 14, -4
 145 0004 9DB0     		sub	sp, sp, #116
 146              		.cfi_def_cfa_offset 144
 147 0006 06AF     		add	r7, sp, #24
 148              		.cfi_def_cfa 7, 120
 149 0008 7860     		str	r0, [r7, #4]
  69:gcode.c       ****   /* -------------------------------------------------------------------------------------
  70:gcode.c       ****      STEP 1: Initialize parser block struct and copy current g-code state modes. The parser
  71:gcode.c       ****      updates these modes and commands as the block line is parser and will only be used and
  72:gcode.c       ****      executed after successful error-checking. The parser block struct also contains a block
  73:gcode.c       ****      values struct, word tracking variables, and a non-modal commands tracker for the new
  74:gcode.c       ****      block. This struct contains all of the necessary information to execute the block. */
  75:gcode.c       **** 
  76:gcode.c       ****   memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
 150              		.loc 1 76 0
 151 000a 4022     		movs	r2, #64
 152 000c 0021     		movs	r1, #0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 5


 153 000e DA48     		ldr	r0, .L279
 154 0010 FFF7FEFF 		bl	memset
  77:gcode.c       ****   memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
 155              		.loc 1 77 0
 156 0014 D84B     		ldr	r3, .L279
 157 0016 D949     		ldr	r1, .L279+4
 158 0018 5A1C     		adds	r2, r3, #1
 159 001a 0B46     		mov	r3, r1
 160 001c 03CB     		ldmia	r3!, {r0, r1}
 161 001e 1060     		str	r0, [r2]	@ unaligned
 162 0020 5160     		str	r1, [r2, #4]	@ unaligned
 163 0022 1B88     		ldrh	r3, [r3]	@ unaligned
 164 0024 1381     		strh	r3, [r2, #8]	@ unaligned
  78:gcode.c       **** 
  79:gcode.c       ****   uint8_t axis_command = AXIS_COMMAND_NONE;
 165              		.loc 1 79 0
 166 0026 0023     		movs	r3, #0
 167 0028 87F85730 		strb	r3, [r7, #87]
  80:gcode.c       ****   uint8_t axis_0, axis_1, axis_linear;
  81:gcode.c       ****   uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
 168              		.loc 1 81 0
 169 002c 0023     		movs	r3, #0
 170 002e 87F85330 		strb	r3, [r7, #83]
  82:gcode.c       **** 
  83:gcode.c       ****   // Initialize bitflag tracking variables for axis indices compatible operations.
  84:gcode.c       ****   uint8_t axis_words = 0; // XYZ tracking
 171              		.loc 1 84 0
 172 0032 0023     		movs	r3, #0
 173 0034 87F85230 		strb	r3, [r7, #82]
  85:gcode.c       ****   uint8_t ijk_words = 0; // IJK tracking
 174              		.loc 1 85 0
 175 0038 0023     		movs	r3, #0
 176 003a 87F85130 		strb	r3, [r7, #81]
  86:gcode.c       **** 
  87:gcode.c       ****   // Initialize command and value words and parser flags variables.
  88:gcode.c       ****   uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations
 177              		.loc 1 88 0
 178 003e 0023     		movs	r3, #0
 179 0040 A7F84E30 		strh	r3, [r7, #78]	@ movhi
  89:gcode.c       ****   uint16_t value_words = 0; // Tracks value words.
 180              		.loc 1 89 0
 181 0044 0023     		movs	r3, #0
 182 0046 A7F84C30 		strh	r3, [r7, #76]	@ movhi
  90:gcode.c       ****   uint8_t gc_parser_flags = GC_PARSER_NONE;
 183              		.loc 1 90 0
 184 004a 0023     		movs	r3, #0
 185 004c 87F84B30 		strb	r3, [r7, #75]
  91:gcode.c       **** 
  92:gcode.c       ****   // Determine if the line is a jogging motion or a normal g-code block.
  93:gcode.c       ****   if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 186              		.loc 1 93 0
 187 0050 7B68     		ldr	r3, [r7, #4]
 188 0052 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 189 0054 242B     		cmp	r3, #36
 190 0056 0BD1     		bne	.L10
  94:gcode.c       ****     // Set G1 and G94 enforced modes to ensure accurate error checks.
  95:gcode.c       ****     gc_parser_flags |= GC_PARSER_JOG_MOTION;
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 6


 191              		.loc 1 95 0
 192 0058 97F84B30 		ldrb	r3, [r7, #75]
 193 005c 43F00103 		orr	r3, r3, #1
 194 0060 87F84B30 		strb	r3, [r7, #75]
  96:gcode.c       ****     gc_block.modal.motion = MOTION_MODE_LINEAR;
 195              		.loc 1 96 0
 196 0064 C44B     		ldr	r3, .L279
 197 0066 0122     		movs	r2, #1
 198 0068 5A70     		strb	r2, [r3, #1]
  97:gcode.c       ****     gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 199              		.loc 1 97 0
 200 006a C34B     		ldr	r3, .L279
 201 006c 0022     		movs	r2, #0
 202 006e 9A70     		strb	r2, [r3, #2]
 203              	.L10:
  98:gcode.c       ****     #ifdef USE_LINE_NUMBERS
  99:gcode.c       ****       gc_block.values.n = JOG_LINE_NUMBER; // Initialize default line number reported during jog.
 100:gcode.c       ****     #endif
 101:gcode.c       ****   }
 102:gcode.c       **** 
 103:gcode.c       ****   /* -------------------------------------------------------------------------------------
 104:gcode.c       ****      STEP 2: Import all g-code words in the block line. A g-code word is a letter followed by
 105:gcode.c       ****      a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also,
 106:gcode.c       ****      perform initial error-checks for command word modal group violations, for any repeated
 107:gcode.c       ****      words, and for negative values set for the value words F, N, P, T, and S. */
 108:gcode.c       **** 
 109:gcode.c       ****   uint8_t word_bit; // Bit-value for assigning tracking variables
 110:gcode.c       ****   uint8_t char_counter;
 111:gcode.c       ****   char letter;
 112:gcode.c       ****   float value;
 113:gcode.c       ****   uint8_t int_value = 0;
 204              		.loc 1 113 0
 205 0070 0023     		movs	r3, #0
 206 0072 87F83E30 		strb	r3, [r7, #62]
 114:gcode.c       ****   uint16_t mantissa = 0;
 207              		.loc 1 114 0
 208 0076 0023     		movs	r3, #0
 209 0078 A7F84830 		strh	r3, [r7, #72]	@ movhi
 115:gcode.c       ****   if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
 210              		.loc 1 115 0
 211 007c 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 212 0080 03F00103 		and	r3, r3, #1
 213 0084 002B     		cmp	r3, #0
 214 0086 04D0     		beq	.L11
 215              		.loc 1 115 0 is_stmt 0 discriminator 1
 216 0088 0323     		movs	r3, #3
 217 008a 87F82630 		strb	r3, [r7, #38]
 218 008e 00F00CBC 		b	.L13
 219              	.L11:
 116:gcode.c       ****   else { char_counter = 0; }
 220              		.loc 1 116 0 is_stmt 1
 221 0092 0023     		movs	r3, #0
 222 0094 87F82630 		strb	r3, [r7, #38]
 117:gcode.c       **** 
 118:gcode.c       ****   while (line[char_counter] != 0) { // Loop until no more g-code words in line.
 223              		.loc 1 118 0
 224 0098 00F007BC 		b	.L13
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 7


 225              	.L95:
 119:gcode.c       **** 
 120:gcode.c       ****     // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
 121:gcode.c       ****     letter = line[char_counter];
 226              		.loc 1 121 0
 227 009c 97F82630 		ldrb	r3, [r7, #38]	@ zero_extendqisi2
 228 00a0 1A46     		mov	r2, r3
 229 00a2 7B68     		ldr	r3, [r7, #4]
 230 00a4 1344     		add	r3, r3, r2
 231 00a6 1B78     		ldrb	r3, [r3]
 232 00a8 87F83D30 		strb	r3, [r7, #61]
 122:gcode.c       ****     if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected wor
 233              		.loc 1 122 0
 234 00ac 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 235 00b0 402B     		cmp	r3, #64
 236 00b2 03D9     		bls	.L14
 237              		.loc 1 122 0 is_stmt 0 discriminator 2
 238 00b4 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 239 00b8 5A2B     		cmp	r3, #90
 240 00ba 02D9     		bls	.L15
 241              	.L14:
 242              		.loc 1 122 0 discriminator 3
 243 00bc 0123     		movs	r3, #1
 244 00be 01F0EEBC 		b	.L251
 245              	.L15:
 123:gcode.c       ****     char_counter++;
 246              		.loc 1 123 0 is_stmt 1
 247 00c2 97F82630 		ldrb	r3, [r7, #38]	@ zero_extendqisi2
 248 00c6 0133     		adds	r3, r3, #1
 249 00c8 DBB2     		uxtb	r3, r3
 250 00ca 87F82630 		strb	r3, [r7, #38]
 124:gcode.c       ****     if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected 
 251              		.loc 1 124 0
 252 00ce 07F12002 		add	r2, r7, #32
 253 00d2 07F12603 		add	r3, r7, #38
 254 00d6 1946     		mov	r1, r3
 255 00d8 7868     		ldr	r0, [r7, #4]
 256 00da FFF7FEFF 		bl	read_float
 257 00de 0346     		mov	r3, r0
 258 00e0 002B     		cmp	r3, #0
 259 00e2 02D1     		bne	.L17
 260              		.loc 1 124 0 is_stmt 0 discriminator 1
 261 00e4 0223     		movs	r3, #2
 262 00e6 01F0DABC 		b	.L251
 263              	.L17:
 125:gcode.c       **** 
 126:gcode.c       ****     // Convert values to smaller uint8 significand and mantissa values for parsing this word.
 127:gcode.c       ****     // NOTE: Mantissa is multiplied by 100 to catch non-integer command values. This is more
 128:gcode.c       ****     // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
 129:gcode.c       ****     // accurate enough for value words that require integers to within 0.0001. This should be
 130:gcode.c       ****     // a good enough comprimise and catch most all non-integer errors. To make it compliant,
 131:gcode.c       ****     // we would simply need to change the mantissa to int16, but this add compiled flash space.
 132:gcode.c       ****     // Maybe update this later.
 133:gcode.c       ****     int_value = trunc(value);
 264              		.loc 1 133 0 is_stmt 1
 265 00ea 3B6A     		ldr	r3, [r7, #32]	@ float
 266 00ec 1846     		mov	r0, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 8


 267 00ee FFF7FEFF 		bl	__aeabi_f2d
 268 00f2 0246     		mov	r2, r0
 269 00f4 0B46     		mov	r3, r1
 270 00f6 1046     		mov	r0, r2
 271 00f8 1946     		mov	r1, r3
 272 00fa FFF7FEFF 		bl	trunc
 273 00fe 0246     		mov	r2, r0
 274 0100 0B46     		mov	r3, r1
 275 0102 1046     		mov	r0, r2
 276 0104 1946     		mov	r1, r3
 277 0106 FFF7FEFF 		bl	__aeabi_d2uiz
 278 010a 0346     		mov	r3, r0
 279 010c 87F83E30 		strb	r3, [r7, #62]
 134:gcode.c       ****     mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
 280              		.loc 1 134 0
 281 0110 3E6A     		ldr	r6, [r7, #32]	@ float
 282 0112 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 283 0116 1846     		mov	r0, r3
 284 0118 FFF7FEFF 		bl	__aeabi_i2f
 285 011c 0346     		mov	r3, r0
 286 011e 1946     		mov	r1, r3
 287 0120 3046     		mov	r0, r6
 288 0122 FFF7FEFF 		bl	__aeabi_fsub
 289 0126 0346     		mov	r3, r0
 290 0128 9549     		ldr	r1, .L279+8
 291 012a 1846     		mov	r0, r3
 292 012c FFF7FEFF 		bl	__aeabi_fmul
 293 0130 0346     		mov	r3, r0
 294 0132 1846     		mov	r0, r3
 295 0134 FFF7FEFF 		bl	__aeabi_f2d
 296 0138 0246     		mov	r2, r0
 297 013a 0B46     		mov	r3, r1
 298 013c 1046     		mov	r0, r2
 299 013e 1946     		mov	r1, r3
 300 0140 FFF7FEFF 		bl	round
 301 0144 0246     		mov	r2, r0
 302 0146 0B46     		mov	r3, r1
 303 0148 1046     		mov	r0, r2
 304 014a 1946     		mov	r1, r3
 305 014c FFF7FEFF 		bl	__aeabi_d2uiz
 306 0150 0346     		mov	r3, r0
 307 0152 A7F84830 		strh	r3, [r7, #72]	@ movhi
 135:gcode.c       ****     // NOTE: Rounding must be used to catch small floating point errors.
 136:gcode.c       **** 
 137:gcode.c       ****     // Check if the g-code word is supported or errors due to modal group violations or has
 138:gcode.c       ****     // been repeated in the g-code block. If ok, update the command or record its value.
 139:gcode.c       ****     switch(letter) {
 308              		.loc 1 139 0
 309 0156 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 310 015a 472B     		cmp	r3, #71
 311 015c 03D0     		beq	.L19
 312 015e 4D2B     		cmp	r3, #77
 313 0160 00F0EB81 		beq	.L20
 314 0164 9EE2     		b	.L261
 315              	.L19:
 140:gcode.c       **** 
 141:gcode.c       ****       /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 9


 142:gcode.c       ****          NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
 143:gcode.c       **** 
 144:gcode.c       ****       case 'G':
 145:gcode.c       ****         // Determine 'G' command and its modal group
 146:gcode.c       ****         switch(int_value) {
 316              		.loc 1 146 0
 317 0166 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 318 016a 5E2B     		cmp	r3, #94
 319 016c 00F2BC81 		bhi	.L21
 320 0170 01A2     		adr	r2, .L23
 321 0172 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 322 0176 00BF     		.p2align 2
 323              	.L23:
 324 0178 69030000 		.word	.L22+1
 325 017c 69030000 		.word	.L22+1
 326 0180 69030000 		.word	.L22+1
 327 0184 69030000 		.word	.L22+1
 328 0188 11030000 		.word	.L24+1
 329 018c E9040000 		.word	.L21+1
 330 0190 E9040000 		.word	.L21+1
 331 0194 E9040000 		.word	.L21+1
 332 0198 E9040000 		.word	.L21+1
 333 019c E9040000 		.word	.L21+1
 334 01a0 F5020000 		.word	.L25+1
 335 01a4 E9040000 		.word	.L21+1
 336 01a8 E9040000 		.word	.L21+1
 337 01ac E9040000 		.word	.L21+1
 338 01b0 E9040000 		.word	.L21+1
 339 01b4 E9040000 		.word	.L21+1
 340 01b8 E9040000 		.word	.L21+1
 341 01bc F1030000 		.word	.L26+1
 342 01c0 F1030000 		.word	.L26+1
 343 01c4 F1030000 		.word	.L26+1
 344 01c8 5B040000 		.word	.L27+1
 345 01cc 5B040000 		.word	.L27+1
 346 01d0 E9040000 		.word	.L21+1
 347 01d4 E9040000 		.word	.L21+1
 348 01d8 E9040000 		.word	.L21+1
 349 01dc E9040000 		.word	.L21+1
 350 01e0 E9040000 		.word	.L21+1
 351 01e4 E9040000 		.word	.L21+1
 352 01e8 F5020000 		.word	.L25+1
 353 01ec E9040000 		.word	.L21+1
 354 01f0 F5020000 		.word	.L25+1
 355 01f4 E9040000 		.word	.L21+1
 356 01f8 E9040000 		.word	.L21+1
 357 01fc E9040000 		.word	.L21+1
 358 0200 E9040000 		.word	.L21+1
 359 0204 E9040000 		.word	.L21+1
 360 0208 E9040000 		.word	.L21+1
 361 020c E9040000 		.word	.L21+1
 362 0210 69030000 		.word	.L22+1
 363 0214 E9040000 		.word	.L21+1
 364 0218 71040000 		.word	.L28+1
 365 021c E9040000 		.word	.L21+1
 366 0220 E9040000 		.word	.L21+1
 367 0224 79040000 		.word	.L29+1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 10


 368 0228 E9040000 		.word	.L21+1
 369 022c E9040000 		.word	.L21+1
 370 0230 E9040000 		.word	.L21+1
 371 0234 E9040000 		.word	.L21+1
 372 0238 E9040000 		.word	.L21+1
 373 023c 79040000 		.word	.L29+1
 374 0240 E9040000 		.word	.L21+1
 375 0244 E9040000 		.word	.L21+1
 376 0248 E9040000 		.word	.L21+1
 377 024c 11030000 		.word	.L24+1
 378 0250 C1040000 		.word	.L30+1
 379 0254 C1040000 		.word	.L30+1
 380 0258 C1040000 		.word	.L30+1
 381 025c C1040000 		.word	.L30+1
 382 0260 C1040000 		.word	.L30+1
 383 0264 C1040000 		.word	.L30+1
 384 0268 E9040000 		.word	.L21+1
 385 026c D5040000 		.word	.L31+1
 386 0270 E9040000 		.word	.L21+1
 387 0274 E9040000 		.word	.L21+1
 388 0278 E9040000 		.word	.L21+1
 389 027c E9040000 		.word	.L21+1
 390 0280 E9040000 		.word	.L21+1
 391 0284 E9040000 		.word	.L21+1
 392 0288 E9040000 		.word	.L21+1
 393 028c E9040000 		.word	.L21+1
 394 0290 E9040000 		.word	.L21+1
 395 0294 E9040000 		.word	.L21+1
 396 0298 E9040000 		.word	.L21+1
 397 029c E9040000 		.word	.L21+1
 398 02a0 E9040000 		.word	.L21+1
 399 02a4 E9040000 		.word	.L21+1
 400 02a8 E9040000 		.word	.L21+1
 401 02ac E9040000 		.word	.L21+1
 402 02b0 E9040000 		.word	.L21+1
 403 02b4 E9040000 		.word	.L21+1
 404 02b8 8B030000 		.word	.L32+1
 405 02bc E9040000 		.word	.L21+1
 406 02c0 E9040000 		.word	.L21+1
 407 02c4 E9040000 		.word	.L21+1
 408 02c8 E9040000 		.word	.L21+1
 409 02cc E9040000 		.word	.L21+1
 410 02d0 E9040000 		.word	.L21+1
 411 02d4 E9040000 		.word	.L21+1
 412 02d8 E9040000 		.word	.L21+1
 413 02dc E9040000 		.word	.L21+1
 414 02e0 05040000 		.word	.L33+1
 415 02e4 05040000 		.word	.L33+1
 416 02e8 F5020000 		.word	.L25+1
 417 02ec 45040000 		.word	.L34+1
 418 02f0 45040000 		.word	.L34+1
 419              		.p2align 1
 420              	.L25:
 147:gcode.c       ****           case 10: case 28: case 30: case 92:
 148:gcode.c       ****             // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
 149:gcode.c       ****             // * G43.1 is also an axis command but is not explicitly defined this way.
 150:gcode.c       ****             if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 11


 421              		.loc 1 150 0
 422 02f4 B7F84830 		ldrh	r3, [r7, #72]
 423 02f8 002B     		cmp	r3, #0
 424 02fa 09D1     		bne	.L24
 151:gcode.c       ****               if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command
 425              		.loc 1 151 0
 426 02fc 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 427 0300 002B     		cmp	r3, #0
 428 0302 02D0     		beq	.L35
 429              		.loc 1 151 0 is_stmt 0 discriminator 1
 430 0304 1823     		movs	r3, #24
 431 0306 01F0CABB 		b	.L251
 432              	.L35:
 152:gcode.c       ****               axis_command = AXIS_COMMAND_NON_MODAL;
 433              		.loc 1 152 0 is_stmt 1
 434 030a 0123     		movs	r3, #1
 435 030c 87F85730 		strb	r3, [r7, #87]
 436              	.L24:
 153:gcode.c       ****             }
 154:gcode.c       ****             // No break. Continues to next line.
 155:gcode.c       ****           case 4: case 53:
 156:gcode.c       ****             word_bit = MODAL_GROUP_G0;
 437              		.loc 1 156 0
 438 0310 0023     		movs	r3, #0
 439 0312 87F84A30 		strb	r3, [r7, #74]
 157:gcode.c       ****             gc_block.non_modal_command = int_value;
 440              		.loc 1 157 0
 441 0316 184A     		ldr	r2, .L279
 442 0318 97F83E30 		ldrb	r3, [r7, #62]
 443 031c 1370     		strb	r3, [r2]
 158:gcode.c       ****             if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
 444              		.loc 1 158 0
 445 031e 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 446 0322 1C2B     		cmp	r3, #28
 447 0324 08D0     		beq	.L36
 448              		.loc 1 158 0 is_stmt 0 discriminator 1
 449 0326 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 450 032a 1E2B     		cmp	r3, #30
 451 032c 04D0     		beq	.L36
 452              		.loc 1 158 0 discriminator 2
 453 032e 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 454 0332 5C2B     		cmp	r3, #92
 455 0334 40F0DB80 		bne	.L269
 456              	.L36:
 159:gcode.c       ****               if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
 457              		.loc 1 159 0 is_stmt 1
 458 0338 B7F84830 		ldrh	r3, [r7, #72]
 459 033c 002B     		cmp	r3, #0
 460 033e 06D0     		beq	.L38
 461              		.loc 1 159 0 is_stmt 0 discriminator 1
 462 0340 B7F84830 		ldrh	r3, [r7, #72]
 463 0344 0A2B     		cmp	r3, #10
 464 0346 02D0     		beq	.L38
 465              		.loc 1 159 0 discriminator 2
 466 0348 1423     		movs	r3, #20
 467 034a 01F0A8BB 		b	.L251
 468              	.L38:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 12


 160:gcode.c       ****               gc_block.non_modal_command += mantissa;
 469              		.loc 1 160 0 is_stmt 1
 470 034e 0A4B     		ldr	r3, .L279
 471 0350 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 472 0352 B7F84830 		ldrh	r3, [r7, #72]	@ movhi
 473 0356 DBB2     		uxtb	r3, r3
 474 0358 1344     		add	r3, r3, r2
 475 035a DAB2     		uxtb	r2, r3
 476 035c 064B     		ldr	r3, .L279
 477 035e 1A70     		strb	r2, [r3]
 161:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 478              		.loc 1 161 0
 479 0360 0023     		movs	r3, #0
 480 0362 A7F84830 		strh	r3, [r7, #72]	@ movhi
 162:gcode.c       ****             }                
 163:gcode.c       ****             break;
 481              		.loc 1 163 0
 482 0366 C2E0     		b	.L269
 483              	.L22:
 164:gcode.c       ****           case 0: case 1: case 2: case 3: case 38:
 165:gcode.c       ****             // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
 166:gcode.c       ****             // * G43.1 is also an axis command but is not explicitly defined this way.
 167:gcode.c       ****             if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command c
 484              		.loc 1 167 0
 485 0368 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 486 036c 002B     		cmp	r3, #0
 487 036e 09D0     		beq	.L40
 488              		.loc 1 167 0 is_stmt 0 discriminator 1
 489 0370 1823     		movs	r3, #24
 490 0372 01F094BB 		b	.L251
 491              	.L280:
 492 0376 00BF     		.align	2
 493              	.L279:
 494 0378 00000000 		.word	gc_block
 495 037c 00000000 		.word	gc_state
 496 0380 0000C842 		.word	1120403456
 497              	.L40:
 168:gcode.c       ****             axis_command = AXIS_COMMAND_MOTION_MODE;
 498              		.loc 1 168 0 is_stmt 1
 499 0384 0223     		movs	r3, #2
 500 0386 87F85730 		strb	r3, [r7, #87]
 501              	.L32:
 169:gcode.c       ****             // No break. Continues to next line.
 170:gcode.c       ****           case 80:
 171:gcode.c       ****             word_bit = MODAL_GROUP_G1;
 502              		.loc 1 171 0
 503 038a 0123     		movs	r3, #1
 504 038c 87F84A30 		strb	r3, [r7, #74]
 172:gcode.c       ****             gc_block.modal.motion = int_value;
 505              		.loc 1 172 0
 506 0390 C24A     		ldr	r2, .L281
 507 0392 97F83E30 		ldrb	r3, [r7, #62]
 508 0396 5370     		strb	r3, [r2, #1]
 173:gcode.c       ****             if (int_value == 38){
 509              		.loc 1 173 0
 510 0398 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 511 039c 262B     		cmp	r3, #38
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 13


 512 039e 40F0A880 		bne	.L270
 174:gcode.c       ****               if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) 
 513              		.loc 1 174 0
 514 03a2 B7F84830 		ldrh	r3, [r7, #72]
 515 03a6 142B     		cmp	r3, #20
 516 03a8 0ED0     		beq	.L42
 517              		.loc 1 174 0 is_stmt 0 discriminator 1
 518 03aa B7F84830 		ldrh	r3, [r7, #72]
 519 03ae 1E2B     		cmp	r3, #30
 520 03b0 0AD0     		beq	.L42
 521              		.loc 1 174 0 discriminator 2
 522 03b2 B7F84830 		ldrh	r3, [r7, #72]
 523 03b6 282B     		cmp	r3, #40
 524 03b8 06D0     		beq	.L42
 525              		.loc 1 174 0 discriminator 3
 526 03ba B7F84830 		ldrh	r3, [r7, #72]
 527 03be 322B     		cmp	r3, #50
 528 03c0 02D0     		beq	.L42
 175:gcode.c       ****                 FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
 529              		.loc 1 175 0 is_stmt 1
 530 03c2 1423     		movs	r3, #20
 531 03c4 01F06BBB 		b	.L251
 532              	.L42:
 176:gcode.c       ****               }
 177:gcode.c       ****               gc_block.modal.motion += (mantissa/10)+100;
 533              		.loc 1 177 0
 534 03c8 B44B     		ldr	r3, .L281
 535 03ca 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 536 03cc B7F84830 		ldrh	r3, [r7, #72]
 537 03d0 B349     		ldr	r1, .L281+4
 538 03d2 A1FB0313 		umull	r1, r3, r1, r3
 539 03d6 DB08     		lsrs	r3, r3, #3
 540 03d8 9BB2     		uxth	r3, r3
 541 03da DBB2     		uxtb	r3, r3
 542 03dc 1344     		add	r3, r3, r2
 543 03de DBB2     		uxtb	r3, r3
 544 03e0 6433     		adds	r3, r3, #100
 545 03e2 DAB2     		uxtb	r2, r3
 546 03e4 AD4B     		ldr	r3, .L281
 547 03e6 5A70     		strb	r2, [r3, #1]
 178:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 548              		.loc 1 178 0
 549 03e8 0023     		movs	r3, #0
 550 03ea A7F84830 		strh	r3, [r7, #72]	@ movhi
 179:gcode.c       ****             }  
 180:gcode.c       ****             break;
 551              		.loc 1 180 0
 552 03ee 80E0     		b	.L270
 553              	.L26:
 181:gcode.c       ****           case 17: case 18: case 19:
 182:gcode.c       ****             word_bit = MODAL_GROUP_G2;
 554              		.loc 1 182 0
 555 03f0 0223     		movs	r3, #2
 556 03f2 87F84A30 		strb	r3, [r7, #74]
 183:gcode.c       ****             gc_block.modal.plane_select = int_value - 17;
 557              		.loc 1 183 0
 558 03f6 97F83E30 		ldrb	r3, [r7, #62]
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 14


 559 03fa 113B     		subs	r3, r3, #17
 560 03fc DAB2     		uxtb	r2, r3
 561 03fe A74B     		ldr	r3, .L281
 562 0400 5A71     		strb	r2, [r3, #5]
 184:gcode.c       ****             break;
 563              		.loc 1 184 0
 564 0402 79E0     		b	.L39
 565              	.L33:
 185:gcode.c       ****           case 90: case 91:
 186:gcode.c       ****             if (mantissa == 0) {
 566              		.loc 1 186 0
 567 0404 B7F84830 		ldrh	r3, [r7, #72]
 568 0408 002B     		cmp	r3, #0
 569 040a 09D1     		bne	.L43
 187:gcode.c       ****               word_bit = MODAL_GROUP_G3;
 570              		.loc 1 187 0
 571 040c 0323     		movs	r3, #3
 572 040e 87F84A30 		strb	r3, [r7, #74]
 188:gcode.c       ****               gc_block.modal.distance = int_value - 90;
 573              		.loc 1 188 0
 574 0412 97F83E30 		ldrb	r3, [r7, #62]
 575 0416 5A3B     		subs	r3, r3, #90
 576 0418 DAB2     		uxtb	r2, r3
 577 041a A04B     		ldr	r3, .L281
 578 041c 1A71     		strb	r2, [r3, #4]
 189:gcode.c       ****             } else {
 190:gcode.c       ****               word_bit = MODAL_GROUP_G4;
 191:gcode.c       ****               if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); 
 192:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 193:gcode.c       ****               // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
 194:gcode.c       ****             }
 195:gcode.c       ****             break;
 579              		.loc 1 195 0
 580 041e 6BE0     		b	.L39
 581              	.L43:
 190:gcode.c       ****               if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); 
 582              		.loc 1 190 0
 583 0420 0423     		movs	r3, #4
 584 0422 87F84A30 		strb	r3, [r7, #74]
 191:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 585              		.loc 1 191 0
 586 0426 B7F84830 		ldrh	r3, [r7, #72]
 587 042a 0A2B     		cmp	r3, #10
 588 042c 03D1     		bne	.L45
 191:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 589              		.loc 1 191 0 is_stmt 0 discriminator 2
 590 042e 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 591 0432 5A2B     		cmp	r3, #90
 592 0434 02D1     		bne	.L46
 593              	.L45:
 191:gcode.c       ****               mantissa = 0; // Set to zero to indicate valid non-integer G command.
 594              		.loc 1 191 0 discriminator 3
 595 0436 1423     		movs	r3, #20
 596 0438 01F031BB 		b	.L251
 597              	.L46:
 192:gcode.c       ****               // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
 598              		.loc 1 192 0 is_stmt 1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 15


 599 043c 0023     		movs	r3, #0
 600 043e A7F84830 		strh	r3, [r7, #72]	@ movhi
 601              		.loc 1 195 0
 602 0442 59E0     		b	.L39
 603              	.L34:
 196:gcode.c       ****           case 93: case 94:
 197:gcode.c       ****             word_bit = MODAL_GROUP_G5;
 604              		.loc 1 197 0
 605 0444 0523     		movs	r3, #5
 606 0446 87F84A30 		strb	r3, [r7, #74]
 198:gcode.c       ****             gc_block.modal.feed_rate = 94 - int_value;
 607              		.loc 1 198 0
 608 044a 97F83E30 		ldrb	r3, [r7, #62]
 609 044e C3F15E03 		rsb	r3, r3, #94
 610 0452 DAB2     		uxtb	r2, r3
 611 0454 914B     		ldr	r3, .L281
 612 0456 9A70     		strb	r2, [r3, #2]
 199:gcode.c       ****             break;
 613              		.loc 1 199 0
 614 0458 4EE0     		b	.L39
 615              	.L27:
 200:gcode.c       ****           case 20: case 21:
 201:gcode.c       ****             word_bit = MODAL_GROUP_G6;
 616              		.loc 1 201 0
 617 045a 0623     		movs	r3, #6
 618 045c 87F84A30 		strb	r3, [r7, #74]
 202:gcode.c       ****             gc_block.modal.units = 21 - int_value;
 619              		.loc 1 202 0
 620 0460 97F83E30 		ldrb	r3, [r7, #62]
 621 0464 C3F11503 		rsb	r3, r3, #21
 622 0468 DAB2     		uxtb	r2, r3
 623 046a 8C4B     		ldr	r3, .L281
 624 046c DA70     		strb	r2, [r3, #3]
 203:gcode.c       ****             break;
 625              		.loc 1 203 0
 626 046e 43E0     		b	.L39
 627              	.L28:
 204:gcode.c       ****           case 40:
 205:gcode.c       ****             word_bit = MODAL_GROUP_G7;
 628              		.loc 1 205 0
 629 0470 0723     		movs	r3, #7
 630 0472 87F84A30 		strb	r3, [r7, #74]
 206:gcode.c       ****             // NOTE: Not required since cutter radius compensation is always disabled. Only here
 207:gcode.c       ****             // to support G40 commands that often appear in g-code program headers to setup default
 208:gcode.c       ****             // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
 209:gcode.c       ****             break;
 631              		.loc 1 209 0
 632 0476 3FE0     		b	.L39
 633              	.L29:
 210:gcode.c       ****           case 43: case 49:
 211:gcode.c       ****             word_bit = MODAL_GROUP_G8;
 634              		.loc 1 211 0
 635 0478 0823     		movs	r3, #8
 636 047a 87F84A30 		strb	r3, [r7, #74]
 212:gcode.c       ****             // NOTE: The NIST g-code standard vaguely states that when a tool length offset is chan
 213:gcode.c       ****             // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, a
 214:gcode.c       ****             // all are explicit axis commands, regardless if they require axis words or not.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 16


 215:gcode.c       ****             if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command c
 637              		.loc 1 215 0
 638 047e 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 639 0482 002B     		cmp	r3, #0
 640 0484 02D0     		beq	.L47
 641              		.loc 1 215 0 is_stmt 0 discriminator 1
 642 0486 1823     		movs	r3, #24
 643 0488 01F009BB 		b	.L251
 644              	.L47:
 216:gcode.c       ****             axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
 645              		.loc 1 216 0 is_stmt 1
 646 048c 0323     		movs	r3, #3
 647 048e 87F85730 		strb	r3, [r7, #87]
 217:gcode.c       ****             if (int_value == 49) { // G49
 648              		.loc 1 217 0
 649 0492 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 650 0496 312B     		cmp	r3, #49
 651 0498 03D1     		bne	.L48
 218:gcode.c       ****               gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
 652              		.loc 1 218 0
 653 049a 804B     		ldr	r3, .L281
 654 049c 0022     		movs	r2, #0
 655 049e 9A71     		strb	r2, [r3, #6]
 656 04a0 0AE0     		b	.L49
 657              	.L48:
 219:gcode.c       ****             } else if (mantissa == 10) { // G43.1
 658              		.loc 1 219 0
 659 04a2 B7F84830 		ldrh	r3, [r7, #72]
 660 04a6 0A2B     		cmp	r3, #10
 661 04a8 03D1     		bne	.L50
 220:gcode.c       ****               gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
 662              		.loc 1 220 0
 663 04aa 7C4B     		ldr	r3, .L281
 664 04ac 0122     		movs	r2, #1
 665 04ae 9A71     		strb	r2, [r3, #6]
 666 04b0 02E0     		b	.L49
 667              	.L50:
 221:gcode.c       ****             } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
 668              		.loc 1 221 0
 669 04b2 1423     		movs	r3, #20
 670 04b4 01F0F3BA 		b	.L251
 671              	.L49:
 222:gcode.c       ****             mantissa = 0; // Set to zero to indicate valid non-integer G command.
 672              		.loc 1 222 0
 673 04b8 0023     		movs	r3, #0
 674 04ba A7F84830 		strh	r3, [r7, #72]	@ movhi
 223:gcode.c       ****             break;
 675              		.loc 1 223 0
 676 04be 1BE0     		b	.L39
 677              	.L30:
 224:gcode.c       ****           case 54: case 55: case 56: case 57: case 58: case 59:
 225:gcode.c       ****             // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
 226:gcode.c       ****             word_bit = MODAL_GROUP_G12;
 678              		.loc 1 226 0
 679 04c0 0923     		movs	r3, #9
 680 04c2 87F84A30 		strb	r3, [r7, #74]
 227:gcode.c       ****             gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 17


 681              		.loc 1 227 0
 682 04c6 97F83E30 		ldrb	r3, [r7, #62]
 683 04ca 363B     		subs	r3, r3, #54
 684 04cc DAB2     		uxtb	r2, r3
 685 04ce 734B     		ldr	r3, .L281
 686 04d0 DA71     		strb	r2, [r3, #7]
 228:gcode.c       ****             break;
 687              		.loc 1 228 0
 688 04d2 11E0     		b	.L39
 689              	.L31:
 229:gcode.c       ****           case 61:
 230:gcode.c       ****             word_bit = MODAL_GROUP_G13;
 690              		.loc 1 230 0
 691 04d4 0A23     		movs	r3, #10
 692 04d6 87F84A30 		strb	r3, [r7, #74]
 231:gcode.c       ****             if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
 693              		.loc 1 231 0
 694 04da B7F84830 		ldrh	r3, [r7, #72]
 695 04de 002B     		cmp	r3, #0
 696 04e0 09D0     		beq	.L271
 697              		.loc 1 231 0 is_stmt 0 discriminator 1
 698 04e2 1423     		movs	r3, #20
 699 04e4 01F0DBBA 		b	.L251
 700              	.L21:
 232:gcode.c       ****             // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
 233:gcode.c       ****             break;
 234:gcode.c       ****           default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
 701              		.loc 1 234 0 is_stmt 1
 702 04e8 1423     		movs	r3, #20
 703 04ea 01F0D8BA 		b	.L251
 704              	.L269:
 163:gcode.c       ****           case 0: case 1: case 2: case 3: case 38:
 705              		.loc 1 163 0
 706 04ee 00BF     		nop
 707 04f0 02E0     		b	.L39
 708              	.L270:
 180:gcode.c       ****           case 17: case 18: case 19:
 709              		.loc 1 180 0
 710 04f2 00BF     		nop
 711 04f4 00E0     		b	.L39
 712              	.L271:
 233:gcode.c       ****           default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
 713              		.loc 1 233 0
 714 04f6 00BF     		nop
 715              	.L39:
 235:gcode.c       ****         }
 236:gcode.c       ****         if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or inva
 716              		.loc 1 236 0
 717 04f8 B7F84830 		ldrh	r3, [r7, #72]
 718 04fc 002B     		cmp	r3, #0
 719 04fe 02D0     		beq	.L52
 720              		.loc 1 236 0 is_stmt 0 discriminator 1
 721 0500 1723     		movs	r3, #23
 722 0502 01F0CCBA 		b	.L251
 723              	.L52:
 237:gcode.c       ****         // Check for more than one command per modal group violations in the current block
 238:gcode.c       ****         // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 18


 239:gcode.c       ****         if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); 
 724              		.loc 1 239 0 is_stmt 1
 725 0506 B7F84E20 		ldrh	r2, [r7, #78]
 726 050a 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 727 050e 42FA03F3 		asr	r3, r2, r3
 728 0512 03F00103 		and	r3, r3, #1
 729 0516 002B     		cmp	r3, #0
 730 0518 02D0     		beq	.L53
 731              		.loc 1 239 0 is_stmt 0 discriminator 1
 732 051a 1523     		movs	r3, #21
 733 051c 01F0BFBA 		b	.L251
 734              	.L53:
 240:gcode.c       ****         command_words |= bit(word_bit);
 735              		.loc 1 240 0 is_stmt 1
 736 0520 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 737 0524 0122     		movs	r2, #1
 738 0526 02FA03F3 		lsl	r3, r2, r3
 739 052a 1AB2     		sxth	r2, r3
 740 052c B7F94E30 		ldrsh	r3, [r7, #78]
 741 0530 1343     		orrs	r3, r3, r2
 742 0532 1BB2     		sxth	r3, r3
 743 0534 A7F84E30 		strh	r3, [r7, #78]	@ movhi
 241:gcode.c       ****         break;
 744              		.loc 1 241 0
 745 0538 B7E1     		b	.L13
 746              	.L20:
 242:gcode.c       **** 
 243:gcode.c       ****       case 'M':
 244:gcode.c       **** 
 245:gcode.c       ****         // Determine 'M' command and its modal group
 246:gcode.c       ****         if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
 747              		.loc 1 246 0
 748 053a B7F84830 		ldrh	r3, [r7, #72]
 749 053e 002B     		cmp	r3, #0
 750 0540 02D0     		beq	.L54
 751              		.loc 1 246 0 is_stmt 0 discriminator 1
 752 0542 1723     		movs	r3, #23
 753 0544 01F0ABBA 		b	.L251
 754              	.L54:
 247:gcode.c       ****         switch(int_value) {
 755              		.loc 1 247 0 is_stmt 1
 756 0548 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 757 054c 1E2B     		cmp	r3, #30
 758 054e 00F28880 		bhi	.L55
 759 0552 01A2     		adr	r2, .L57
 760 0554 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 761              		.p2align 2
 762              	.L57:
 763 0558 D5050000 		.word	.L56+1
 764 055c D5050000 		.word	.L56+1
 765 0560 D5050000 		.word	.L56+1
 766 0564 FF050000 		.word	.L58+1
 767 0568 FF050000 		.word	.L58+1
 768 056c FF050000 		.word	.L58+1
 769 0570 63060000 		.word	.L55+1
 770 0574 31060000 		.word	.L59+1
 771 0578 31060000 		.word	.L59+1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 19


 772 057c 31060000 		.word	.L59+1
 773 0580 63060000 		.word	.L55+1
 774 0584 63060000 		.word	.L55+1
 775 0588 63060000 		.word	.L55+1
 776 058c 63060000 		.word	.L55+1
 777 0590 63060000 		.word	.L55+1
 778 0594 63060000 		.word	.L55+1
 779 0598 63060000 		.word	.L55+1
 780 059c 63060000 		.word	.L55+1
 781 05a0 63060000 		.word	.L55+1
 782 05a4 63060000 		.word	.L55+1
 783 05a8 63060000 		.word	.L55+1
 784 05ac 63060000 		.word	.L55+1
 785 05b0 63060000 		.word	.L55+1
 786 05b4 63060000 		.word	.L55+1
 787 05b8 63060000 		.word	.L55+1
 788 05bc 63060000 		.word	.L55+1
 789 05c0 63060000 		.word	.L55+1
 790 05c4 63060000 		.word	.L55+1
 791 05c8 63060000 		.word	.L55+1
 792 05cc 63060000 		.word	.L55+1
 793 05d0 D5050000 		.word	.L56+1
 794              		.p2align 1
 795              	.L56:
 248:gcode.c       ****           case 0: case 1: case 2: case 30:
 249:gcode.c       ****             word_bit = MODAL_GROUP_M4;
 796              		.loc 1 249 0
 797 05d4 0B23     		movs	r3, #11
 798 05d6 87F84A30 		strb	r3, [r7, #74]
 250:gcode.c       ****             switch(int_value) {
 799              		.loc 1 250 0
 800 05da 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 801 05de 002B     		cmp	r3, #0
 802 05e0 02D0     		beq	.L61
 803 05e2 012B     		cmp	r3, #1
 804 05e4 09D0     		beq	.L272
 805 05e6 03E0     		b	.L262
 806              	.L61:
 251:gcode.c       ****               case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
 807              		.loc 1 251 0
 808 05e8 2C4B     		ldr	r3, .L281
 809 05ea 0322     		movs	r2, #3
 810 05ec 1A72     		strb	r2, [r3, #8]
 811 05ee 05E0     		b	.L63
 812              	.L262:
 252:gcode.c       ****               case 1: break; // Optional stop not supported. Ignore.
 253:gcode.c       ****               default: gc_block.modal.program_flow = int_value; // Program end and reset
 813              		.loc 1 253 0
 814 05f0 2A4A     		ldr	r2, .L281
 815 05f2 97F83E30 		ldrb	r3, [r7, #62]
 816 05f6 1372     		strb	r3, [r2, #8]
 254:gcode.c       ****             }
 255:gcode.c       ****             break;
 817              		.loc 1 255 0
 818 05f8 36E0     		b	.L64
 819              	.L272:
 252:gcode.c       ****               case 1: break; // Optional stop not supported. Ignore.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 20


 820              		.loc 1 252 0
 821 05fa 00BF     		nop
 822              	.L63:
 823              		.loc 1 255 0 discriminator 1
 824 05fc 34E0     		b	.L64
 825              	.L58:
 256:gcode.c       ****           #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
 257:gcode.c       ****             case 4:
 258:gcode.c       ****           #endif
 259:gcode.c       ****           case 3: case 5:
 260:gcode.c       ****             word_bit = MODAL_GROUP_M7;
 826              		.loc 1 260 0
 827 05fe 0C23     		movs	r3, #12
 828 0600 87F84A30 		strb	r3, [r7, #74]
 261:gcode.c       ****             switch(int_value) {
 829              		.loc 1 261 0
 830 0604 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 831 0608 042B     		cmp	r3, #4
 832 060a 08D0     		beq	.L66
 833 060c 052B     		cmp	r3, #5
 834 060e 0AD0     		beq	.L67
 835 0610 032B     		cmp	r3, #3
 836 0612 00D0     		beq	.L68
 262:gcode.c       ****               case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
 263:gcode.c       ****               #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
 264:gcode.c       ****                 case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
 265:gcode.c       ****               #endif
 266:gcode.c       ****               case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
 267:gcode.c       ****             }
 268:gcode.c       ****             break;
 837              		.loc 1 268 0
 838 0614 28E0     		b	.L64
 839              	.L68:
 262:gcode.c       ****               case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
 840              		.loc 1 262 0
 841 0616 214B     		ldr	r3, .L281
 842 0618 1022     		movs	r2, #16
 843 061a 9A72     		strb	r2, [r3, #10]
 844 061c 07E0     		b	.L65
 845              	.L66:
 264:gcode.c       ****               #endif
 846              		.loc 1 264 0
 847 061e 1F4B     		ldr	r3, .L281
 848 0620 2022     		movs	r2, #32
 849 0622 9A72     		strb	r2, [r3, #10]
 850 0624 03E0     		b	.L65
 851              	.L67:
 266:gcode.c       ****             }
 852              		.loc 1 266 0
 853 0626 1D4B     		ldr	r3, .L281
 854 0628 0022     		movs	r2, #0
 855 062a 9A72     		strb	r2, [r3, #10]
 856 062c 00BF     		nop
 857              	.L65:
 858              		.loc 1 268 0
 859 062e 1BE0     		b	.L64
 860              	.L59:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 21


 269:gcode.c       ****           #ifdef ENABLE_M7
 270:gcode.c       ****             case 7: case 8: case 9:
 271:gcode.c       ****           #else
 272:gcode.c       ****             case 8: case 9:
 273:gcode.c       ****           #endif
 274:gcode.c       ****             word_bit = MODAL_GROUP_M8;
 861              		.loc 1 274 0
 862 0630 0D23     		movs	r3, #13
 863 0632 87F84A30 		strb	r3, [r7, #74]
 275:gcode.c       ****             switch(int_value) {
 864              		.loc 1 275 0
 865 0636 97F83E30 		ldrb	r3, [r7, #62]	@ zero_extendqisi2
 866 063a 082B     		cmp	r3, #8
 867 063c 08D0     		beq	.L70
 868 063e 092B     		cmp	r3, #9
 869 0640 0AD0     		beq	.L71
 870 0642 072B     		cmp	r3, #7
 871 0644 00D0     		beq	.L72
 276:gcode.c       ****               #ifdef ENABLE_M7
 277:gcode.c       ****                 case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
 278:gcode.c       ****               #endif
 279:gcode.c       ****               case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
 280:gcode.c       ****               case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
 281:gcode.c       ****             }
 282:gcode.c       ****             break;
 872              		.loc 1 282 0
 873 0646 0FE0     		b	.L64
 874              	.L72:
 277:gcode.c       ****               #endif
 875              		.loc 1 277 0
 876 0648 144B     		ldr	r3, .L281
 877 064a 8022     		movs	r2, #128
 878 064c 5A72     		strb	r2, [r3, #9]
 879 064e 07E0     		b	.L69
 880              	.L70:
 279:gcode.c       ****               case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
 881              		.loc 1 279 0
 882 0650 124B     		ldr	r3, .L281
 883 0652 4022     		movs	r2, #64
 884 0654 5A72     		strb	r2, [r3, #9]
 885 0656 03E0     		b	.L69
 886              	.L71:
 280:gcode.c       ****             }
 887              		.loc 1 280 0
 888 0658 104B     		ldr	r3, .L281
 889 065a 0022     		movs	r2, #0
 890 065c 5A72     		strb	r2, [r3, #9]
 891 065e 00BF     		nop
 892              	.L69:
 893              		.loc 1 282 0
 894 0660 02E0     		b	.L64
 895              	.L55:
 283:gcode.c       ****           default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
 896              		.loc 1 283 0
 897 0662 1423     		movs	r3, #20
 898 0664 01F01BBA 		b	.L251
 899              	.L64:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 22


 284:gcode.c       ****         }
 285:gcode.c       **** 
 286:gcode.c       ****         // Check for more than one command per modal group violations in the current block
 287:gcode.c       ****         // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
 288:gcode.c       ****         if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); 
 900              		.loc 1 288 0
 901 0668 B7F84E20 		ldrh	r2, [r7, #78]
 902 066c 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 903 0670 42FA03F3 		asr	r3, r2, r3
 904 0674 03F00103 		and	r3, r3, #1
 905 0678 002B     		cmp	r3, #0
 906 067a 02D0     		beq	.L73
 907              		.loc 1 288 0 is_stmt 0 discriminator 1
 908 067c 1523     		movs	r3, #21
 909 067e 01F00EBA 		b	.L251
 910              	.L73:
 289:gcode.c       ****         command_words |= bit(word_bit);
 911              		.loc 1 289 0 is_stmt 1
 912 0682 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 913 0686 0122     		movs	r2, #1
 914 0688 02FA03F3 		lsl	r3, r2, r3
 915 068c 1AB2     		sxth	r2, r3
 916 068e B7F94E30 		ldrsh	r3, [r7, #78]
 917 0692 1343     		orrs	r3, r3, r2
 918 0694 1BB2     		sxth	r3, r3
 919 0696 A7F84E30 		strh	r3, [r7, #78]	@ movhi
 290:gcode.c       ****         break;
 920              		.loc 1 290 0
 921 069a 06E1     		b	.L13
 922              	.L282:
 923              		.align	2
 924              	.L281:
 925 069c 00000000 		.word	gc_block
 926 06a0 CDCCCCCC 		.word	-858993459
 927              	.L261:
 291:gcode.c       **** 
 292:gcode.c       ****       // NOTE: All remaining letters assign values.
 293:gcode.c       ****       default:
 294:gcode.c       **** 
 295:gcode.c       ****         /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
 296:gcode.c       ****            legal g-code words and stores their value. Error-checking is performed later since some
 297:gcode.c       ****            words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
 298:gcode.c       ****         switch(letter){
 928              		.loc 1 298 0
 929 06a4 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 930 06a8 463B     		subs	r3, r3, #70
 931 06aa 142B     		cmp	r3, #20
 932 06ac 00F2CB80 		bhi	.L74
 933 06b0 01A2     		adr	r2, .L76
 934 06b2 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 935 06b6 00BF     		.p2align 2
 936              	.L76:
 937 06b8 0D070000 		.word	.L75+1
 938 06bc 47080000 		.word	.L74+1
 939 06c0 47080000 		.word	.L74+1
 940 06c4 1B070000 		.word	.L77+1
 941 06c8 35070000 		.word	.L78+1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 23


 942 06cc 4F070000 		.word	.L79+1
 943 06d0 69070000 		.word	.L80+1
 944 06d4 47080000 		.word	.L74+1
 945 06d8 79070000 		.word	.L81+1
 946 06dc 47080000 		.word	.L74+1
 947 06e0 A7070000 		.word	.L82+1
 948 06e4 47080000 		.word	.L74+1
 949 06e8 B5070000 		.word	.L83+1
 950 06ec C3070000 		.word	.L84+1
 951 06f0 D1070000 		.word	.L85+1
 952 06f4 47080000 		.word	.L74+1
 953 06f8 47080000 		.word	.L74+1
 954 06fc 47080000 		.word	.L74+1
 955 0700 F9070000 		.word	.L86+1
 956 0704 13080000 		.word	.L87+1
 957 0708 2D080000 		.word	.L88+1
 958              		.p2align 1
 959              	.L75:
 299:gcode.c       ****           #ifdef A_AXIS
 300:gcode.c       ****             case 'A': word_bit = WORD_A; gc_block.values.xyz[A_AXIS] = value; axis_words |= (1<<A_A
 301:gcode.c       ****           #endif
 302:gcode.c       ****           #ifdef B_AXIS
 303:gcode.c       ****             case 'B': word_bit = WORD_B; gc_block.values.xyz[B_AXIS] = value; axis_words |= (1<<B_A
 304:gcode.c       ****           #endif
 305:gcode.c       ****           #ifdef C_AXIS
 306:gcode.c       ****             case 'C': word_bit = WORD_C; gc_block.values.xyz[C_AXIS] = value; axis_words |= (1<<C_A
 307:gcode.c       ****           #endif
 308:gcode.c       ****           // case 'D': // Not supported
 309:gcode.c       ****           case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
 960              		.loc 1 309 0
 961 070c 0023     		movs	r3, #0
 962 070e 87F84A30 		strb	r3, [r7, #74]
 963 0712 3B6A     		ldr	r3, [r7, #32]	@ float
 964 0714 BE4A     		ldr	r2, .L283+8
 965 0716 D360     		str	r3, [r2, #12]	@ float
 966 0718 98E0     		b	.L89
 967              	.L77:
 310:gcode.c       ****           // case 'H': // Not supported
 311:gcode.c       ****           case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS
 968              		.loc 1 311 0
 969 071a 0123     		movs	r3, #1
 970 071c 87F84A30 		strb	r3, [r7, #74]
 971 0720 3B6A     		ldr	r3, [r7, #32]	@ float
 972 0722 BB4A     		ldr	r2, .L283+8
 973 0724 1361     		str	r3, [r2, #16]	@ float
 974 0726 97F85130 		ldrb	r3, [r7, #81]
 975 072a 43F00103 		orr	r3, r3, #1
 976 072e 87F85130 		strb	r3, [r7, #81]
 977 0732 8BE0     		b	.L89
 978              	.L78:
 312:gcode.c       ****           case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS
 979              		.loc 1 312 0
 980 0734 0223     		movs	r3, #2
 981 0736 87F84A30 		strb	r3, [r7, #74]
 982 073a 3B6A     		ldr	r3, [r7, #32]	@ float
 983 073c B44A     		ldr	r2, .L283+8
 984 073e 5361     		str	r3, [r2, #20]	@ float
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 24


 985 0740 97F85130 		ldrb	r3, [r7, #81]
 986 0744 43F00203 		orr	r3, r3, #2
 987 0748 87F85130 		strb	r3, [r7, #81]
 988 074c 7EE0     		b	.L89
 989              	.L79:
 313:gcode.c       ****           case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS
 990              		.loc 1 313 0
 991 074e 0323     		movs	r3, #3
 992 0750 87F84A30 		strb	r3, [r7, #74]
 993 0754 3B6A     		ldr	r3, [r7, #32]	@ float
 994 0756 AE4A     		ldr	r2, .L283+8
 995 0758 9361     		str	r3, [r2, #24]	@ float
 996 075a 97F85130 		ldrb	r3, [r7, #81]
 997 075e 43F00403 		orr	r3, r3, #4
 998 0762 87F85130 		strb	r3, [r7, #81]
 999 0766 71E0     		b	.L89
 1000              	.L80:
 314:gcode.c       ****           case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
 1001              		.loc 1 314 0
 1002 0768 0423     		movs	r3, #4
 1003 076a 87F84A30 		strb	r3, [r7, #74]
 1004 076e A84A     		ldr	r2, .L283+8
 1005 0770 97F83E30 		ldrb	r3, [r7, #62]
 1006 0774 1377     		strb	r3, [r2, #28]
 1007 0776 69E0     		b	.L89
 1008              	.L81:
 315:gcode.c       ****           case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
 1009              		.loc 1 315 0
 1010 0778 0523     		movs	r3, #5
 1011 077a 87F84A30 		strb	r3, [r7, #74]
 1012 077e 3B6A     		ldr	r3, [r7, #32]	@ float
 1013 0780 1846     		mov	r0, r3
 1014 0782 FFF7FEFF 		bl	__aeabi_f2d
 1015 0786 0246     		mov	r2, r0
 1016 0788 0B46     		mov	r3, r1
 1017 078a 1046     		mov	r0, r2
 1018 078c 1946     		mov	r1, r3
 1019 078e FFF7FEFF 		bl	trunc
 1020 0792 0246     		mov	r2, r0
 1021 0794 0B46     		mov	r3, r1
 1022 0796 1046     		mov	r0, r2
 1023 0798 1946     		mov	r1, r3
 1024 079a FFF7FEFF 		bl	__aeabi_d2iz
 1025 079e 0246     		mov	r2, r0
 1026 07a0 9B4B     		ldr	r3, .L283+8
 1027 07a2 1A62     		str	r2, [r3, #32]
 1028 07a4 52E0     		b	.L89
 1029              	.L82:
 316:gcode.c       ****           case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
 1030              		.loc 1 316 0
 1031 07a6 0623     		movs	r3, #6
 1032 07a8 87F84A30 		strb	r3, [r7, #74]
 1033 07ac 3B6A     		ldr	r3, [r7, #32]	@ float
 1034 07ae 984A     		ldr	r2, .L283+8
 1035 07b0 5362     		str	r3, [r2, #36]	@ float
 1036 07b2 4BE0     		b	.L89
 1037              	.L83:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 25


 317:gcode.c       ****           // NOTE: For certain commands, P value must be an integer, but none of these commands are
 318:gcode.c       ****           // case 'Q': // Not supported
 319:gcode.c       ****           case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
 1038              		.loc 1 319 0
 1039 07b4 0723     		movs	r3, #7
 1040 07b6 87F84A30 		strb	r3, [r7, #74]
 1041 07ba 3B6A     		ldr	r3, [r7, #32]	@ float
 1042 07bc 944A     		ldr	r2, .L283+8
 1043 07be 9362     		str	r3, [r2, #40]	@ float
 1044 07c0 44E0     		b	.L89
 1045              	.L84:
 320:gcode.c       ****           case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
 1046              		.loc 1 320 0
 1047 07c2 0823     		movs	r3, #8
 1048 07c4 87F84A30 		strb	r3, [r7, #74]
 1049 07c8 3B6A     		ldr	r3, [r7, #32]	@ float
 1050 07ca 914A     		ldr	r2, .L283+8
 1051 07cc D362     		str	r3, [r2, #44]	@ float
 1052 07ce 3DE0     		b	.L89
 1053              	.L85:
 321:gcode.c       ****           case 'T': word_bit = WORD_T;
 1054              		.loc 1 321 0
 1055 07d0 0923     		movs	r3, #9
 1056 07d2 87F84A30 		strb	r3, [r7, #74]
 322:gcode.c       ****             if(value > MAX_TOOL_NUMBER)  { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
 1057              		.loc 1 322 0
 1058 07d6 3B6A     		ldr	r3, [r7, #32]	@ float
 1059 07d8 8E49     		ldr	r1, .L283+12
 1060 07da 1846     		mov	r0, r3
 1061 07dc FFF7FEFF 		bl	__aeabi_fcmpgt
 1062 07e0 0346     		mov	r3, r0
 1063 07e2 002B     		cmp	r3, #0
 1064 07e4 02D0     		beq	.L263
 1065              		.loc 1 322 0 is_stmt 0 discriminator 1
 1066 07e6 2623     		movs	r3, #38
 1067 07e8 01F059B9 		b	.L251
 1068              	.L263:
 323:gcode.c       ****              gc_block.values.t = int_value;
 1069              		.loc 1 323 0 is_stmt 1
 1070 07ec 884A     		ldr	r2, .L283+8
 1071 07ee 97F83E30 		ldrb	r3, [r7, #62]
 1072 07f2 82F83030 		strb	r3, [r2, #48]
 324:gcode.c       ****  						break;
 1073              		.loc 1 324 0
 1074 07f6 29E0     		b	.L89
 1075              	.L86:
 325:gcode.c       ****           case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXI
 1076              		.loc 1 325 0
 1077 07f8 0A23     		movs	r3, #10
 1078 07fa 87F84A30 		strb	r3, [r7, #74]
 1079 07fe 3B6A     		ldr	r3, [r7, #32]	@ float
 1080 0800 834A     		ldr	r2, .L283+8
 1081 0802 5363     		str	r3, [r2, #52]	@ float
 1082 0804 97F85230 		ldrb	r3, [r7, #82]
 1083 0808 43F00103 		orr	r3, r3, #1
 1084 080c 87F85230 		strb	r3, [r7, #82]
 1085 0810 1CE0     		b	.L89
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 26


 1086              	.L87:
 326:gcode.c       ****           case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXI
 1087              		.loc 1 326 0
 1088 0812 0B23     		movs	r3, #11
 1089 0814 87F84A30 		strb	r3, [r7, #74]
 1090 0818 3B6A     		ldr	r3, [r7, #32]	@ float
 1091 081a 7D4A     		ldr	r2, .L283+8
 1092 081c 9363     		str	r3, [r2, #56]	@ float
 1093 081e 97F85230 		ldrb	r3, [r7, #82]
 1094 0822 43F00203 		orr	r3, r3, #2
 1095 0826 87F85230 		strb	r3, [r7, #82]
 1096 082a 0FE0     		b	.L89
 1097              	.L88:
 327:gcode.c       ****           case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXI
 1098              		.loc 1 327 0
 1099 082c 0C23     		movs	r3, #12
 1100 082e 87F84A30 		strb	r3, [r7, #74]
 1101 0832 3B6A     		ldr	r3, [r7, #32]	@ float
 1102 0834 764A     		ldr	r2, .L283+8
 1103 0836 D363     		str	r3, [r2, #60]	@ float
 1104 0838 97F85230 		ldrb	r3, [r7, #82]
 1105 083c 43F00403 		orr	r3, r3, #4
 1106 0840 87F85230 		strb	r3, [r7, #82]
 1107 0844 02E0     		b	.L89
 1108              	.L74:
 328:gcode.c       ****           default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
 1109              		.loc 1 328 0
 1110 0846 1423     		movs	r3, #20
 1111 0848 01F029B9 		b	.L251
 1112              	.L89:
 329:gcode.c       ****         }
 330:gcode.c       **** 
 331:gcode.c       ****         // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
 332:gcode.c       ****         if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word r
 1113              		.loc 1 332 0
 1114 084c B7F84C20 		ldrh	r2, [r7, #76]
 1115 0850 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 1116 0854 42FA03F3 		asr	r3, r2, r3
 1117 0858 03F00103 		and	r3, r3, #1
 1118 085c 002B     		cmp	r3, #0
 1119 085e 02D0     		beq	.L92
 1120              		.loc 1 332 0 is_stmt 0 discriminator 1
 1121 0860 1923     		movs	r3, #25
 1122 0862 01F01CB9 		b	.L251
 1123              	.L92:
 333:gcode.c       ****         // Check for invalid negative values for words F, N, P, T, and S.
 334:gcode.c       ****         // NOTE: Negative value check is done here simply for code-efficiency.
 335:gcode.c       ****         if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
 1124              		.loc 1 335 0 is_stmt 1
 1125 0866 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 1126 086a 40F26132 		movw	r2, #865
 1127 086e 42FA03F3 		asr	r3, r2, r3
 1128 0872 03F00103 		and	r3, r3, #1
 1129 0876 002B     		cmp	r3, #0
 1130 0878 0BD0     		beq	.L93
 336:gcode.c       ****           if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
 1131              		.loc 1 336 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 27


 1132 087a 3B6A     		ldr	r3, [r7, #32]	@ float
 1133 087c 4FF00001 		mov	r1, #0
 1134 0880 1846     		mov	r0, r3
 1135 0882 FFF7FEFF 		bl	__aeabi_fcmplt
 1136 0886 0346     		mov	r3, r0
 1137 0888 002B     		cmp	r3, #0
 1138 088a 02D0     		beq	.L93
 1139              		.loc 1 336 0 is_stmt 0 discriminator 1
 1140 088c 0423     		movs	r3, #4
 1141 088e 01F006B9 		b	.L251
 1142              	.L93:
 337:gcode.c       ****         }
 338:gcode.c       ****         value_words |= bit(word_bit); // Flag to indicate parameter assigned.
 1143              		.loc 1 338 0 is_stmt 1
 1144 0892 97F84A30 		ldrb	r3, [r7, #74]	@ zero_extendqisi2
 1145 0896 0122     		movs	r2, #1
 1146 0898 02FA03F3 		lsl	r3, r2, r3
 1147 089c 1AB2     		sxth	r2, r3
 1148 089e B7F94C30 		ldrsh	r3, [r7, #76]
 1149 08a2 1343     		orrs	r3, r3, r2
 1150 08a4 1BB2     		sxth	r3, r3
 1151 08a6 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 1152              	.L13:
 118:gcode.c       **** 
 1153              		.loc 1 118 0
 1154 08aa 97F82630 		ldrb	r3, [r7, #38]	@ zero_extendqisi2
 1155 08ae 1A46     		mov	r2, r3
 1156 08b0 7B68     		ldr	r3, [r7, #4]
 1157 08b2 1344     		add	r3, r3, r2
 1158 08b4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1159 08b6 002B     		cmp	r3, #0
 1160 08b8 7FF4F0AB 		bne	.L95
 339:gcode.c       **** 
 340:gcode.c       ****     }
 341:gcode.c       ****   }
 342:gcode.c       ****   // Parsing complete!
 343:gcode.c       **** 
 344:gcode.c       **** 
 345:gcode.c       ****   /* -------------------------------------------------------------------------------------
 346:gcode.c       ****      STEP 3: Error-check all commands and values passed in this block. This step ensures all of
 347:gcode.c       ****      the commands are valid for execution and follows the NIST standard as closely as possible.
 348:gcode.c       ****      If an error is found, all commands and values in this block are dumped and will not update
 349:gcode.c       ****      the active system g-code modes. If the block is ok, the active system g-code modes will be
 350:gcode.c       ****      updated based on the commands of this block, and signal for it to be executed.
 351:gcode.c       **** 
 352:gcode.c       ****      Also, we have to pre-convert all of the values passed based on the modes set by the parsed
 353:gcode.c       ****      block. There are a number of error-checks that require target information that can only be
 354:gcode.c       ****      accurately calculated if we convert these values in conjunction with the error-checking.
 355:gcode.c       ****      This relegates the next execution step as only updating the system g-code modes and
 356:gcode.c       ****      performing the programmed actions in order. The execution step should not require any
 357:gcode.c       ****      conversion calculations and would only require minimal checks necessary to execute.
 358:gcode.c       ****   */
 359:gcode.c       **** 
 360:gcode.c       ****   /* NOTE: At this point, the g-code block has been parsed and the block line can be freed.
 361:gcode.c       ****      NOTE: It's also possible, at some future point, to break up STEP 2, to allow piece-wise
 362:gcode.c       ****      parsing of the block on a per-word basis, rather than the entire block. This could remove
 363:gcode.c       ****      the need for maintaining a large string variable for the entire block and free up some memory.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 28


 364:gcode.c       ****      To do this, this would simply need to retain all of the data in STEP 1, such as the new block
 365:gcode.c       ****      data struct, the modal group and value bitflag tracking variables, and axis array indices
 366:gcode.c       ****      compatible variables. This data contains all of the information necessary to error-check the
 367:gcode.c       ****      new g-code block when the EOL character is received. However, this would break Grbl's startup
 368:gcode.c       ****      lines in how it currently works and would require some refactoring to make it compatible.
 369:gcode.c       ****   */
 370:gcode.c       **** 
 371:gcode.c       ****   // [0. Non-specific/common error-checks and miscellaneous setup]:
 372:gcode.c       **** 
 373:gcode.c       ****   // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
 374:gcode.c       ****   // command has been sent. If so, set axis command to current motion mode.
 375:gcode.c       ****   if (axis_words) {
 1161              		.loc 1 375 0
 1162 08bc 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1163 08c0 002B     		cmp	r3, #0
 1164 08c2 06D0     		beq	.L96
 376:gcode.c       ****     if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
 1165              		.loc 1 376 0
 1166 08c4 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 1167 08c8 002B     		cmp	r3, #0
 1168 08ca 02D1     		bne	.L96
 1169              		.loc 1 376 0 is_stmt 0 discriminator 1
 1170 08cc 0223     		movs	r3, #2
 1171 08ce 87F85730 		strb	r3, [r7, #87]
 1172              	.L96:
 377:gcode.c       ****   }
 378:gcode.c       **** 
 379:gcode.c       ****   // Check for valid line number N value.
 380:gcode.c       ****   if (bit_istrue(value_words,bit(WORD_N))) {
 1173              		.loc 1 380 0 is_stmt 1
 1174 08d2 B7F84C30 		ldrh	r3, [r7, #76]
 1175 08d6 03F02003 		and	r3, r3, #32
 1176 08da 002B     		cmp	r3, #0
 1177 08dc 07D0     		beq	.L97
 381:gcode.c       ****     // Line number value cannot be less than zero (done) or greater than max line number.
 382:gcode.c       ****     if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceed
 1178              		.loc 1 382 0
 1179 08de 4C4B     		ldr	r3, .L283+8
 1180 08e0 1B6A     		ldr	r3, [r3, #32]
 1181 08e2 4D4A     		ldr	r2, .L283+16
 1182 08e4 9342     		cmp	r3, r2
 1183 08e6 02DD     		ble	.L97
 1184              		.loc 1 382 0 is_stmt 0 discriminator 1
 1185 08e8 1B23     		movs	r3, #27
 1186 08ea 01F0D8B8 		b	.L251
 1187              	.L97:
 383:gcode.c       ****   }
 384:gcode.c       ****   // bit_false(value_words,bit(WORD_N)); // NOTE: Single-meaning value word. Set at end of error-ch
 385:gcode.c       **** 
 386:gcode.c       ****   // Track for unused words at the end of error-checking.
 387:gcode.c       ****   // NOTE: Single-meaning value words are removed all at once at the end of error-checking, because
 388:gcode.c       ****   // they are always used when present. This was done to save a few bytes of flash. For clarity, th
 389:gcode.c       ****   // single-meaning value words may be removed as they are used. Also, axis words are treated in th
 390:gcode.c       ****   // same way. If there is an explicit/implicit axis command, XYZ words are always used and are
 391:gcode.c       ****   // are removed at the end of error-checking.
 392:gcode.c       **** 
 393:gcode.c       ****   // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 29


 394:gcode.c       **** 
 395:gcode.c       ****   // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Fe
 396:gcode.c       ****   //   is not defined after switching to G94 from G93.
 397:gcode.c       ****   // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
 398:gcode.c       ****   if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 1188              		.loc 1 398 0 is_stmt 1
 1189 08ee 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 1190 08f2 03F00103 		and	r3, r3, #1
 1191 08f6 002B     		cmp	r3, #0
 1192 08f8 20D0     		beq	.L98
 399:gcode.c       ****     if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
 1193              		.loc 1 399 0
 1194 08fa B7F84C30 		ldrh	r3, [r7, #76]
 1195 08fe 03F00103 		and	r3, r3, #1
 1196 0902 002B     		cmp	r3, #0
 1197 0904 02D1     		bne	.L99
 1198              		.loc 1 399 0 is_stmt 0 discriminator 1
 1199 0906 1623     		movs	r3, #22
 1200 0908 01F0C9B8 		b	.L251
 1201              	.L99:
 400:gcode.c       ****     if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 1202              		.loc 1 400 0 is_stmt 1
 1203 090c 404B     		ldr	r3, .L283+8
 1204 090e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1205 0910 012B     		cmp	r3, #1
 1206 0912 52D1     		bne	.L101
 1207              		.loc 1 400 0 is_stmt 0 discriminator 1
 1208 0914 3E4B     		ldr	r3, .L283+8
 1209 0916 DB68     		ldr	r3, [r3, #12]	@ float
 1210 0918 1846     		mov	r0, r3
 1211 091a FFF7FEFF 		bl	__aeabi_f2d
 1212 091e 3AA3     		adr	r3, .L283
 1213 0920 D3E90023 		ldrd	r2, [r3]
 1214 0924 FFF7FEFF 		bl	__aeabi_dmul
 1215 0928 0246     		mov	r2, r0
 1216 092a 0B46     		mov	r3, r1
 1217 092c 1046     		mov	r0, r2
 1218 092e 1946     		mov	r1, r3
 1219 0930 FFF7FEFF 		bl	__aeabi_d2f
 1220 0934 0246     		mov	r2, r0
 1221 0936 364B     		ldr	r3, .L283+8
 1222 0938 DA60     		str	r2, [r3, #12]	@ float
 1223 093a 3EE0     		b	.L101
 1224              	.L98:
 401:gcode.c       ****   } else {
 402:gcode.c       ****     if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
 1225              		.loc 1 402 0 is_stmt 1
 1226 093c 344B     		ldr	r3, .L283+8
 1227 093e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1228 0940 012B     		cmp	r3, #1
 1229 0942 14D1     		bne	.L102
 403:gcode.c       ****       // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word c
 404:gcode.c       ****       if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 1230              		.loc 1 404 0
 1231 0944 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 1232 0948 022B     		cmp	r3, #2
 1233 094a 36D1     		bne	.L101
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 30


 405:gcode.c       ****         if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SE
 1234              		.loc 1 405 0
 1235 094c 304B     		ldr	r3, .L283+8
 1236 094e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1237 0950 502B     		cmp	r3, #80
 1238 0952 03D1     		bne	.L103
 1239              		.loc 1 405 0 is_stmt 0 discriminator 1
 1240 0954 2E4B     		ldr	r3, .L283+8
 1241 0956 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1242 0958 002B     		cmp	r3, #0
 1243 095a 2ED0     		beq	.L101
 1244              	.L103:
 406:gcode.c       ****           if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // 
 1245              		.loc 1 406 0 is_stmt 1
 1246 095c B7F84C30 		ldrh	r3, [r7, #76]
 1247 0960 03F00103 		and	r3, r3, #1
 1248 0964 002B     		cmp	r3, #0
 1249 0966 28D1     		bne	.L101
 1250              		.loc 1 406 0 is_stmt 0 discriminator 1
 1251 0968 1623     		movs	r3, #22
 1252 096a 01F098B8 		b	.L251
 1253              	.L102:
 407:gcode.c       ****         }
 408:gcode.c       ****       }
 409:gcode.c       ****       // NOTE: It seems redundant to check for an F word to be passed after switching from G94 to G
 410:gcode.c       ****       // accomplish the exact same thing if the feed rate value is always reset to zero and undefin
 411:gcode.c       ****       // inverse time block, since the commands that use this value already perform undefined check
 412:gcode.c       ****       // also allow other commands, following this switch, to execute and not error out needlessly.
 413:gcode.c       ****       // combined with the above feed rate mode and the below set feed rate error-checking.
 414:gcode.c       **** 
 415:gcode.c       ****       // [3. Set feed rate ]: F is negative (done.)
 416:gcode.c       ****       // - In inverse time mode: Always implicitly zero the feed rate value before and after block 
 417:gcode.c       ****       // NOTE: If in G93 mode or switched into it from G94, just keep F value as initialized zero o
 418:gcode.c       ****       // value in the block. If no F word is passed with a motion command that requires a feed rate
 419:gcode.c       ****       // out in the motion modes error-checking. However, if no F word is passed with NO motion com
 420:gcode.c       ****       // a feed rate, we simply move on and the state feed rate value gets updated to zero and rema
 421:gcode.c       ****     } else { // = G94
 422:gcode.c       ****       // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last s
 423:gcode.c       ****       if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
 1254              		.loc 1 423 0 is_stmt 1
 1255 096e 2B4B     		ldr	r3, .L283+20
 1256 0970 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1257 0972 002B     		cmp	r3, #0
 1258 0974 21D1     		bne	.L101
 424:gcode.c       ****         if (bit_istrue(value_words,bit(WORD_F))) {
 1259              		.loc 1 424 0
 1260 0976 B7F84C30 		ldrh	r3, [r7, #76]
 1261 097a 03F00103 		and	r3, r3, #1
 1262 097e 002B     		cmp	r3, #0
 1263 0980 17D0     		beq	.L104
 425:gcode.c       ****           if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 1264              		.loc 1 425 0
 1265 0982 234B     		ldr	r3, .L283+8
 1266 0984 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1267 0986 012B     		cmp	r3, #1
 1268 0988 17D1     		bne	.L101
 1269              		.loc 1 425 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 31


 1270 098a 214B     		ldr	r3, .L283+8
 1271 098c DB68     		ldr	r3, [r3, #12]	@ float
 1272 098e 1846     		mov	r0, r3
 1273 0990 FFF7FEFF 		bl	__aeabi_f2d
 1274 0994 1CA3     		adr	r3, .L283
 1275 0996 D3E90023 		ldrd	r2, [r3]
 1276 099a FFF7FEFF 		bl	__aeabi_dmul
 1277 099e 0246     		mov	r2, r0
 1278 09a0 0B46     		mov	r3, r1
 1279 09a2 1046     		mov	r0, r2
 1280 09a4 1946     		mov	r1, r3
 1281 09a6 FFF7FEFF 		bl	__aeabi_d2f
 1282 09aa 0246     		mov	r2, r0
 1283 09ac 184B     		ldr	r3, .L283+8
 1284 09ae DA60     		str	r2, [r3, #12]	@ float
 1285 09b0 03E0     		b	.L101
 1286              	.L104:
 426:gcode.c       ****         } else {
 427:gcode.c       ****           gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 1287              		.loc 1 427 0 is_stmt 1
 1288 09b2 1A4B     		ldr	r3, .L283+20
 1289 09b4 1B69     		ldr	r3, [r3, #16]	@ float
 1290 09b6 164A     		ldr	r2, .L283+8
 1291 09b8 D360     		str	r3, [r2, #12]	@ float
 1292              	.L101:
 428:gcode.c       ****         }
 429:gcode.c       ****       } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or th
 430:gcode.c       ****     }
 431:gcode.c       ****   }
 432:gcode.c       ****   // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-ch
 433:gcode.c       **** 
 434:gcode.c       ****   // [4. Set spindle speed ]: S is negative (done.)
 435:gcode.c       ****   if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
 1293              		.loc 1 435 0
 1294 09ba B7F84C30 		ldrh	r3, [r7, #76]
 1295 09be 03F48073 		and	r3, r3, #256
 1296 09c2 002B     		cmp	r3, #0
 1297 09c4 03D1     		bne	.L106
 1298              		.loc 1 435 0 is_stmt 0 discriminator 1
 1299 09c6 154B     		ldr	r3, .L283+20
 1300 09c8 DB68     		ldr	r3, [r3, #12]	@ float
 1301 09ca 114A     		ldr	r2, .L283+8
 1302 09cc D362     		str	r3, [r2, #44]	@ float
 1303              	.L106:
 436:gcode.c       ****   // bit_false(value_words,bit(WORD_S)); // NOTE: Single-meaning value word. Set at end of error-ch
 437:gcode.c       **** 
 438:gcode.c       ****   // [5. Select tool ]: NOT SUPPORTED. Only tracks value. T is negative (done.) Not an integer. Gre
 439:gcode.c       ****   // bit_false(value_words,bit(WORD_T)); // NOTE: Single-meaning value word. Set at end of error-ch
 440:gcode.c       **** 
 441:gcode.c       ****   // [6. Change tool ]: N/A
 442:gcode.c       ****   // [7. Spindle control ]: N/A
 443:gcode.c       ****   // [8. Coolant control ]: N/A
 444:gcode.c       ****   // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
 445:gcode.c       **** 
 446:gcode.c       ****   // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
 447:gcode.c       ****   if (gc_block.non_modal_command == NON_MODAL_DWELL) {
 1304              		.loc 1 447 0 is_stmt 1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 32


 1305 09ce 104B     		ldr	r3, .L283+8
 1306 09d0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1307 09d2 042B     		cmp	r3, #4
 1308 09d4 0ED1     		bne	.L107
 448:gcode.c       ****     if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word
 1309              		.loc 1 448 0
 1310 09d6 B7F84C30 		ldrh	r3, [r7, #76]
 1311 09da 03F04003 		and	r3, r3, #64
 1312 09de 002B     		cmp	r3, #0
 1313 09e0 02D1     		bne	.L108
 1314              		.loc 1 448 0 is_stmt 0 discriminator 1
 1315 09e2 1C23     		movs	r3, #28
 1316 09e4 01F05BB8 		b	.L251
 1317              	.L108:
 449:gcode.c       ****     bit_false(value_words,bit(WORD_P));
 1318              		.loc 1 449 0 is_stmt 1
 1319 09e8 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 1320 09ec 23F04003 		bic	r3, r3, #64
 1321 09f0 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 1322              	.L107:
 450:gcode.c       ****   }
 451:gcode.c       **** 
 452:gcode.c       ****   // [11. Set active plane ]: N/A
 453:gcode.c       ****   switch (gc_block.modal.plane_select) {
 1323              		.loc 1 453 0
 1324 09f4 064B     		ldr	r3, .L283+8
 1325 09f6 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1326 09f8 002B     		cmp	r3, #0
 1327 09fa 11D0     		beq	.L110
 1328 09fc 012B     		cmp	r3, #1
 1329 09fe 19D0     		beq	.L111
 1330 0a00 22E0     		b	.L264
 1331              	.L284:
 1332 0a02 00BFAFF3 		.align	3
 1332      0080
 1333              	.L283:
 1334 0a08 66666666 		.word	1717986918
 1335 0a0c 66663940 		.word	1077503590
 1336 0a10 00000000 		.word	gc_block
 1337 0a14 00007F43 		.word	1132396544
 1338 0a18 80969800 		.word	10000000
 1339 0a1c 00000000 		.word	gc_state
 1340              	.L110:
 454:gcode.c       ****     case PLANE_SELECT_XY:
 455:gcode.c       ****       axis_0 = X_AXIS;
 1341              		.loc 1 455 0
 1342 0a20 0023     		movs	r3, #0
 1343 0a22 87F85630 		strb	r3, [r7, #86]
 456:gcode.c       ****       axis_1 = Y_AXIS;
 1344              		.loc 1 456 0
 1345 0a26 0123     		movs	r3, #1
 1346 0a28 87F85530 		strb	r3, [r7, #85]
 457:gcode.c       ****       axis_linear = Z_AXIS;
 1347              		.loc 1 457 0
 1348 0a2c 0223     		movs	r3, #2
 1349 0a2e 87F85430 		strb	r3, [r7, #84]
 458:gcode.c       ****       break;
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 33


 1350              		.loc 1 458 0
 1351 0a32 12E0     		b	.L112
 1352              	.L111:
 459:gcode.c       ****     case PLANE_SELECT_ZX:
 460:gcode.c       ****       axis_0 = Z_AXIS;
 1353              		.loc 1 460 0
 1354 0a34 0223     		movs	r3, #2
 1355 0a36 87F85630 		strb	r3, [r7, #86]
 461:gcode.c       ****       axis_1 = X_AXIS;
 1356              		.loc 1 461 0
 1357 0a3a 0023     		movs	r3, #0
 1358 0a3c 87F85530 		strb	r3, [r7, #85]
 462:gcode.c       ****       axis_linear = Y_AXIS;
 1359              		.loc 1 462 0
 1360 0a40 0123     		movs	r3, #1
 1361 0a42 87F85430 		strb	r3, [r7, #84]
 463:gcode.c       ****       break;
 1362              		.loc 1 463 0
 1363 0a46 08E0     		b	.L112
 1364              	.L264:
 464:gcode.c       ****     default: // case PLANE_SELECT_YZ:
 465:gcode.c       ****       axis_0 = Y_AXIS;
 1365              		.loc 1 465 0
 1366 0a48 0123     		movs	r3, #1
 1367 0a4a 87F85630 		strb	r3, [r7, #86]
 466:gcode.c       ****       axis_1 = Z_AXIS;
 1368              		.loc 1 466 0
 1369 0a4e 0223     		movs	r3, #2
 1370 0a50 87F85530 		strb	r3, [r7, #85]
 467:gcode.c       ****       axis_linear = X_AXIS;
 1371              		.loc 1 467 0
 1372 0a54 0023     		movs	r3, #0
 1373 0a56 87F85430 		strb	r3, [r7, #84]
 1374              	.L112:
 468:gcode.c       ****   }
 469:gcode.c       **** 
 470:gcode.c       ****   // [12. Set length units ]: N/A
 471:gcode.c       ****   // Pre-convert XYZ coordinate values to millimeters, if applicable.
 472:gcode.c       ****   uint8_t idx;
 473:gcode.c       ****   if (gc_block.modal.units == UNITS_MODE_INCHES) {
 1375              		.loc 1 473 0
 1376 0a5a A94B     		ldr	r3, .L285+8
 1377 0a5c DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1378 0a5e 012B     		cmp	r3, #1
 1379 0a60 34D1     		bne	.L113
 474:gcode.c       ****     for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 1380              		.loc 1 474 0
 1381 0a62 0023     		movs	r3, #0
 1382 0a64 87F84730 		strb	r3, [r7, #71]
 1383 0a68 2CE0     		b	.L114
 1384              	.L116:
 475:gcode.c       ****       if (bit_istrue(axis_words,bit(idx)) ) {
 1385              		.loc 1 475 0
 1386 0a6a 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 1387 0a6e 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1388 0a72 42FA03F3 		asr	r3, r2, r3
 1389 0a76 03F00103 		and	r3, r3, #1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 34


 1390 0a7a 002B     		cmp	r3, #0
 1391 0a7c 1DD0     		beq	.L115
 476:gcode.c       ****         gc_block.values.xyz[idx] *= MM_PER_INCH;
 1392              		.loc 1 476 0
 1393 0a7e 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1394 0a82 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1395 0a86 9E4A     		ldr	r2, .L285+8
 1396 0a88 0C33     		adds	r3, r3, #12
 1397 0a8a 9B00     		lsls	r3, r3, #2
 1398 0a8c 1344     		add	r3, r3, r2
 1399 0a8e 5B68     		ldr	r3, [r3, #4]	@ float
 1400 0a90 1846     		mov	r0, r3
 1401 0a92 FFF7FEFF 		bl	__aeabi_f2d
 1402 0a96 98A3     		adr	r3, .L285
 1403 0a98 D3E90023 		ldrd	r2, [r3]
 1404 0a9c FFF7FEFF 		bl	__aeabi_dmul
 1405 0aa0 0246     		mov	r2, r0
 1406 0aa2 0B46     		mov	r3, r1
 1407 0aa4 1046     		mov	r0, r2
 1408 0aa6 1946     		mov	r1, r3
 1409 0aa8 FFF7FEFF 		bl	__aeabi_d2f
 1410 0aac 0146     		mov	r1, r0
 1411 0aae 944A     		ldr	r2, .L285+8
 1412 0ab0 06F10C03 		add	r3, r6, #12
 1413 0ab4 9B00     		lsls	r3, r3, #2
 1414 0ab6 1344     		add	r3, r3, r2
 1415 0ab8 5960     		str	r1, [r3, #4]	@ float
 1416              	.L115:
 474:gcode.c       ****     for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 1417              		.loc 1 474 0 discriminator 2
 1418 0aba 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1419 0abe 0133     		adds	r3, r3, #1
 1420 0ac0 87F84730 		strb	r3, [r7, #71]
 1421              	.L114:
 474:gcode.c       ****     for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 1422              		.loc 1 474 0 is_stmt 0 discriminator 1
 1423 0ac4 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1424 0ac8 022B     		cmp	r3, #2
 1425 0aca CED9     		bls	.L116
 1426              	.L113:
 477:gcode.c       ****       }
 478:gcode.c       ****     }
 479:gcode.c       ****   }
 480:gcode.c       **** 
 481:gcode.c       ****   // [13. Cutter radius compensation ]: G41/42 NOT SUPPORTED. Error, if enabled while G53 is active
 482:gcode.c       ****   // [G40 Errors]: G2/3 arc is programmed after a G40. The linear move after disabling is less than
 483:gcode.c       ****   //   NOTE: Since cutter radius compensation is never enabled, these G40 errors don't apply. Grbl 
 484:gcode.c       ****   //   only for the purpose to not error when G40 is sent with a g-code program header to setup the
 485:gcode.c       **** 
 486:gcode.c       ****   // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
 487:gcode.c       ****   // [G43.1 Errors]: Motion command in same line.
 488:gcode.c       ****   //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
 489:gcode.c       ****   //   axis that is configured (in config.h). There should be an error if the configured axis
 490:gcode.c       ****   //   is absent or if any of the other axis words are present.
 491:gcode.c       ****   if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
 1427              		.loc 1 491 0 is_stmt 1
 1428 0acc 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 35


 1429 0ad0 032B     		cmp	r3, #3
 1430 0ad2 0AD1     		bne	.L117
 492:gcode.c       ****     if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
 1431              		.loc 1 492 0
 1432 0ad4 8A4B     		ldr	r3, .L285+8
 1433 0ad6 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1434 0ad8 012B     		cmp	r3, #1
 1435 0ada 06D1     		bne	.L117
 493:gcode.c       ****       if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
 1436              		.loc 1 493 0
 1437 0adc 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1438 0ae0 042B     		cmp	r3, #4
 1439 0ae2 02D0     		beq	.L117
 1440              		.loc 1 493 0 is_stmt 0 discriminator 1
 1441 0ae4 2523     		movs	r3, #37
 1442 0ae6 00F0DABF 		b	.L251
 1443              	.L117:
 494:gcode.c       ****     }
 495:gcode.c       ****   }
 496:gcode.c       **** 
 497:gcode.c       ****   // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
 498:gcode.c       ****   // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
 499:gcode.c       ****   // is active. The read pauses the processor temporarily and may cause a rare crash. For
 500:gcode.c       ****   // future versions on processors with enough memory, all coordinate data should be stored
 501:gcode.c       ****   // in memory and written to EEPROM only when there is not a cycle active.
 502:gcode.c       ****   float block_coord_system[N_AXIS];
 503:gcode.c       ****   memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
 1444              		.loc 1 503 0 is_stmt 1
 1445 0aea 864A     		ldr	r2, .L285+12
 1446 0aec 07F11403 		add	r3, r7, #20
 1447 0af0 2832     		adds	r2, r2, #40
 1448 0af2 07CA     		ldmia	r2, {r0, r1, r2}
 1449 0af4 83E80700 		stmia	r3, {r0, r1, r2}
 504:gcode.c       ****   if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
 1450              		.loc 1 504 0
 1451 0af8 B7F84E30 		ldrh	r3, [r7, #78]
 1452 0afc 03F40073 		and	r3, r3, #512
 1453 0b00 002B     		cmp	r3, #0
 1454 0b02 1AD0     		beq	.L118
 505:gcode.c       ****     if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SY
 1455              		.loc 1 505 0
 1456 0b04 7E4B     		ldr	r3, .L285+8
 1457 0b06 DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 1458 0b08 062B     		cmp	r3, #6
 1459 0b0a 02D9     		bls	.L119
 1460              		.loc 1 505 0 is_stmt 0 discriminator 1
 1461 0b0c 1D23     		movs	r3, #29
 1462 0b0e 00F0C6BF 		b	.L251
 1463              	.L119:
 506:gcode.c       ****     if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 1464              		.loc 1 506 0 is_stmt 1
 1465 0b12 7C4B     		ldr	r3, .L285+12
 1466 0b14 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1467 0b16 7A4B     		ldr	r3, .L285+8
 1468 0b18 DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 1469 0b1a 9A42     		cmp	r2, r3
 1470 0b1c 0DD0     		beq	.L118
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 36


 507:gcode.c       ****       if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATU
 1471              		.loc 1 507 0
 1472 0b1e 784B     		ldr	r3, .L285+8
 1473 0b20 DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 1474 0b22 07F11402 		add	r2, r7, #20
 1475 0b26 1146     		mov	r1, r2
 1476 0b28 1846     		mov	r0, r3
 1477 0b2a FFF7FEFF 		bl	settings_read_coord_data
 1478 0b2e 0346     		mov	r3, r0
 1479 0b30 002B     		cmp	r3, #0
 1480 0b32 02D1     		bne	.L118
 1481              		.loc 1 507 0 is_stmt 0 discriminator 1
 1482 0b34 0723     		movs	r3, #7
 1483 0b36 00F0B2BF 		b	.L251
 1484              	.L118:
 508:gcode.c       ****     }
 509:gcode.c       ****   }
 510:gcode.c       **** 
 511:gcode.c       ****   // [16. Set path control mode ]: N/A. Only G61. G61.1 and G64 NOT SUPPORTED.
 512:gcode.c       ****   // [17. Set distance mode ]: N/A. Only G91.1. G90.1 NOT SUPPORTED.
 513:gcode.c       ****   // [18. Set retract mode ]: NOT SUPPORTED.
 514:gcode.c       **** 
 515:gcode.c       ****   // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offs
 516:gcode.c       ****   // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), a
 517:gcode.c       ****   // commands all treat axis words differently. G10 as absolute offsets or computes current positio
 518:gcode.c       ****   // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that o
 519:gcode.c       ****   // all the current coordinate system and G92 offsets.
 520:gcode.c       ****   switch (gc_block.non_modal_command) {
 1485              		.loc 1 520 0 is_stmt 1
 1486 0b3a 714B     		ldr	r3, .L285+8
 1487 0b3c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1488 0b3e 0A2B     		cmp	r3, #10
 1489 0b40 03D0     		beq	.L121
 1490 0b42 5C2B     		cmp	r3, #92
 1491 0b44 00F0CB80 		beq	.L122
 1492 0b48 48E1     		b	.L265
 1493              	.L121:
 521:gcode.c       ****     case NON_MODAL_SET_COORDINATE_DATA:
 522:gcode.c       ****       // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
 523:gcode.c       ****       // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missi
 524:gcode.c       ****       // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
 525:gcode.c       ****       if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
 1494              		.loc 1 525 0
 1495 0b4a 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1496 0b4e 002B     		cmp	r3, #0
 1497 0b50 02D1     		bne	.L123
 1498              		.loc 1 525 0 is_stmt 0 discriminator 1
 1499 0b52 1A23     		movs	r3, #26
 1500 0b54 00F0A3BF 		b	.L251
 1501              	.L123:
 526:gcode.c       ****       if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSIN
 1502              		.loc 1 526 0 is_stmt 1
 1503 0b58 B7F84C30 		ldrh	r3, [r7, #76]
 1504 0b5c 03F05003 		and	r3, r3, #80
 1505 0b60 002B     		cmp	r3, #0
 1506 0b62 02D1     		bne	.L124
 1507              		.loc 1 526 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 37


 1508 0b64 1C23     		movs	r3, #28
 1509 0b66 00F09ABF 		b	.L251
 1510              	.L124:
 527:gcode.c       ****       coord_select = trunc(gc_block.values.p); // Convert p value to int.
 1511              		.loc 1 527 0 is_stmt 1
 1512 0b6a 654B     		ldr	r3, .L285+8
 1513 0b6c 5B6A     		ldr	r3, [r3, #36]	@ float
 1514 0b6e 1846     		mov	r0, r3
 1515 0b70 FFF7FEFF 		bl	__aeabi_f2d
 1516 0b74 0246     		mov	r2, r0
 1517 0b76 0B46     		mov	r3, r1
 1518 0b78 1046     		mov	r0, r2
 1519 0b7a 1946     		mov	r1, r3
 1520 0b7c FFF7FEFF 		bl	trunc
 1521 0b80 0246     		mov	r2, r0
 1522 0b82 0B46     		mov	r3, r1
 1523 0b84 1046     		mov	r0, r2
 1524 0b86 1946     		mov	r1, r3
 1525 0b88 FFF7FEFF 		bl	__aeabi_d2uiz
 1526 0b8c 0346     		mov	r3, r0
 1527 0b8e 87F85330 		strb	r3, [r7, #83]
 528:gcode.c       ****       if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Gre
 1528              		.loc 1 528 0
 1529 0b92 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 1530 0b96 062B     		cmp	r3, #6
 1531 0b98 02D9     		bls	.L125
 1532              		.loc 1 528 0 is_stmt 0 discriminator 1
 1533 0b9a 1D23     		movs	r3, #29
 1534 0b9c 00F07FBF 		b	.L251
 1535              	.L125:
 529:gcode.c       ****       if (gc_block.values.l != 20) {
 1536              		.loc 1 529 0 is_stmt 1
 1537 0ba0 574B     		ldr	r3, .L285+8
 1538 0ba2 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1539 0ba4 142B     		cmp	r3, #20
 1540 0ba6 0FD0     		beq	.L126
 530:gcode.c       ****         if (gc_block.values.l == 2) {
 1541              		.loc 1 530 0
 1542 0ba8 554B     		ldr	r3, .L285+8
 1543 0baa 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1544 0bac 022B     		cmp	r3, #2
 1545 0bae 08D1     		bne	.L127
 531:gcode.c       ****           if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [
 1546              		.loc 1 531 0
 1547 0bb0 B7F84C30 		ldrh	r3, [r7, #76]
 1548 0bb4 03F08003 		and	r3, r3, #128
 1549 0bb8 002B     		cmp	r3, #0
 1550 0bba 05D0     		beq	.L126
 1551              		.loc 1 531 0 is_stmt 0 discriminator 1
 1552 0bbc 1423     		movs	r3, #20
 1553 0bbe 00F06EBF 		b	.L251
 1554              	.L127:
 532:gcode.c       ****         } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
 1555              		.loc 1 532 0 is_stmt 1
 1556 0bc2 1423     		movs	r3, #20
 1557 0bc4 00F06BBF 		b	.L251
 1558              	.L126:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 38


 533:gcode.c       ****       }
 534:gcode.c       ****       bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
 1559              		.loc 1 534 0
 1560 0bc8 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 1561 0bcc 23F05003 		bic	r3, r3, #80
 1562 0bd0 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 535:gcode.c       **** 
 536:gcode.c       ****       // Determine coordinate system to change and try to load from EEPROM.
 537:gcode.c       ****       if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data ind
 1563              		.loc 1 537 0
 1564 0bd4 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 1565 0bd8 002B     		cmp	r3, #0
 1566 0bda 05D0     		beq	.L128
 1567              		.loc 1 537 0 is_stmt 0 discriminator 1
 1568 0bdc 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 1569 0be0 013B     		subs	r3, r3, #1
 1570 0be2 87F85330 		strb	r3, [r7, #83]
 1571 0be6 03E0     		b	.L129
 1572              	.L128:
 538:gcode.c       ****       else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate sys
 1573              		.loc 1 538 0 is_stmt 1
 1574 0be8 454B     		ldr	r3, .L285+8
 1575 0bea DB79     		ldrb	r3, [r3, #7]
 1576 0bec 87F85330 		strb	r3, [r7, #83]
 1577              	.L129:
 539:gcode.c       ****       
 540:gcode.c       ****       // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
 541:gcode.c       ****       // FIXME: Instead of IJK, we'd better use: float vector[N_AXIS]; // [DG]
 542:gcode.c       ****       if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_F
 1578              		.loc 1 542 0
 1579 0bf0 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 1580 0bf4 4449     		ldr	r1, .L285+16
 1581 0bf6 1846     		mov	r0, r3
 1582 0bf8 FFF7FEFF 		bl	settings_read_coord_data
 1583 0bfc 0346     		mov	r3, r0
 1584 0bfe 002B     		cmp	r3, #0
 1585 0c00 02D1     		bne	.L130
 1586              		.loc 1 542 0 is_stmt 0 discriminator 1
 1587 0c02 0723     		movs	r3, #7
 1588 0c04 00F04BBF 		b	.L251
 1589              	.L130:
 543:gcode.c       **** 
 544:gcode.c       ****       // Pre-calculate the coordinate data changes.
 545:gcode.c       ****       for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 1590              		.loc 1 545 0 is_stmt 1
 1591 0c08 0023     		movs	r3, #0
 1592 0c0a 87F84730 		strb	r3, [r7, #71]
 1593 0c0e 61E0     		b	.L131
 1594              	.L135:
 546:gcode.c       ****         // Update axes defined only in block. Always in machine coordinates. Can change non-active 
 547:gcode.c       ****         if (bit_istrue(axis_words,bit(idx)) ) {
 1595              		.loc 1 547 0
 1596 0c10 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 1597 0c14 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1598 0c18 42FA03F3 		asr	r3, r2, r3
 1599 0c1c 03F00103 		and	r3, r3, #1
 1600 0c20 002B     		cmp	r3, #0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 39


 1601 0c22 52D0     		beq	.L132
 548:gcode.c       ****           if (gc_block.values.l == 20) {
 1602              		.loc 1 548 0
 1603 0c24 364B     		ldr	r3, .L285+8
 1604 0c26 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1605 0c28 142B     		cmp	r3, #20
 1606 0c2a 40D1     		bne	.L133
 549:gcode.c       ****             // L20: Update coordinate system axis at current position (with modifiers) with program
 550:gcode.c       ****             // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
 551:gcode.c       ****             gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.v
 1607              		.loc 1 551 0
 1608 0c2c 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1609 0c30 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1610 0c34 334A     		ldr	r2, .L285+12
 1611 0c36 0633     		adds	r3, r3, #6
 1612 0c38 9B00     		lsls	r3, r3, #2
 1613 0c3a 1344     		add	r3, r3, r2
 1614 0c3c 5868     		ldr	r0, [r3, #4]	@ float
 1615 0c3e 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1616 0c42 304A     		ldr	r2, .L285+12
 1617 0c44 0C33     		adds	r3, r3, #12
 1618 0c46 9B00     		lsls	r3, r3, #2
 1619 0c48 1344     		add	r3, r3, r2
 1620 0c4a 5B68     		ldr	r3, [r3, #4]	@ float
 1621 0c4c 1946     		mov	r1, r3
 1622 0c4e FFF7FEFF 		bl	__aeabi_fsub
 1623 0c52 0346     		mov	r3, r0
 1624 0c54 1846     		mov	r0, r3
 1625 0c56 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1626 0c5a 294A     		ldr	r2, .L285+8
 1627 0c5c 0C33     		adds	r3, r3, #12
 1628 0c5e 9B00     		lsls	r3, r3, #2
 1629 0c60 1344     		add	r3, r3, r2
 1630 0c62 5B68     		ldr	r3, [r3, #4]	@ float
 1631 0c64 1946     		mov	r1, r3
 1632 0c66 FFF7FEFF 		bl	__aeabi_fsub
 1633 0c6a 0346     		mov	r3, r0
 1634 0c6c 1946     		mov	r1, r3
 1635 0c6e 244A     		ldr	r2, .L285+8
 1636 0c70 B31C     		adds	r3, r6, #2
 1637 0c72 9B00     		lsls	r3, r3, #2
 1638 0c74 1344     		add	r3, r3, r2
 1639 0c76 9960     		str	r1, [r3, #8]	@ float
 552:gcode.c       ****             if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_
 1640              		.loc 1 552 0
 1641 0c78 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1642 0c7c 022B     		cmp	r3, #2
 1643 0c7e 24D1     		bne	.L132
 1644              		.loc 1 552 0 is_stmt 0 discriminator 1
 1645 0c80 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1646 0c84 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1647 0c88 1D4A     		ldr	r2, .L285+8
 1648 0c8a 0233     		adds	r3, r3, #2
 1649 0c8c 9B00     		lsls	r3, r3, #2
 1650 0c8e 1344     		add	r3, r3, r2
 1651 0c90 9A68     		ldr	r2, [r3, #8]	@ float
 1652 0c92 1C4B     		ldr	r3, .L285+12
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 40


 1653 0c94 1B6C     		ldr	r3, [r3, #64]	@ float
 1654 0c96 1946     		mov	r1, r3
 1655 0c98 1046     		mov	r0, r2
 1656 0c9a FFF7FEFF 		bl	__aeabi_fsub
 1657 0c9e 0346     		mov	r3, r0
 1658 0ca0 1946     		mov	r1, r3
 1659 0ca2 174A     		ldr	r2, .L285+8
 1660 0ca4 B31C     		adds	r3, r6, #2
 1661 0ca6 9B00     		lsls	r3, r3, #2
 1662 0ca8 1344     		add	r3, r3, r2
 1663 0caa 9960     		str	r1, [r3, #8]	@ float
 1664 0cac 0DE0     		b	.L132
 1665              	.L133:
 553:gcode.c       ****           } else {
 554:gcode.c       ****             // L2: Update coordinate system axis to programmed value.
 555:gcode.c       ****             gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
 1666              		.loc 1 555 0 is_stmt 1
 1667 0cae 97F84710 		ldrb	r1, [r7, #71]	@ zero_extendqisi2
 1668 0cb2 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1669 0cb6 124A     		ldr	r2, .L285+8
 1670 0cb8 0C33     		adds	r3, r3, #12
 1671 0cba 9B00     		lsls	r3, r3, #2
 1672 0cbc 1344     		add	r3, r3, r2
 1673 0cbe 5A68     		ldr	r2, [r3, #4]	@ float
 1674 0cc0 0F48     		ldr	r0, .L285+8
 1675 0cc2 8B1C     		adds	r3, r1, #2
 1676 0cc4 9B00     		lsls	r3, r3, #2
 1677 0cc6 0344     		add	r3, r3, r0
 1678 0cc8 9A60     		str	r2, [r3, #8]	@ float
 1679              	.L132:
 545:gcode.c       ****         // Update axes defined only in block. Always in machine coordinates. Can change non-active 
 1680              		.loc 1 545 0 discriminator 2
 1681 0cca 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1682 0cce 0133     		adds	r3, r3, #1
 1683 0cd0 87F84730 		strb	r3, [r7, #71]
 1684              	.L131:
 545:gcode.c       ****         // Update axes defined only in block. Always in machine coordinates. Can change non-active 
 1685              		.loc 1 545 0 is_stmt 0 discriminator 1
 1686 0cd4 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1687 0cd8 022B     		cmp	r3, #2
 1688 0cda 99D9     		bls	.L135
 556:gcode.c       ****           }
 557:gcode.c       ****         } // Else, keep current stored value.
 558:gcode.c       ****       }
 559:gcode.c       ****       break;
 1689              		.loc 1 559 0 is_stmt 1
 1690 0cdc 7FE1     		b	.L136
 1691              	.L122:
 560:gcode.c       ****     case NON_MODAL_SET_COORDINATE_OFFSET:
 561:gcode.c       ****       // [G92 Errors]: No axis words.
 562:gcode.c       ****       if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 1692              		.loc 1 562 0
 1693 0cde 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1694 0ce2 002B     		cmp	r3, #0
 1695 0ce4 02D1     		bne	.L137
 1696              		.loc 1 562 0 is_stmt 0 discriminator 1
 1697 0ce6 1A23     		movs	r3, #26
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 41


 1698 0ce8 00F0D9BE 		b	.L251
 1699              	.L137:
 563:gcode.c       **** 
 564:gcode.c       ****       // Update axes defined only in block. Offsets current system to defined value. Does not updat
 565:gcode.c       ****       // active coordinate system is selected, but is still active unless G92.1 disables it.
 566:gcode.c       ****       for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 1700              		.loc 1 566 0 is_stmt 1
 1701 0cec 0023     		movs	r3, #0
 1702 0cee 87F84730 		strb	r3, [r7, #71]
 1703 0cf2 6EE0     		b	.L138
 1704              	.L286:
 1705 0cf4 AFF30080 		.align	3
 1706              	.L285:
 1707 0cf8 66666666 		.word	1717986918
 1708 0cfc 66663940 		.word	1077503590
 1709 0d00 00000000 		.word	gc_block
 1710 0d04 00000000 		.word	gc_state
 1711 0d08 10000000 		.word	gc_block+16
 1712              	.L142:
 567:gcode.c       ****         if (bit_istrue(axis_words,bit(idx)) ) {
 1713              		.loc 1 567 0
 1714 0d0c 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 1715 0d10 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1716 0d14 42FA03F3 		asr	r3, r2, r3
 1717 0d18 03F00103 		and	r3, r3, #1
 1718 0d1c 002B     		cmp	r3, #0
 1719 0d1e 44D0     		beq	.L139
 568:gcode.c       ****           // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
 569:gcode.c       ****           gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values
 1720              		.loc 1 569 0
 1721 0d20 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1722 0d24 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1723 0d28 BC4A     		ldr	r2, .L287
 1724 0d2a 0633     		adds	r3, r3, #6
 1725 0d2c 9B00     		lsls	r3, r3, #2
 1726 0d2e 1344     		add	r3, r3, r2
 1727 0d30 5A68     		ldr	r2, [r3, #4]	@ float
 1728 0d32 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1729 0d36 9B00     		lsls	r3, r3, #2
 1730 0d38 07F15801 		add	r1, r7, #88
 1731 0d3c 0B44     		add	r3, r3, r1
 1732 0d3e 53F8443C 		ldr	r3, [r3, #-68]	@ float
 1733 0d42 1946     		mov	r1, r3
 1734 0d44 1046     		mov	r0, r2
 1735 0d46 FFF7FEFF 		bl	__aeabi_fsub
 1736 0d4a 0346     		mov	r3, r0
 1737 0d4c 1846     		mov	r0, r3
 1738 0d4e 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1739 0d52 B34A     		ldr	r2, .L287+4
 1740 0d54 0C33     		adds	r3, r3, #12
 1741 0d56 9B00     		lsls	r3, r3, #2
 1742 0d58 1344     		add	r3, r3, r2
 1743 0d5a 5B68     		ldr	r3, [r3, #4]	@ float
 1744 0d5c 1946     		mov	r1, r3
 1745 0d5e FFF7FEFF 		bl	__aeabi_fsub
 1746 0d62 0346     		mov	r3, r0
 1747 0d64 1946     		mov	r1, r3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 42


 1748 0d66 AE4A     		ldr	r2, .L287+4
 1749 0d68 06F10C03 		add	r3, r6, #12
 1750 0d6c 9B00     		lsls	r3, r3, #2
 1751 0d6e 1344     		add	r3, r3, r2
 1752 0d70 5960     		str	r1, [r3, #4]	@ float
 570:gcode.c       ****           if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_of
 1753              		.loc 1 570 0
 1754 0d72 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1755 0d76 022B     		cmp	r3, #2
 1756 0d78 26D1     		bne	.L141
 1757              		.loc 1 570 0 is_stmt 0 discriminator 1
 1758 0d7a 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1759 0d7e 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1760 0d82 A74A     		ldr	r2, .L287+4
 1761 0d84 0C33     		adds	r3, r3, #12
 1762 0d86 9B00     		lsls	r3, r3, #2
 1763 0d88 1344     		add	r3, r3, r2
 1764 0d8a 5A68     		ldr	r2, [r3, #4]	@ float
 1765 0d8c A34B     		ldr	r3, .L287
 1766 0d8e 1B6C     		ldr	r3, [r3, #64]	@ float
 1767 0d90 1946     		mov	r1, r3
 1768 0d92 1046     		mov	r0, r2
 1769 0d94 FFF7FEFF 		bl	__aeabi_fsub
 1770 0d98 0346     		mov	r3, r0
 1771 0d9a 1946     		mov	r1, r3
 1772 0d9c A04A     		ldr	r2, .L287+4
 1773 0d9e 06F10C03 		add	r3, r6, #12
 1774 0da2 9B00     		lsls	r3, r3, #2
 1775 0da4 1344     		add	r3, r3, r2
 1776 0da6 5960     		str	r1, [r3, #4]	@ float
 1777 0da8 0EE0     		b	.L141
 1778              	.L139:
 571:gcode.c       ****         } else {
 572:gcode.c       ****           gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
 1779              		.loc 1 572 0 is_stmt 1
 1780 0daa 97F84710 		ldrb	r1, [r7, #71]	@ zero_extendqisi2
 1781 0dae 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1782 0db2 9A4A     		ldr	r2, .L287
 1783 0db4 0C33     		adds	r3, r3, #12
 1784 0db6 9B00     		lsls	r3, r3, #2
 1785 0db8 1344     		add	r3, r3, r2
 1786 0dba 5A68     		ldr	r2, [r3, #4]	@ float
 1787 0dbc 9848     		ldr	r0, .L287+4
 1788 0dbe 01F10C03 		add	r3, r1, #12
 1789 0dc2 9B00     		lsls	r3, r3, #2
 1790 0dc4 0344     		add	r3, r3, r0
 1791 0dc6 5A60     		str	r2, [r3, #4]	@ float
 1792              	.L141:
 566:gcode.c       ****         if (bit_istrue(axis_words,bit(idx)) ) {
 1793              		.loc 1 566 0 discriminator 2
 1794 0dc8 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1795 0dcc 0133     		adds	r3, r3, #1
 1796 0dce 87F84730 		strb	r3, [r7, #71]
 1797              	.L138:
 566:gcode.c       ****         if (bit_istrue(axis_words,bit(idx)) ) {
 1798              		.loc 1 566 0 is_stmt 0 discriminator 1
 1799 0dd2 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 43


 1800 0dd6 022B     		cmp	r3, #2
 1801 0dd8 98D9     		bls	.L142
 573:gcode.c       ****         }
 574:gcode.c       ****       }
 575:gcode.c       ****       break;
 1802              		.loc 1 575 0 is_stmt 1
 1803 0dda 00E1     		b	.L136
 1804              	.L265:
 576:gcode.c       **** 
 577:gcode.c       ****     default:
 578:gcode.c       **** 
 579:gcode.c       ****       // At this point, the rest of the explicit axis commands treat the axis values as the traditi
 580:gcode.c       ****       // target position with the coordinate system offsets, G92 offsets, absolute override, and di
 581:gcode.c       ****       // modes applied. This includes the motion mode commands. We can now pre-compute the target p
 582:gcode.c       ****       // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
 583:gcode.c       ****       if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
 1805              		.loc 1 583 0
 1806 0ddc 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 1807 0de0 032B     		cmp	r3, #3
 1808 0de2 00F09580 		beq	.L143
 584:gcode.c       ****         if (axis_words) {
 1809              		.loc 1 584 0
 1810 0de6 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1811 0dea 002B     		cmp	r3, #0
 1812 0dec 00F09080 		beq	.L143
 585:gcode.c       ****           for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to s
 1813              		.loc 1 585 0
 1814 0df0 0023     		movs	r3, #0
 1815 0df2 87F84730 		strb	r3, [r7, #71]
 1816 0df6 86E0     		b	.L144
 1817              	.L149:
 586:gcode.c       ****             if ( bit_isfalse(axis_words,bit(idx)) ) {
 1818              		.loc 1 586 0
 1819 0df8 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 1820 0dfc 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1821 0e00 42FA03F3 		asr	r3, r2, r3
 1822 0e04 03F00103 		and	r3, r3, #1
 1823 0e08 002B     		cmp	r3, #0
 1824 0e0a 0FD1     		bne	.L145
 587:gcode.c       ****               gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep sam
 1825              		.loc 1 587 0
 1826 0e0c 97F84710 		ldrb	r1, [r7, #71]	@ zero_extendqisi2
 1827 0e10 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1828 0e14 814A     		ldr	r2, .L287
 1829 0e16 0633     		adds	r3, r3, #6
 1830 0e18 9B00     		lsls	r3, r3, #2
 1831 0e1a 1344     		add	r3, r3, r2
 1832 0e1c 5A68     		ldr	r2, [r3, #4]	@ float
 1833 0e1e 8048     		ldr	r0, .L287+4
 1834 0e20 01F10C03 		add	r3, r1, #12
 1835 0e24 9B00     		lsls	r3, r3, #2
 1836 0e26 0344     		add	r3, r3, r0
 1837 0e28 5A60     		str	r2, [r3, #4]	@ float
 1838 0e2a 67E0     		b	.L146
 1839              	.L145:
 588:gcode.c       ****             } else {
 589:gcode.c       ****               // Update specified value according to distance mode or ignore if absolute override i
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 44


 590:gcode.c       ****               // NOTE: G53 is never active with G28/30 since they are in the same modal group.
 591:gcode.c       ****               if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
 1840              		.loc 1 591 0
 1841 0e2c 7C4B     		ldr	r3, .L287+4
 1842 0e2e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1843 0e30 352B     		cmp	r3, #53
 1844 0e32 63D0     		beq	.L146
 592:gcode.c       ****                 // Apply coordinate offsets based on distance mode.
 593:gcode.c       ****                 if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
 1845              		.loc 1 593 0
 1846 0e34 7A4B     		ldr	r3, .L287+4
 1847 0e36 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1848 0e38 002B     		cmp	r3, #0
 1849 0e3a 44D1     		bne	.L147
 594:gcode.c       ****                   gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
 1850              		.loc 1 594 0
 1851 0e3c 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1852 0e40 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1853 0e44 764A     		ldr	r2, .L287+4
 1854 0e46 0C33     		adds	r3, r3, #12
 1855 0e48 9B00     		lsls	r3, r3, #2
 1856 0e4a 1344     		add	r3, r3, r2
 1857 0e4c D3F80480 		ldr	r8, [r3, #4]	@ float
 1858 0e50 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1859 0e54 9B00     		lsls	r3, r3, #2
 1860 0e56 07F15802 		add	r2, r7, #88
 1861 0e5a 1344     		add	r3, r3, r2
 1862 0e5c 53F8440C 		ldr	r0, [r3, #-68]	@ float
 1863 0e60 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1864 0e64 6D4A     		ldr	r2, .L287
 1865 0e66 0C33     		adds	r3, r3, #12
 1866 0e68 9B00     		lsls	r3, r3, #2
 1867 0e6a 1344     		add	r3, r3, r2
 1868 0e6c 5B68     		ldr	r3, [r3, #4]	@ float
 1869 0e6e 1946     		mov	r1, r3
 1870 0e70 FFF7FEFF 		bl	__aeabi_fadd
 1871 0e74 0346     		mov	r3, r0
 1872 0e76 1946     		mov	r1, r3
 1873 0e78 4046     		mov	r0, r8
 1874 0e7a FFF7FEFF 		bl	__aeabi_fadd
 1875 0e7e 0346     		mov	r3, r0
 1876 0e80 1946     		mov	r1, r3
 1877 0e82 674A     		ldr	r2, .L287+4
 1878 0e84 06F10C03 		add	r3, r6, #12
 1879 0e88 9B00     		lsls	r3, r3, #2
 1880 0e8a 1344     		add	r3, r3, r2
 1881 0e8c 5960     		str	r1, [r3, #4]	@ float
 595:gcode.c       ****                   if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_l
 1882              		.loc 1 595 0
 1883 0e8e 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1884 0e92 022B     		cmp	r3, #2
 1885 0e94 32D1     		bne	.L146
 1886              		.loc 1 595 0 is_stmt 0 discriminator 1
 1887 0e96 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1888 0e9a 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1889 0e9e 604A     		ldr	r2, .L287+4
 1890 0ea0 0C33     		adds	r3, r3, #12
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 45


 1891 0ea2 9B00     		lsls	r3, r3, #2
 1892 0ea4 1344     		add	r3, r3, r2
 1893 0ea6 5A68     		ldr	r2, [r3, #4]	@ float
 1894 0ea8 5C4B     		ldr	r3, .L287
 1895 0eaa 1B6C     		ldr	r3, [r3, #64]	@ float
 1896 0eac 1946     		mov	r1, r3
 1897 0eae 1046     		mov	r0, r2
 1898 0eb0 FFF7FEFF 		bl	__aeabi_fadd
 1899 0eb4 0346     		mov	r3, r0
 1900 0eb6 1946     		mov	r1, r3
 1901 0eb8 594A     		ldr	r2, .L287+4
 1902 0eba 06F10C03 		add	r3, r6, #12
 1903 0ebe 9B00     		lsls	r3, r3, #2
 1904 0ec0 1344     		add	r3, r3, r2
 1905 0ec2 5960     		str	r1, [r3, #4]	@ float
 1906 0ec4 1AE0     		b	.L146
 1907              	.L147:
 596:gcode.c       ****                 } else {  // Incremental mode
 597:gcode.c       ****                   gc_block.values.xyz[idx] += gc_state.position[idx];
 1908              		.loc 1 597 0 is_stmt 1
 1909 0ec6 97F84760 		ldrb	r6, [r7, #71]	@ zero_extendqisi2
 1910 0eca 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1911 0ece 544A     		ldr	r2, .L287+4
 1912 0ed0 0C33     		adds	r3, r3, #12
 1913 0ed2 9B00     		lsls	r3, r3, #2
 1914 0ed4 1344     		add	r3, r3, r2
 1915 0ed6 5868     		ldr	r0, [r3, #4]	@ float
 1916 0ed8 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1917 0edc 4F4A     		ldr	r2, .L287
 1918 0ede 0633     		adds	r3, r3, #6
 1919 0ee0 9B00     		lsls	r3, r3, #2
 1920 0ee2 1344     		add	r3, r3, r2
 1921 0ee4 5B68     		ldr	r3, [r3, #4]	@ float
 1922 0ee6 1946     		mov	r1, r3
 1923 0ee8 FFF7FEFF 		bl	__aeabi_fadd
 1924 0eec 0346     		mov	r3, r0
 1925 0eee 1946     		mov	r1, r3
 1926 0ef0 4B4A     		ldr	r2, .L287+4
 1927 0ef2 06F10C03 		add	r3, r6, #12
 1928 0ef6 9B00     		lsls	r3, r3, #2
 1929 0ef8 1344     		add	r3, r3, r2
 1930 0efa 5960     		str	r1, [r3, #4]	@ float
 1931              	.L146:
 585:gcode.c       ****             if ( bit_isfalse(axis_words,bit(idx)) ) {
 1932              		.loc 1 585 0 discriminator 2
 1933 0efc 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1934 0f00 0133     		adds	r3, r3, #1
 1935 0f02 87F84730 		strb	r3, [r7, #71]
 1936              	.L144:
 585:gcode.c       ****             if ( bit_isfalse(axis_words,bit(idx)) ) {
 1937              		.loc 1 585 0 is_stmt 0 discriminator 1
 1938 0f06 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 1939 0f0a 022B     		cmp	r3, #2
 1940 0f0c 7FF674AF 		bls	.L149
 1941              	.L143:
 598:gcode.c       ****                 }
 599:gcode.c       ****               }
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 46


 600:gcode.c       ****             }
 601:gcode.c       ****           }
 602:gcode.c       ****         }
 603:gcode.c       ****       }
 604:gcode.c       **** 
 605:gcode.c       ****       // Check remaining non-modal commands for errors.
 606:gcode.c       ****       switch (gc_block.non_modal_command) {
 1942              		.loc 1 606 0 is_stmt 1
 1943 0f10 434B     		ldr	r3, .L287+4
 1944 0f12 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1945 0f14 262B     		cmp	r3, #38
 1946 0f16 5DD0     		beq	.L273
 1947 0f18 262B     		cmp	r3, #38
 1948 0f1a 04DC     		bgt	.L151
 1949 0f1c 1C2B     		cmp	r3, #28
 1950 0f1e 08D0     		beq	.L152
 1951 0f20 1E2B     		cmp	r3, #30
 1952 0f22 06D0     		beq	.L152
 1953 0f24 5BE0     		b	.L136
 1954              	.L151:
 1955 0f26 352B     		cmp	r3, #53
 1956 0f28 49D0     		beq	.L153
 1957 0f2a 662B     		cmp	r3, #102
 1958 0f2c 54D0     		beq	.L274
 1959 0f2e 282B     		cmp	r3, #40
 607:gcode.c       ****         case NON_MODAL_GO_HOME_0: // G28
 608:gcode.c       ****         case NON_MODAL_GO_HOME_1: // G30
 609:gcode.c       ****           // [G28/30 Errors]: Cutter compensation is enabled.
 610:gcode.c       ****           // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
 611:gcode.c       ****           // NOTE: Store parameter data in IJK values. By rule, they are not in use with this comma
 612:gcode.c       ****           if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
 613:gcode.c       ****             if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SET
 614:gcode.c       ****           } else { // == NON_MODAL_GO_HOME_1
 615:gcode.c       ****             if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SET
 616:gcode.c       ****           }
 617:gcode.c       ****           if (axis_words) {
 618:gcode.c       ****             // Move only the axes specified in secondary move.
 619:gcode.c       ****             for (idx=0; idx<N_AXIS; idx++) {
 620:gcode.c       ****               if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 621:gcode.c       ****             }
 622:gcode.c       ****           } else {
 623:gcode.c       ****             axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
 624:gcode.c       ****           }
 625:gcode.c       ****           break;
 626:gcode.c       ****         case NON_MODAL_SET_HOME_0: // G28.1
 627:gcode.c       ****         case NON_MODAL_SET_HOME_1: // G30.1
 628:gcode.c       ****           // [G28.1/30.1 Errors]: Cutter compensation is enabled.
 629:gcode.c       ****           // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
 630:gcode.c       ****           break;
 1960              		.loc 1 630 0
 1961 0f30 50E0     		b	.L273
 1962              	.L152:
 612:gcode.c       ****             if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SET
 1963              		.loc 1 612 0
 1964 0f32 3B4B     		ldr	r3, .L287+4
 1965 0f34 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1966 0f36 1C2B     		cmp	r3, #28
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 47


 1967 0f38 09D1     		bne	.L155
 613:gcode.c       ****           } else { // == NON_MODAL_GO_HOME_1
 1968              		.loc 1 613 0
 1969 0f3a 3A49     		ldr	r1, .L287+8
 1970 0f3c 0620     		movs	r0, #6
 1971 0f3e FFF7FEFF 		bl	settings_read_coord_data
 1972 0f42 0346     		mov	r3, r0
 1973 0f44 002B     		cmp	r3, #0
 1974 0f46 0CD1     		bne	.L156
 613:gcode.c       ****           } else { // == NON_MODAL_GO_HOME_1
 1975              		.loc 1 613 0 is_stmt 0 discriminator 1
 1976 0f48 0723     		movs	r3, #7
 1977 0f4a 00F0A8BD 		b	.L251
 1978              	.L155:
 615:gcode.c       ****           }
 1979              		.loc 1 615 0 is_stmt 1
 1980 0f4e 3549     		ldr	r1, .L287+8
 1981 0f50 0720     		movs	r0, #7
 1982 0f52 FFF7FEFF 		bl	settings_read_coord_data
 1983 0f56 0346     		mov	r3, r0
 1984 0f58 002B     		cmp	r3, #0
 1985 0f5a 02D1     		bne	.L156
 615:gcode.c       ****           }
 1986              		.loc 1 615 0 is_stmt 0 discriminator 1
 1987 0f5c 0723     		movs	r3, #7
 1988 0f5e 00F09EBD 		b	.L251
 1989              	.L156:
 617:gcode.c       ****             // Move only the axes specified in secondary move.
 1990              		.loc 1 617 0 is_stmt 1
 1991 0f62 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1992 0f66 002B     		cmp	r3, #0
 1993 0f68 25D0     		beq	.L157
 619:gcode.c       ****               if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 1994              		.loc 1 619 0
 1995 0f6a 0023     		movs	r3, #0
 1996 0f6c 87F84730 		strb	r3, [r7, #71]
 1997 0f70 1CE0     		b	.L158
 1998              	.L160:
 620:gcode.c       ****             }
 1999              		.loc 1 620 0
 2000 0f72 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 2001 0f76 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2002 0f7a 42FA03F3 		asr	r3, r2, r3
 2003 0f7e 03F00103 		and	r3, r3, #1
 2004 0f82 002B     		cmp	r3, #0
 2005 0f84 0DD1     		bne	.L159
 620:gcode.c       ****             }
 2006              		.loc 1 620 0 is_stmt 0 discriminator 1
 2007 0f86 97F84710 		ldrb	r1, [r7, #71]	@ zero_extendqisi2
 2008 0f8a 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2009 0f8e 234A     		ldr	r2, .L287
 2010 0f90 0633     		adds	r3, r3, #6
 2011 0f92 9B00     		lsls	r3, r3, #2
 2012 0f94 1344     		add	r3, r3, r2
 2013 0f96 5A68     		ldr	r2, [r3, #4]	@ float
 2014 0f98 2148     		ldr	r0, .L287+4
 2015 0f9a 8B1C     		adds	r3, r1, #2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 48


 2016 0f9c 9B00     		lsls	r3, r3, #2
 2017 0f9e 0344     		add	r3, r3, r0
 2018 0fa0 9A60     		str	r2, [r3, #8]	@ float
 2019              	.L159:
 619:gcode.c       ****               if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 2020              		.loc 1 619 0 is_stmt 1 discriminator 2
 2021 0fa2 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2022 0fa6 0133     		adds	r3, r3, #1
 2023 0fa8 87F84730 		strb	r3, [r7, #71]
 2024              	.L158:
 619:gcode.c       ****               if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 2025              		.loc 1 619 0 is_stmt 0 discriminator 1
 2026 0fac 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2027 0fb0 022B     		cmp	r3, #2
 2028 0fb2 DED9     		bls	.L160
 625:gcode.c       ****         case NON_MODAL_SET_HOME_0: // G28.1
 2029              		.loc 1 625 0 is_stmt 1
 2030 0fb4 13E0     		b	.L136
 2031              	.L157:
 623:gcode.c       ****           }
 2032              		.loc 1 623 0
 2033 0fb6 0023     		movs	r3, #0
 2034 0fb8 87F85730 		strb	r3, [r7, #87]
 625:gcode.c       ****         case NON_MODAL_SET_HOME_0: // G28.1
 2035              		.loc 1 625 0
 2036 0fbc 0FE0     		b	.L136
 2037              	.L153:
 631:gcode.c       ****         case NON_MODAL_RESET_COORDINATE_OFFSET:
 632:gcode.c       ****           // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
 633:gcode.c       ****           break;
 634:gcode.c       ****         case NON_MODAL_ABSOLUTE_OVERRIDE:
 635:gcode.c       ****           // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
 636:gcode.c       ****           // NOTE: All explicit axis word commands are in this modal group. So no implicit check ne
 637:gcode.c       ****           if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_L
 2038              		.loc 1 637 0
 2039 0fbe 184B     		ldr	r3, .L287+4
 2040 0fc0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2041 0fc2 002B     		cmp	r3, #0
 2042 0fc4 0AD0     		beq	.L275
 2043              		.loc 1 637 0 is_stmt 0 discriminator 1
 2044 0fc6 164B     		ldr	r3, .L287+4
 2045 0fc8 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2046 0fca 012B     		cmp	r3, #1
 2047 0fcc 06D0     		beq	.L275
 638:gcode.c       ****             FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
 2048              		.loc 1 638 0 is_stmt 1
 2049 0fce 1E23     		movs	r3, #30
 2050 0fd0 00F065BD 		b	.L251
 2051              	.L273:
 630:gcode.c       ****         case NON_MODAL_RESET_COORDINATE_OFFSET:
 2052              		.loc 1 630 0
 2053 0fd4 00BF     		nop
 2054 0fd6 02E0     		b	.L136
 2055              	.L274:
 633:gcode.c       ****         case NON_MODAL_ABSOLUTE_OVERRIDE:
 2056              		.loc 1 633 0
 2057 0fd8 00BF     		nop
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 49


 2058 0fda 00E0     		b	.L136
 2059              	.L275:
 639:gcode.c       ****           }
 640:gcode.c       ****           break;
 2060              		.loc 1 640 0
 2061 0fdc 00BF     		nop
 2062              	.L136:
 641:gcode.c       ****       }
 642:gcode.c       ****   }
 643:gcode.c       **** 
 644:gcode.c       ****   // [20. Motion modes ]:
 645:gcode.c       ****   if (gc_block.modal.motion == MOTION_MODE_NONE) {
 2063              		.loc 1 645 0
 2064 0fde 104B     		ldr	r3, .L287+4
 2065 0fe0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2066 0fe2 502B     		cmp	r3, #80
 2067 0fe4 07D1     		bne	.L163
 646:gcode.c       ****     // [G80 Errors]: Axis word are programmed while G80 is active.
 647:gcode.c       ****     // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
 648:gcode.c       ****     if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
 2068              		.loc 1 648 0
 2069 0fe6 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2070 0fea 002B     		cmp	r3, #0
 2071 0fec 00F07382 		beq	.L164
 2072              		.loc 1 648 0 is_stmt 0 discriminator 1
 2073 0ff0 1F23     		movs	r3, #31
 2074 0ff2 00F054BD 		b	.L251
 2075              	.L163:
 649:gcode.c       **** 
 650:gcode.c       ****   // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), 
 651:gcode.c       ****   // was explicitly commanded in the g-code block.
 652:gcode.c       ****   } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
 2076              		.loc 1 652 0 is_stmt 1
 2077 0ff6 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 2078 0ffa 022B     		cmp	r3, #2
 2079 0ffc 40F06B82 		bne	.L164
 653:gcode.c       **** 
 654:gcode.c       ****     if (gc_block.modal.motion == MOTION_MODE_SEEK) {
 2080              		.loc 1 654 0
 2081 1000 074B     		ldr	r3, .L287+4
 2082 1002 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2083 1004 002B     		cmp	r3, #0
 2084 1006 0FD1     		bne	.L165
 655:gcode.c       ****       // [G0 Errors]: Axis letter not configured or without real value (done.)
 656:gcode.c       ****       // Axis words are optional. If missing, set axis command flag to ignore execution.
 657:gcode.c       ****       if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 2085              		.loc 1 657 0
 2086 1008 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2087 100c 002B     		cmp	r3, #0
 2088 100e 40F06282 		bne	.L164
 2089              		.loc 1 657 0 is_stmt 0 discriminator 1
 2090 1012 0023     		movs	r3, #0
 2091 1014 87F85730 		strb	r3, [r7, #87]
 2092 1018 5DE2     		b	.L164
 2093              	.L288:
 2094 101a 00BF     		.align	2
 2095              	.L287:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 50


 2096 101c 00000000 		.word	gc_state
 2097 1020 00000000 		.word	gc_block
 2098 1024 10000000 		.word	gc_block+16
 2099              	.L165:
 658:gcode.c       **** 
 659:gcode.c       ****     // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units p
 660:gcode.c       ****     // the value must be positive. In inverse time mode, a positive value must be passed with each 
 661:gcode.c       ****     } else {
 662:gcode.c       ****       // Check if feed rate is defined for the motion modes that require it.
 663:gcode.c       ****       if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undef
 2100              		.loc 1 663 0 is_stmt 1
 2101 1028 C34B     		ldr	r3, .L289+8
 2102 102a DB68     		ldr	r3, [r3, #12]	@ float
 2103 102c 4FF00001 		mov	r1, #0
 2104 1030 1846     		mov	r0, r3
 2105 1032 FFF7FEFF 		bl	__aeabi_fcmpeq
 2106 1036 0346     		mov	r3, r0
 2107 1038 002B     		cmp	r3, #0
 2108 103a 02D0     		beq	.L266
 2109              		.loc 1 663 0 is_stmt 0 discriminator 1
 2110 103c 1623     		movs	r3, #22
 2111 103e 00F02EBD 		b	.L251
 2112              	.L266:
 664:gcode.c       **** 
 665:gcode.c       ****       switch (gc_block.modal.motion) {
 2113              		.loc 1 665 0 is_stmt 1
 2114 1042 BD4B     		ldr	r3, .L289+8
 2115 1044 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2116 1046 8C2B     		cmp	r3, #140
 2117 1048 00F02482 		beq	.L169
 2118 104c 8C2B     		cmp	r3, #140
 2119 104e 06DC     		bgt	.L170
 2120 1050 022B     		cmp	r3, #2
 2121 1052 17D0     		beq	.L171
 2122 1054 032B     		cmp	r3, #3
 2123 1056 1BD0     		beq	.L172
 2124 1058 012B     		cmp	r3, #1
 2125 105a 0AD0     		beq	.L173
 2126 105c 3BE2     		b	.L164
 2127              	.L170:
 2128 105e 8E2B     		cmp	r3, #142
 2129 1060 00F01882 		beq	.L169
 2130 1064 8E2B     		cmp	r3, #142
 2131 1066 C0F20F82 		blt	.L174
 2132 106a 8F2B     		cmp	r3, #143
 2133 106c 00F00C82 		beq	.L174
 2134 1070 31E2     		b	.L164
 2135              	.L173:
 2136              	.LBB2:
 666:gcode.c       ****         case MOTION_MODE_LINEAR:
 667:gcode.c       ****           // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
 668:gcode.c       ****           // Axis words are optional. If missing, set axis command flag to ignore execution.
 669:gcode.c       ****           if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 2137              		.loc 1 669 0
 2138 1072 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2139 1076 002B     		cmp	r3, #0
 2140 1078 40F02A82 		bne	.L276
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 51


 2141              		.loc 1 669 0 is_stmt 0 discriminator 1
 2142 107c 0023     		movs	r3, #0
 2143 107e 87F85730 		strb	r3, [r7, #87]
 670:gcode.c       ****           break;
 2144              		.loc 1 670 0 is_stmt 1 discriminator 1
 2145 1082 25E2     		b	.L276
 2146              	.L171:
 671:gcode.c       ****         case MOTION_MODE_CW_ARC: 
 672:gcode.c       ****           gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
 2147              		.loc 1 672 0
 2148 1084 97F84B30 		ldrb	r3, [r7, #75]
 2149 1088 43F00403 		orr	r3, r3, #4
 2150 108c 87F84B30 		strb	r3, [r7, #75]
 2151              	.L172:
 673:gcode.c       ****         case MOTION_MODE_CCW_ARC:
 674:gcode.c       ****           // [G2/3 Errors All-Modes]: Feed rate undefined.
 675:gcode.c       ****           // [G2/3 Radius-Mode Errors]: No axis words in selected plane. Target point is same as cu
 676:gcode.c       ****           // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius 
 677:gcode.c       ****           //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm O
 678:gcode.c       ****           // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed
 679:gcode.c       ****           // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with t
 680:gcode.c       **** 
 681:gcode.c       ****           if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 2152              		.loc 1 681 0
 2153 1090 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2154 1094 002B     		cmp	r3, #0
 2155 1096 02D1     		bne	.L176
 2156              		.loc 1 681 0 is_stmt 0 discriminator 1
 2157 1098 1A23     		movs	r3, #26
 2158 109a 00F000BD 		b	.L251
 2159              	.L176:
 682:gcode.c       ****           if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE
 2160              		.loc 1 682 0 is_stmt 1
 2161 109e 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 2162 10a2 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2163 10a6 0121     		movs	r1, #1
 2164 10a8 9940     		lsls	r1, r1, r3
 2165 10aa 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2166 10ae 0120     		movs	r0, #1
 2167 10b0 00FA03F3 		lsl	r3, r0, r3
 2168 10b4 0B43     		orrs	r3, r3, r1
 2169 10b6 1340     		ands	r3, r3, r2
 2170 10b8 002B     		cmp	r3, #0
 2171 10ba 02D1     		bne	.L177
 2172              		.loc 1 682 0 is_stmt 0 discriminator 1
 2173 10bc 2023     		movs	r3, #32
 2174 10be 00F0EEBC 		b	.L251
 2175              	.L177:
 683:gcode.c       **** 
 684:gcode.c       ****           // Calculate the change in position along each selected axis
 685:gcode.c       ****           float x,y;
 686:gcode.c       ****           x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current pos
 2176              		.loc 1 686 0 is_stmt 1
 2177 10c2 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2178 10c6 9C4A     		ldr	r2, .L289+8
 2179 10c8 0C33     		adds	r3, r3, #12
 2180 10ca 9B00     		lsls	r3, r3, #2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 52


 2181 10cc 1344     		add	r3, r3, r2
 2182 10ce 5868     		ldr	r0, [r3, #4]	@ float
 2183 10d0 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2184 10d4 994A     		ldr	r2, .L289+12
 2185 10d6 0633     		adds	r3, r3, #6
 2186 10d8 9B00     		lsls	r3, r3, #2
 2187 10da 1344     		add	r3, r3, r2
 2188 10dc 5B68     		ldr	r3, [r3, #4]	@ float
 2189 10de 1946     		mov	r1, r3
 2190 10e0 FFF7FEFF 		bl	__aeabi_fsub
 2191 10e4 0346     		mov	r3, r0
 2192 10e6 BB63     		str	r3, [r7, #56]	@ float
 687:gcode.c       ****           y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current pos
 2193              		.loc 1 687 0
 2194 10e8 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2195 10ec 924A     		ldr	r2, .L289+8
 2196 10ee 0C33     		adds	r3, r3, #12
 2197 10f0 9B00     		lsls	r3, r3, #2
 2198 10f2 1344     		add	r3, r3, r2
 2199 10f4 5868     		ldr	r0, [r3, #4]	@ float
 2200 10f6 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2201 10fa 904A     		ldr	r2, .L289+12
 2202 10fc 0633     		adds	r3, r3, #6
 2203 10fe 9B00     		lsls	r3, r3, #2
 2204 1100 1344     		add	r3, r3, r2
 2205 1102 5B68     		ldr	r3, [r3, #4]	@ float
 2206 1104 1946     		mov	r1, r3
 2207 1106 FFF7FEFF 		bl	__aeabi_fsub
 2208 110a 0346     		mov	r3, r0
 2209 110c 7B63     		str	r3, [r7, #52]	@ float
 688:gcode.c       **** 
 689:gcode.c       ****           if (value_words & bit(WORD_R)) { // Arc Radius Mode
 2210              		.loc 1 689 0
 2211 110e B7F84C30 		ldrh	r3, [r7, #76]
 2212 1112 03F08003 		and	r3, r3, #128
 2213 1116 002B     		cmp	r3, #0
 2214 1118 00F0E980 		beq	.L178
 2215              	.LBB3:
 690:gcode.c       ****             bit_false(value_words,bit(WORD_R));
 2216              		.loc 1 690 0
 2217 111c B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 2218 1120 23F08003 		bic	r3, r3, #128
 2219 1124 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 691:gcode.c       ****             if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCOD
 2220              		.loc 1 691 0
 2221 1128 0C22     		movs	r2, #12
 2222 112a 8549     		ldr	r1, .L289+16
 2223 112c 8548     		ldr	r0, .L289+20
 2224 112e FFF7FEFF 		bl	memcmp
 2225 1132 0346     		mov	r3, r0
 2226 1134 002B     		cmp	r3, #0
 2227 1136 02D1     		bne	.L179
 2228              		.loc 1 691 0 is_stmt 0 discriminator 1
 2229 1138 2123     		movs	r3, #33
 2230 113a 00F0B0BC 		b	.L251
 2231              	.L179:
 692:gcode.c       **** 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 53


 693:gcode.c       ****             // Convert radius value to proper units.
 694:gcode.c       ****             if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
 2232              		.loc 1 694 0 is_stmt 1
 2233 113e 7E4B     		ldr	r3, .L289+8
 2234 1140 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 2235 1142 012B     		cmp	r3, #1
 2236 1144 12D1     		bne	.L180
 2237              		.loc 1 694 0 is_stmt 0 discriminator 1
 2238 1146 7C4B     		ldr	r3, .L289+8
 2239 1148 9B6A     		ldr	r3, [r3, #40]	@ float
 2240 114a 1846     		mov	r0, r3
 2241 114c FFF7FEFF 		bl	__aeabi_f2d
 2242 1150 77A3     		adr	r3, .L289
 2243 1152 D3E90023 		ldrd	r2, [r3]
 2244 1156 FFF7FEFF 		bl	__aeabi_dmul
 2245 115a 0246     		mov	r2, r0
 2246 115c 0B46     		mov	r3, r1
 2247 115e 1046     		mov	r0, r2
 2248 1160 1946     		mov	r1, r3
 2249 1162 FFF7FEFF 		bl	__aeabi_d2f
 2250 1166 0246     		mov	r2, r0
 2251 1168 734B     		ldr	r3, .L289+8
 2252 116a 9A62     		str	r2, [r3, #40]	@ float
 2253              	.L180:
 695:gcode.c       ****             /*  We need to calculate the center of the circle that has the designated radius and pa
 696:gcode.c       ****                 through both the current position and the target position. This method calculates t
 697:gcode.c       ****                 set of equations where [x,y] is the vector from current to target position, d == ma
 698:gcode.c       ****                 that vector, h == hypotenuse of the triangle formed by the radius of the circle, th
 699:gcode.c       ****                 the center of the travel vector. A vector perpendicular to the travel vector [-y,x]
 700:gcode.c       ****                 length of h [-y/d*h, x/d*h] and added to the center of the travel vector [x/2,y/2] 
 701:gcode.c       ****                 [i,j] at [x/2-y/d*h, y/2+x/d*h] which will be the center of our arc.
 702:gcode.c       **** 
 703:gcode.c       ****                 d^2 == x^2 + y^2
 704:gcode.c       ****                 h^2 == r^2 - (d/2)^2
 705:gcode.c       ****                 i == x/2 - y/d*h
 706:gcode.c       ****                 j == y/2 + x/d*h
 707:gcode.c       **** 
 708:gcode.c       ****                                                                      O <- [i,j]
 709:gcode.c       ****                                                                   -  |
 710:gcode.c       ****                                                         r      -     |
 711:gcode.c       ****                                                             -        |
 712:gcode.c       ****                                                          -           | h
 713:gcode.c       ****                                                       -              |
 714:gcode.c       ****                                         [0,0] ->  C -----------------+--------------- T  <- [x,y]
 715:gcode.c       ****                                                   | <------ d/2 ---->|
 716:gcode.c       **** 
 717:gcode.c       ****                 C - Current position
 718:gcode.c       ****                 T - Target position
 719:gcode.c       ****                 O - center of circle that pass through both C and T
 720:gcode.c       ****                 d - distance from C to T
 721:gcode.c       ****                 r - designated radius
 722:gcode.c       ****                 h - distance from center of CT to O
 723:gcode.c       **** 
 724:gcode.c       ****                 Expanding the equations:
 725:gcode.c       **** 
 726:gcode.c       ****                 d -> sqrt(x^2 + y^2)
 727:gcode.c       ****                 h -> sqrt(4 * r^2 - x^2 - y^2)/2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 54


 728:gcode.c       ****                 i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2
 729:gcode.c       ****                 j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2
 730:gcode.c       **** 
 731:gcode.c       ****                 Which can be written:
 732:gcode.c       **** 
 733:gcode.c       ****                 i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2
 734:gcode.c       ****                 j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2
 735:gcode.c       **** 
 736:gcode.c       ****                 Which we for size and speed reasons optimize to:
 737:gcode.c       **** 
 738:gcode.c       ****                 h_x2_div_d = sqrt(4 * r^2 - x^2 - y^2)/sqrt(x^2 + y^2)
 739:gcode.c       ****                 i = (x - (y * h_x2_div_d))/2
 740:gcode.c       ****                 j = (y + (x * h_x2_div_d))/2
 741:gcode.c       ****             */
 742:gcode.c       **** 
 743:gcode.c       ****             // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
 744:gcode.c       ****             // than d. If so, the sqrt of a negative number is complex and error out.
 745:gcode.c       ****             float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
 2254              		.loc 1 745 0 is_stmt 1
 2255 116c 724B     		ldr	r3, .L289+8
 2256 116e 9B6A     		ldr	r3, [r3, #40]	@ float
 2257 1170 1846     		mov	r0, r3
 2258 1172 FFF7FEFF 		bl	__aeabi_f2d
 2259 1176 4FF00002 		mov	r2, #0
 2260 117a 734B     		ldr	r3, .L289+24
 2261 117c FFF7FEFF 		bl	__aeabi_dmul
 2262 1180 0246     		mov	r2, r0
 2263 1182 0B46     		mov	r3, r1
 2264 1184 9046     		mov	r8, r2
 2265 1186 9946     		mov	r9, r3
 2266 1188 6B4B     		ldr	r3, .L289+8
 2267 118a 9B6A     		ldr	r3, [r3, #40]	@ float
 2268 118c 1846     		mov	r0, r3
 2269 118e FFF7FEFF 		bl	__aeabi_f2d
 2270 1192 0246     		mov	r2, r0
 2271 1194 0B46     		mov	r3, r1
 2272 1196 4046     		mov	r0, r8
 2273 1198 4946     		mov	r1, r9
 2274 119a FFF7FEFF 		bl	__aeabi_dmul
 2275 119e 0246     		mov	r2, r0
 2276 11a0 0B46     		mov	r3, r1
 2277 11a2 9046     		mov	r8, r2
 2278 11a4 9946     		mov	r9, r3
 2279 11a6 B96B     		ldr	r1, [r7, #56]	@ float
 2280 11a8 B86B     		ldr	r0, [r7, #56]	@ float
 2281 11aa FFF7FEFF 		bl	__aeabi_fmul
 2282 11ae 0346     		mov	r3, r0
 2283 11b0 1846     		mov	r0, r3
 2284 11b2 FFF7FEFF 		bl	__aeabi_f2d
 2285 11b6 0246     		mov	r2, r0
 2286 11b8 0B46     		mov	r3, r1
 2287 11ba 4046     		mov	r0, r8
 2288 11bc 4946     		mov	r1, r9
 2289 11be FFF7FEFF 		bl	__aeabi_dsub
 2290 11c2 0246     		mov	r2, r0
 2291 11c4 0B46     		mov	r3, r1
 2292 11c6 9046     		mov	r8, r2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 55


 2293 11c8 9946     		mov	r9, r3
 2294 11ca 796B     		ldr	r1, [r7, #52]	@ float
 2295 11cc 786B     		ldr	r0, [r7, #52]	@ float
 2296 11ce FFF7FEFF 		bl	__aeabi_fmul
 2297 11d2 0346     		mov	r3, r0
 2298 11d4 1846     		mov	r0, r3
 2299 11d6 FFF7FEFF 		bl	__aeabi_f2d
 2300 11da 0246     		mov	r2, r0
 2301 11dc 0B46     		mov	r3, r1
 2302 11de 4046     		mov	r0, r8
 2303 11e0 4946     		mov	r1, r9
 2304 11e2 FFF7FEFF 		bl	__aeabi_dsub
 2305 11e6 0246     		mov	r2, r0
 2306 11e8 0B46     		mov	r3, r1
 2307 11ea 1046     		mov	r0, r2
 2308 11ec 1946     		mov	r1, r3
 2309 11ee FFF7FEFF 		bl	__aeabi_d2f
 2310 11f2 0346     		mov	r3, r0
 2311 11f4 3B64     		str	r3, [r7, #64]	@ float
 746:gcode.c       **** 
 747:gcode.c       ****             if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
 2312              		.loc 1 747 0
 2313 11f6 4FF00001 		mov	r1, #0
 2314 11fa 386C     		ldr	r0, [r7, #64]	@ float
 2315 11fc FFF7FEFF 		bl	__aeabi_fcmplt
 2316 1200 0346     		mov	r3, r0
 2317 1202 002B     		cmp	r3, #0
 2318 1204 02D0     		beq	.L267
 2319              		.loc 1 747 0 is_stmt 0 discriminator 1
 2320 1206 2223     		movs	r3, #34
 2321 1208 00F049BC 		b	.L251
 2322              	.L267:
 748:gcode.c       **** 
 749:gcode.c       ****             // Finish computing h_x2_div_d.
 750:gcode.c       ****             h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
 2323              		.loc 1 750 0 is_stmt 1
 2324 120c 386C     		ldr	r0, [r7, #64]	@ float
 2325 120e FFF7FEFF 		bl	__aeabi_f2d
 2326 1212 0246     		mov	r2, r0
 2327 1214 0B46     		mov	r3, r1
 2328 1216 1046     		mov	r0, r2
 2329 1218 1946     		mov	r1, r3
 2330 121a FFF7FEFF 		bl	sqrt
 2331 121e 0246     		mov	r2, r0
 2332 1220 0B46     		mov	r3, r1
 2333 1222 1446     		mov	r4, r2
 2334 1224 83F00045 		eor	r5, r3, #-2147483648
 2335 1228 796B     		ldr	r1, [r7, #52]	@ float
 2336 122a B86B     		ldr	r0, [r7, #56]	@ float
 2337 122c FFF7FEFF 		bl	hypot_f
 2338 1230 0346     		mov	r3, r0
 2339 1232 1846     		mov	r0, r3
 2340 1234 FFF7FEFF 		bl	__aeabi_f2d
 2341 1238 0246     		mov	r2, r0
 2342 123a 0B46     		mov	r3, r1
 2343 123c 2046     		mov	r0, r4
 2344 123e 2946     		mov	r1, r5
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 56


 2345 1240 FFF7FEFF 		bl	__aeabi_ddiv
 2346 1244 0346     		mov	r3, r0
 2347 1246 0C46     		mov	r4, r1
 2348 1248 1846     		mov	r0, r3
 2349 124a 2146     		mov	r1, r4
 2350 124c FFF7FEFF 		bl	__aeabi_d2f
 2351 1250 0346     		mov	r3, r0
 2352 1252 3B64     		str	r3, [r7, #64]	@ float
 751:gcode.c       ****             // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
 752:gcode.c       ****             if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
 2353              		.loc 1 752 0
 2354 1254 384B     		ldr	r3, .L289+8
 2355 1256 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2356 1258 032B     		cmp	r3, #3
 2357 125a 03D1     		bne	.L183
 2358              		.loc 1 752 0 is_stmt 0 discriminator 1
 2359 125c 3B6C     		ldr	r3, [r7, #64]
 2360 125e 83F00043 		eor	r3, r3, #-2147483648
 2361 1262 3B64     		str	r3, [r7, #64]	@ float
 2362              	.L183:
 753:gcode.c       **** 
 754:gcode.c       ****             /* The counter clockwise circle lies to the left of the target direction. When offset i
 755:gcode.c       ****                the left hand circle will be generated - when it is negative the right hand circle i
 756:gcode.c       **** 
 757:gcode.c       ****                                                                    T  <-- Target position
 758:gcode.c       **** 
 759:gcode.c       ****                                                                    ^
 760:gcode.c       ****                         Clockwise circles with this center         |          Clockwise circles wit
 761:gcode.c       ****                         will have > 180 deg of angular travel      |          < 180 deg of angular 
 762:gcode.c       ****                                                          \         |          /
 763:gcode.c       ****             center of arc when h_x2_div_d is positive ->  x <----- | -----> x <- center of arc when
 764:gcode.c       ****                                                                    |
 765:gcode.c       ****                                                                    |
 766:gcode.c       **** 
 767:gcode.c       ****                                                                    C  <-- Current position
 768:gcode.c       ****             */
 769:gcode.c       ****             // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel
 770:gcode.c       ****             // even though it is advised against ever generating such circles in a single line of g
 771:gcode.c       ****             // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite
 772:gcode.c       ****             // travel and thus we get the unadvisably long arcs as prescribed.
 773:gcode.c       ****             if (gc_block.values.r < 0) {
 2363              		.loc 1 773 0 is_stmt 1
 2364 1264 344B     		ldr	r3, .L289+8
 2365 1266 9B6A     		ldr	r3, [r3, #40]	@ float
 2366 1268 4FF00001 		mov	r1, #0
 2367 126c 1846     		mov	r0, r3
 2368 126e FFF7FEFF 		bl	__aeabi_fcmplt
 2369 1272 0346     		mov	r3, r0
 2370 1274 002B     		cmp	r3, #0
 2371 1276 09D0     		beq	.L184
 774:gcode.c       ****                 h_x2_div_d = -h_x2_div_d;
 2372              		.loc 1 774 0
 2373 1278 3B6C     		ldr	r3, [r7, #64]
 2374 127a 83F00043 		eor	r3, r3, #-2147483648
 2375 127e 3B64     		str	r3, [r7, #64]	@ float
 775:gcode.c       ****                 gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_
 2376              		.loc 1 775 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 57


 2377 1280 2D4B     		ldr	r3, .L289+8
 2378 1282 9B6A     		ldr	r3, [r3, #40]	@ float
 2379 1284 83F00043 		eor	r3, r3, #-2147483648
 2380 1288 2B4A     		ldr	r2, .L289+8
 2381 128a 9362     		str	r3, [r2, #40]	@ float
 2382              	.L184:
 776:gcode.c       ****             }
 777:gcode.c       ****             // Complete the operation by calculating the actual center of the arc
 778:gcode.c       ****             gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
 2383              		.loc 1 778 0
 2384 128c 97F85640 		ldrb	r4, [r7, #86]	@ zero_extendqisi2
 2385 1290 396C     		ldr	r1, [r7, #64]	@ float
 2386 1292 786B     		ldr	r0, [r7, #52]	@ float
 2387 1294 FFF7FEFF 		bl	__aeabi_fmul
 2388 1298 0346     		mov	r3, r0
 2389 129a 1946     		mov	r1, r3
 2390 129c B86B     		ldr	r0, [r7, #56]	@ float
 2391 129e FFF7FEFF 		bl	__aeabi_fsub
 2392 12a2 0346     		mov	r3, r0
 2393 12a4 4FF07C51 		mov	r1, #1056964608
 2394 12a8 1846     		mov	r0, r3
 2395 12aa FFF7FEFF 		bl	__aeabi_fmul
 2396 12ae 0346     		mov	r3, r0
 2397 12b0 1946     		mov	r1, r3
 2398 12b2 214A     		ldr	r2, .L289+8
 2399 12b4 A31C     		adds	r3, r4, #2
 2400 12b6 9B00     		lsls	r3, r3, #2
 2401 12b8 1344     		add	r3, r3, r2
 2402 12ba 9960     		str	r1, [r3, #8]	@ float
 779:gcode.c       ****             gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
 2403              		.loc 1 779 0
 2404 12bc 97F85540 		ldrb	r4, [r7, #85]	@ zero_extendqisi2
 2405 12c0 396C     		ldr	r1, [r7, #64]	@ float
 2406 12c2 B86B     		ldr	r0, [r7, #56]	@ float
 2407 12c4 FFF7FEFF 		bl	__aeabi_fmul
 2408 12c8 0346     		mov	r3, r0
 2409 12ca 796B     		ldr	r1, [r7, #52]	@ float
 2410 12cc 1846     		mov	r0, r3
 2411 12ce FFF7FEFF 		bl	__aeabi_fadd
 2412 12d2 0346     		mov	r3, r0
 2413 12d4 4FF07C51 		mov	r1, #1056964608
 2414 12d8 1846     		mov	r0, r3
 2415 12da FFF7FEFF 		bl	__aeabi_fmul
 2416 12de 0346     		mov	r3, r0
 2417 12e0 1946     		mov	r1, r3
 2418 12e2 154A     		ldr	r2, .L289+8
 2419 12e4 A31C     		adds	r3, r4, #2
 2420 12e6 9B00     		lsls	r3, r3, #2
 2421 12e8 1344     		add	r3, r3, r2
 2422 12ea 9960     		str	r1, [r3, #8]	@ float
 2423              	.LBE3:
 780:gcode.c       **** 
 781:gcode.c       ****           } else { // Arc Center Format Offset Mode
 782:gcode.c       ****             if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE);
 783:gcode.c       ****             bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
 784:gcode.c       **** 
 785:gcode.c       ****             // Convert IJK values to proper units.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 58


 786:gcode.c       ****             if (gc_block.modal.units == UNITS_MODE_INCHES) {
 787:gcode.c       ****               for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used 
 788:gcode.c       ****                 if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 789:gcode.c       ****               }
 790:gcode.c       ****             }
 791:gcode.c       **** 
 792:gcode.c       ****             // Arc radius from center to target
 793:gcode.c       ****             x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
 794:gcode.c       ****             y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
 795:gcode.c       ****             float target_r = hypot_f(x,y);
 796:gcode.c       **** 
 797:gcode.c       ****             // Compute arc radius for mc_arc. Defined from current location to center.
 798:gcode.c       ****             gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
 799:gcode.c       **** 
 800:gcode.c       ****             // Compute difference between current location and target radii for final error-checks.
 801:gcode.c       ****             float delta_r = fabs(target_r-gc_block.values.r);
 802:gcode.c       ****             if (delta_r > 0.005) {
 803:gcode.c       ****               if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] >
 804:gcode.c       ****               if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [A
 805:gcode.c       ****             }
 806:gcode.c       ****           }
 807:gcode.c       ****           break;
 2424              		.loc 1 807 0
 2425 12ec F3E0     		b	.L164
 2426              	.L178:
 2427              	.LBB4:
 782:gcode.c       ****             bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
 2428              		.loc 1 782 0
 2429 12ee 97F85120 		ldrb	r2, [r7, #81]	@ zero_extendqisi2
 2430 12f2 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2431 12f6 0121     		movs	r1, #1
 2432 12f8 9940     		lsls	r1, r1, r3
 2433 12fa 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2434 12fe 0120     		movs	r0, #1
 2435 1300 00FA03F3 		lsl	r3, r0, r3
 2436 1304 0B43     		orrs	r3, r3, r1
 2437 1306 1340     		ands	r3, r3, r2
 2438 1308 002B     		cmp	r3, #0
 2439 130a 01D1     		bne	.L187
 782:gcode.c       ****             bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
 2440              		.loc 1 782 0 is_stmt 0 discriminator 1
 2441 130c 2323     		movs	r3, #35
 2442 130e C6E3     		b	.L251
 2443              	.L187:
 783:gcode.c       **** 
 2444              		.loc 1 783 0 is_stmt 1
 2445 1310 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 2446 1314 23F00E03 		bic	r3, r3, #14
 2447 1318 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 786:gcode.c       ****               for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used 
 2448              		.loc 1 786 0
 2449 131c 064B     		ldr	r3, .L289+8
 2450 131e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 2451 1320 012B     		cmp	r3, #1
 2452 1322 43D1     		bne	.L188
 787:gcode.c       ****                 if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 2453              		.loc 1 787 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 59


 2454 1324 0023     		movs	r3, #0
 2455 1326 87F84730 		strb	r3, [r7, #71]
 2456 132a 3BE0     		b	.L189
 2457              	.L290:
 2458 132c AFF30080 		.align	3
 2459              	.L289:
 2460 1330 66666666 		.word	1717986918
 2461 1334 66663940 		.word	1077503590
 2462 1338 00000000 		.word	gc_block
 2463 133c 00000000 		.word	gc_state
 2464 1340 34000000 		.word	gc_block+52
 2465 1344 1C000000 		.word	gc_state+28
 2466 1348 00001040 		.word	1074790400
 2467              	.L191:
 788:gcode.c       ****               }
 2468              		.loc 1 788 0
 2469 134c 97F85120 		ldrb	r2, [r7, #81]	@ zero_extendqisi2
 2470 1350 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2471 1354 42FA03F3 		asr	r3, r2, r3
 2472 1358 03F00103 		and	r3, r3, #1
 2473 135c 002B     		cmp	r3, #0
 2474 135e 1CD0     		beq	.L190
 788:gcode.c       ****               }
 2475              		.loc 1 788 0 is_stmt 0 discriminator 1
 2476 1360 97F84740 		ldrb	r4, [r7, #71]	@ zero_extendqisi2
 2477 1364 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2478 1368 B74A     		ldr	r2, .L291+24
 2479 136a 0233     		adds	r3, r3, #2
 2480 136c 9B00     		lsls	r3, r3, #2
 2481 136e 1344     		add	r3, r3, r2
 2482 1370 9B68     		ldr	r3, [r3, #8]	@ float
 2483 1372 1846     		mov	r0, r3
 2484 1374 FFF7FEFF 		bl	__aeabi_f2d
 2485 1378 ADA3     		adr	r3, .L291
 2486 137a D3E90023 		ldrd	r2, [r3]
 2487 137e FFF7FEFF 		bl	__aeabi_dmul
 2488 1382 0246     		mov	r2, r0
 2489 1384 0B46     		mov	r3, r1
 2490 1386 1046     		mov	r0, r2
 2491 1388 1946     		mov	r1, r3
 2492 138a FFF7FEFF 		bl	__aeabi_d2f
 2493 138e 0146     		mov	r1, r0
 2494 1390 AD4A     		ldr	r2, .L291+24
 2495 1392 A31C     		adds	r3, r4, #2
 2496 1394 9B00     		lsls	r3, r3, #2
 2497 1396 1344     		add	r3, r3, r2
 2498 1398 9960     		str	r1, [r3, #8]	@ float
 2499              	.L190:
 787:gcode.c       ****                 if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 2500              		.loc 1 787 0 is_stmt 1 discriminator 2
 2501 139a 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2502 139e 0133     		adds	r3, r3, #1
 2503 13a0 87F84730 		strb	r3, [r7, #71]
 2504              	.L189:
 787:gcode.c       ****                 if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 2505              		.loc 1 787 0 is_stmt 0 discriminator 1
 2506 13a4 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 60


 2507 13a8 022B     		cmp	r3, #2
 2508 13aa CFD9     		bls	.L191
 2509              	.L188:
 793:gcode.c       ****             y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
 2510              		.loc 1 793 0 is_stmt 1
 2511 13ac 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2512 13b0 A54A     		ldr	r2, .L291+24
 2513 13b2 0233     		adds	r3, r3, #2
 2514 13b4 9B00     		lsls	r3, r3, #2
 2515 13b6 1344     		add	r3, r3, r2
 2516 13b8 9B68     		ldr	r3, [r3, #8]	@ float
 2517 13ba 1946     		mov	r1, r3
 2518 13bc B86B     		ldr	r0, [r7, #56]	@ float
 2519 13be FFF7FEFF 		bl	__aeabi_fsub
 2520 13c2 0346     		mov	r3, r0
 2521 13c4 BB63     		str	r3, [r7, #56]	@ float
 794:gcode.c       ****             float target_r = hypot_f(x,y);
 2522              		.loc 1 794 0
 2523 13c6 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2524 13ca 9F4A     		ldr	r2, .L291+24
 2525 13cc 0233     		adds	r3, r3, #2
 2526 13ce 9B00     		lsls	r3, r3, #2
 2527 13d0 1344     		add	r3, r3, r2
 2528 13d2 9B68     		ldr	r3, [r3, #8]	@ float
 2529 13d4 1946     		mov	r1, r3
 2530 13d6 786B     		ldr	r0, [r7, #52]	@ float
 2531 13d8 FFF7FEFF 		bl	__aeabi_fsub
 2532 13dc 0346     		mov	r3, r0
 2533 13de 7B63     		str	r3, [r7, #52]	@ float
 795:gcode.c       **** 
 2534              		.loc 1 795 0
 2535 13e0 796B     		ldr	r1, [r7, #52]	@ float
 2536 13e2 B86B     		ldr	r0, [r7, #56]	@ float
 2537 13e4 FFF7FEFF 		bl	hypot_f
 2538 13e8 3863     		str	r0, [r7, #48]	@ float
 798:gcode.c       **** 
 2539              		.loc 1 798 0
 2540 13ea 97F85630 		ldrb	r3, [r7, #86]	@ zero_extendqisi2
 2541 13ee 964A     		ldr	r2, .L291+24
 2542 13f0 0233     		adds	r3, r3, #2
 2543 13f2 9B00     		lsls	r3, r3, #2
 2544 13f4 1344     		add	r3, r3, r2
 2545 13f6 9868     		ldr	r0, [r3, #8]	@ float
 2546 13f8 97F85530 		ldrb	r3, [r7, #85]	@ zero_extendqisi2
 2547 13fc 924A     		ldr	r2, .L291+24
 2548 13fe 0233     		adds	r3, r3, #2
 2549 1400 9B00     		lsls	r3, r3, #2
 2550 1402 1344     		add	r3, r3, r2
 2551 1404 9B68     		ldr	r3, [r3, #8]	@ float
 2552 1406 1946     		mov	r1, r3
 2553 1408 FFF7FEFF 		bl	hypot_f
 2554 140c 0246     		mov	r2, r0
 2555 140e 8E4B     		ldr	r3, .L291+24
 2556 1410 9A62     		str	r2, [r3, #40]	@ float
 801:gcode.c       ****             if (delta_r > 0.005) {
 2557              		.loc 1 801 0
 2558 1412 8D4B     		ldr	r3, .L291+24
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 61


 2559 1414 9B6A     		ldr	r3, [r3, #40]	@ float
 2560 1416 1946     		mov	r1, r3
 2561 1418 386B     		ldr	r0, [r7, #48]	@ float
 2562 141a FFF7FEFF 		bl	__aeabi_fsub
 2563 141e 0346     		mov	r3, r0
 2564 1420 23F00043 		bic	r3, r3, #-2147483648
 2565 1424 FB62     		str	r3, [r7, #44]	@ float
 802:gcode.c       ****               if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] >
 2566              		.loc 1 802 0
 2567 1426 F86A     		ldr	r0, [r7, #44]	@ float
 2568 1428 FFF7FEFF 		bl	__aeabi_f2d
 2569 142c 82A3     		adr	r3, .L291+8
 2570 142e D3E90023 		ldrd	r2, [r3]
 2571 1432 FFF7FEFF 		bl	__aeabi_dcmpgt
 2572 1436 0346     		mov	r3, r0
 2573 1438 002B     		cmp	r3, #0
 2574 143a 00D1     		bne	.L257
 2575              	.LBE4:
 2576              		.loc 1 807 0
 2577 143c 4BE0     		b	.L164
 2578              	.L257:
 2579              	.LBB5:
 803:gcode.c       ****               if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [A
 2580              		.loc 1 803 0
 2581 143e 4FF07C51 		mov	r1, #1056964608
 2582 1442 F86A     		ldr	r0, [r7, #44]	@ float
 2583 1444 FFF7FEFF 		bl	__aeabi_fcmpgt
 2584 1448 0346     		mov	r3, r0
 2585 144a 002B     		cmp	r3, #0
 2586 144c 01D0     		beq	.L268
 803:gcode.c       ****               if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [A
 2587              		.loc 1 803 0 is_stmt 0 discriminator 1
 2588 144e 2123     		movs	r3, #33
 2589 1450 25E3     		b	.L251
 2590              	.L268:
 804:gcode.c       ****             }
 2591              		.loc 1 804 0 is_stmt 1
 2592 1452 F86A     		ldr	r0, [r7, #44]	@ float
 2593 1454 FFF7FEFF 		bl	__aeabi_f2d
 2594 1458 0446     		mov	r4, r0
 2595 145a 0D46     		mov	r5, r1
 2596 145c 7A4B     		ldr	r3, .L291+24
 2597 145e 9B6A     		ldr	r3, [r3, #40]	@ float
 2598 1460 1846     		mov	r0, r3
 2599 1462 FFF7FEFF 		bl	__aeabi_f2d
 2600 1466 76A3     		adr	r3, .L291+16
 2601 1468 D3E90023 		ldrd	r2, [r3]
 2602 146c FFF7FEFF 		bl	__aeabi_dmul
 2603 1470 0246     		mov	r2, r0
 2604 1472 0B46     		mov	r3, r1
 2605 1474 2046     		mov	r0, r4
 2606 1476 2946     		mov	r1, r5
 2607 1478 FFF7FEFF 		bl	__aeabi_dcmpgt
 2608 147c 0346     		mov	r3, r0
 2609 147e 002B     		cmp	r3, #0
 2610 1480 00D1     		bne	.L259
 2611              	.LBE5:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 62


 2612              		.loc 1 807 0
 2613 1482 28E0     		b	.L164
 2614              	.L259:
 2615              	.LBB6:
 804:gcode.c       ****             }
 2616              		.loc 1 804 0 discriminator 1
 2617 1484 2123     		movs	r3, #33
 2618 1486 0AE3     		b	.L251
 2619              	.L174:
 2620              	.LBE6:
 808:gcode.c       ****         case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
 809:gcode.c       ****           gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
 2621              		.loc 1 809 0
 2622 1488 97F84B30 		ldrb	r3, [r7, #75]
 2623 148c 43F01003 		orr	r3, r3, #16
 2624 1490 87F84B30 		strb	r3, [r7, #75]
 2625              	.L169:
 810:gcode.c       ****         case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
 811:gcode.c       ****           if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
 2626              		.loc 1 811 0
 2627 1494 6C4B     		ldr	r3, .L291+24
 2628 1496 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2629 1498 8E2B     		cmp	r3, #142
 2630 149a 03D0     		beq	.L196
 812:gcode.c       ****               (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_P
 2631              		.loc 1 812 0 discriminator 1
 2632 149c 6A4B     		ldr	r3, .L291+24
 2633 149e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 811:gcode.c       ****               (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_P
 2634              		.loc 1 811 0 discriminator 1
 2635 14a0 8F2B     		cmp	r3, #143
 2636 14a2 05D1     		bne	.L197
 2637              	.L196:
 2638              		.loc 1 812 0
 2639 14a4 97F84B30 		ldrb	r3, [r7, #75]
 2640 14a8 43F00803 		orr	r3, r3, #8
 2641 14ac 87F84B30 		strb	r3, [r7, #75]
 2642              	.L197:
 813:gcode.c       ****           // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. F
 814:gcode.c       ****           //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of
 815:gcode.c       ****           //   an error, it issues an alarm to prevent further motion to the probe. It's also done 
 816:gcode.c       ****           //   allow the planner buffer to empty and move off the probe trigger before another prob
 817:gcode.c       ****           if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 2643              		.loc 1 817 0
 2644 14b0 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2645 14b4 002B     		cmp	r3, #0
 2646 14b6 01D1     		bne	.L198
 2647              		.loc 1 817 0 is_stmt 0 discriminator 1
 2648 14b8 1A23     		movs	r3, #26
 2649 14ba F0E2     		b	.L251
 2650              	.L198:
 818:gcode.c       ****           if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_
 2651              		.loc 1 818 0 is_stmt 1
 2652 14bc 0C22     		movs	r2, #12
 2653 14be 6349     		ldr	r1, .L291+28
 2654 14c0 6348     		ldr	r0, .L291+32
 2655 14c2 FFF7FEFF 		bl	memcmp
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 63


 2656 14c6 0346     		mov	r3, r0
 2657 14c8 002B     		cmp	r3, #0
 2658 14ca 03D1     		bne	.L277
 2659              		.loc 1 818 0 is_stmt 0 discriminator 1
 2660 14cc 2123     		movs	r3, #33
 2661 14ce E6E2     		b	.L251
 2662              	.L276:
 670:gcode.c       ****         case MOTION_MODE_CW_ARC: 
 2663              		.loc 1 670 0 is_stmt 1
 2664 14d0 00BF     		nop
 2665 14d2 00E0     		b	.L164
 2666              	.L277:
 819:gcode.c       ****           break;
 2667              		.loc 1 819 0
 2668 14d4 00BF     		nop
 2669              	.L164:
 2670              	.LBE2:
 820:gcode.c       ****       }
 821:gcode.c       ****     }
 822:gcode.c       ****   }
 823:gcode.c       **** 
 824:gcode.c       ****   // [21. Program flow ]: No error checks required.
 825:gcode.c       **** 
 826:gcode.c       ****   // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
 827:gcode.c       ****   // radius mode, or axis words that aren't used in the block.
 828:gcode.c       ****   if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 2671              		.loc 1 828 0
 2672 14d6 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2673 14da 03F00103 		and	r3, r3, #1
 2674 14de 002B     		cmp	r3, #0
 2675 14e0 06D0     		beq	.L200
 829:gcode.c       ****     // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
 830:gcode.c       ****     bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
 2676              		.loc 1 830 0
 2677 14e2 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 2678 14e6 23F02103 		bic	r3, r3, #33
 2679 14ea A7F84C30 		strh	r3, [r7, #76]	@ movhi
 2680 14ee 07E0     		b	.L201
 2681              	.L200:
 831:gcode.c       ****   } else {
 832:gcode.c       ****     bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-mean
 2682              		.loc 1 832 0
 2683 14f0 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 2684 14f4 23F44873 		bic	r3, r3, #800
 2685 14f8 23F00103 		bic	r3, r3, #1
 2686 14fc A7F84C30 		strh	r3, [r7, #76]	@ movhi
 2687              	.L201:
 833:gcode.c       ****   }
 834:gcode.c       ****   
 835:gcode.c       ****   if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z)|bit(WORD_A)|bit(WO
 2688              		.loc 1 835 0
 2689 1500 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 2690 1504 002B     		cmp	r3, #0
 2691 1506 05D0     		beq	.L202
 2692              		.loc 1 835 0 is_stmt 0 discriminator 1
 2693 1508 B7F84C30 		ldrh	r3, [r7, #76]	@ movhi
 2694 150c C3F30903 		ubfx	r3, r3, #0, #10
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 64


 2695 1510 A7F84C30 		strh	r3, [r7, #76]	@ movhi
 2696              	.L202:
 836:gcode.c       ****   if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
 2697              		.loc 1 836 0 is_stmt 1
 2698 1514 B7F84C30 		ldrh	r3, [r7, #76]
 2699 1518 002B     		cmp	r3, #0
 2700 151a 01D0     		beq	.L203
 2701              		.loc 1 836 0 is_stmt 0 discriminator 1
 2702 151c 2423     		movs	r3, #36
 2703 151e BEE2     		b	.L251
 2704              	.L203:
 837:gcode.c       **** 
 838:gcode.c       ****   /* -------------------------------------------------------------------------------------
 839:gcode.c       ****      STEP 4: EXECUTE!!
 840:gcode.c       ****      Assumes that all error-checking has been completed and no failure modes exist. We just
 841:gcode.c       ****      need to update the state and execute the block according to the order-of-execution.
 842:gcode.c       ****   */
 843:gcode.c       **** 
 844:gcode.c       ****   // Initialize planner data struct for motion blocks.
 845:gcode.c       ****   plan_line_data_t plan_data;
 846:gcode.c       ****   plan_line_data_t *pl_data = &plan_data;
 2705              		.loc 1 846 0 is_stmt 1
 2706 1520 07F10803 		add	r3, r7, #8
 2707 1524 BB62     		str	r3, [r7, #40]
 847:gcode.c       ****   memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
 2708              		.loc 1 847 0
 2709 1526 0C22     		movs	r2, #12
 2710 1528 0021     		movs	r1, #0
 2711 152a B86A     		ldr	r0, [r7, #40]
 2712 152c FFF7FEFF 		bl	memset
 848:gcode.c       **** 
 849:gcode.c       ****   // Intercept jog commands and complete error checking for valid jog commands and execute.
 850:gcode.c       ****   // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
 851:gcode.c       ****   // targets are computed correctly. The final parser position after a jog is updated in
 852:gcode.c       ****   // protocol_execute_realtime() when jogging completes or is canceled.
 853:gcode.c       ****   if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 2713              		.loc 1 853 0
 2714 1530 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2715 1534 03F00103 		and	r3, r3, #1
 2716 1538 002B     		cmp	r3, #0
 2717 153a 33D0     		beq	.L204
 2718              	.LBB7:
 854:gcode.c       ****     // Only distance and unit modal commands and G53 absolute override command are allowed.
 855:gcode.c       ****     // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
 856:gcode.c       ****     if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL
 2719              		.loc 1 856 0
 2720 153c B7F84E30 		ldrh	r3, [r7, #78]
 2721 1540 23F04903 		bic	r3, r3, #73
 2722 1544 002B     		cmp	r3, #0
 2723 1546 01D0     		beq	.L205
 2724              		.loc 1 856 0 is_stmt 0 discriminator 1
 2725 1548 1023     		movs	r3, #16
 2726 154a A8E2     		b	.L251
 2727              	.L205:
 857:gcode.c       ****     if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command =
 2728              		.loc 1 857 0 is_stmt 1
 2729 154c 3E4B     		ldr	r3, .L291+24
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 65


 2730 154e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2731 1550 352B     		cmp	r3, #53
 2732 1552 05D0     		beq	.L206
 2733              		.loc 1 857 0 is_stmt 0 discriminator 1
 2734 1554 3C4B     		ldr	r3, .L291+24
 2735 1556 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2736 1558 002B     		cmp	r3, #0
 2737 155a 01D0     		beq	.L206
 2738              		.loc 1 857 0 discriminator 2
 2739 155c 1023     		movs	r3, #16
 2740 155e 9EE2     		b	.L251
 2741              	.L206:
 858:gcode.c       **** 
 859:gcode.c       ****     // Initialize planner data to current spindle and coolant modal state.
 860:gcode.c       ****     pl_data->spindle_speed = gc_state.spindle_speed;
 2742              		.loc 1 860 0 is_stmt 1
 2743 1560 3C4B     		ldr	r3, .L291+36
 2744 1562 DA68     		ldr	r2, [r3, #12]	@ float
 2745 1564 BB6A     		ldr	r3, [r7, #40]
 2746 1566 5A60     		str	r2, [r3, #4]	@ float
 861:gcode.c       ****     plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 2747              		.loc 1 861 0
 2748 1568 3A4B     		ldr	r3, .L291+36
 2749 156a 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2750 156c 394B     		ldr	r3, .L291+36
 2751 156e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2752 1570 1343     		orrs	r3, r3, r2
 2753 1572 DBB2     		uxtb	r3, r3
 2754 1574 3B74     		strb	r3, [r7, #16]
 862:gcode.c       **** 
 863:gcode.c       ****     uint8_t status = jog_execute(&plan_data, &gc_block);
 2755              		.loc 1 863 0
 2756 1576 07F10803 		add	r3, r7, #8
 2757 157a 3349     		ldr	r1, .L291+24
 2758 157c 1846     		mov	r0, r3
 2759 157e FFF7FEFF 		bl	jog_execute
 2760 1582 0346     		mov	r3, r0
 2761 1584 87F82730 		strb	r3, [r7, #39]
 864:gcode.c       ****     if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.value
 2762              		.loc 1 864 0
 2763 1588 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 2764 158c 002B     		cmp	r3, #0
 2765 158e 06D1     		bne	.L207
 2766              		.loc 1 864 0 is_stmt 0 discriminator 1
 2767 1590 304B     		ldr	r3, .L291+36
 2768 1592 2D4A     		ldr	r2, .L291+24
 2769 1594 1C33     		adds	r3, r3, #28
 2770 1596 3432     		adds	r2, r2, #52
 2771 1598 07CA     		ldmia	r2, {r0, r1, r2}
 2772 159a 83E80700 		stmia	r3, {r0, r1, r2}
 2773              	.L207:
 865:gcode.c       ****     return(status);
 2774              		.loc 1 865 0 is_stmt 1
 2775 159e 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 2776 15a2 7CE2     		b	.L251
 2777              	.L204:
 2778              	.LBE7:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 66


 866:gcode.c       ****   }
 867:gcode.c       ****   
 868:gcode.c       ****   // If in laser mode, setup laser power based on current and past parser conditions.
 869:gcode.c       ****   if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 2779              		.loc 1 869 0
 2780 15a4 2C4B     		ldr	r3, .L291+40
 2781 15a6 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 2782 15aa 03F00203 		and	r3, r3, #2
 2783 15ae 002B     		cmp	r3, #0
 2784 15b0 60D0     		beq	.L208
 870:gcode.c       ****     if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_C
 2785              		.loc 1 870 0
 2786 15b2 254B     		ldr	r3, .L291+24
 2787 15b4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2788 15b6 012B     		cmp	r3, #1
 2789 15b8 0DD0     		beq	.L209
 2790              		.loc 1 870 0 is_stmt 0 discriminator 1
 2791 15ba 234B     		ldr	r3, .L291+24
 2792 15bc 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2793 15be 022B     		cmp	r3, #2
 2794 15c0 09D0     		beq	.L209
 871:gcode.c       ****         || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
 2795              		.loc 1 871 0 is_stmt 1 discriminator 2
 2796 15c2 214B     		ldr	r3, .L291+24
 2797 15c4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 870:gcode.c       ****     if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_C
 2798              		.loc 1 870 0 discriminator 2
 2799 15c6 032B     		cmp	r3, #3
 2800 15c8 05D0     		beq	.L209
 872:gcode.c       ****       gc_parser_flags |= GC_PARSER_LASER_DISABLE;
 2801              		.loc 1 872 0
 2802 15ca 97F84B30 		ldrb	r3, [r7, #75]
 2803 15ce 43F04003 		orr	r3, r3, #64
 2804 15d2 87F84B30 		strb	r3, [r7, #75]
 2805              	.L209:
 873:gcode.c       ****     }
 874:gcode.c       **** 
 875:gcode.c       ****     // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
 876:gcode.c       ****     // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitt
 877:gcode.c       ****     // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero lengt
 878:gcode.c       ****     if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
 2806              		.loc 1 878 0
 2807 15d6 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2808 15da 002B     		cmp	r3, #0
 2809 15dc 0AD0     		beq	.L210
 2810              		.loc 1 878 0 is_stmt 0 discriminator 1
 2811 15de 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 2812 15e2 022B     		cmp	r3, #2
 2813 15e4 06D1     		bne	.L210
 879:gcode.c       ****       gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
 2814              		.loc 1 879 0 is_stmt 1
 2815 15e6 97F84B30 		ldrb	r3, [r7, #75]
 2816 15ea 63F07F03 		orn	r3, r3, #127
 2817 15ee 87F84B30 		strb	r3, [r7, #75]
 2818 15f2 3FE0     		b	.L208
 2819              	.L210:
 880:gcode.c       ****     } else {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 67


 881:gcode.c       ****       // M3 constant power laser requires planner syncs to update the laser when changing between
 882:gcode.c       ****       // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
 883:gcode.c       ****       if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
 2820              		.loc 1 883 0
 2821 15f4 174B     		ldr	r3, .L291+36
 2822 15f6 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 2823 15f8 102B     		cmp	r3, #16
 2824 15fa 3BD1     		bne	.L208
 884:gcode.c       ****         if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_
 2825              		.loc 1 884 0
 2826 15fc 154B     		ldr	r3, .L291+36
 2827 15fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2828 1600 012B     		cmp	r3, #1
 2829 1602 07D0     		beq	.L211
 2830              		.loc 1 884 0 is_stmt 0 discriminator 1
 2831 1604 134B     		ldr	r3, .L291+36
 2832 1606 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2833 1608 022B     		cmp	r3, #2
 2834 160a 03D0     		beq	.L211
 885:gcode.c       ****             || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
 2835              		.loc 1 885 0 is_stmt 1
 2836 160c 114B     		ldr	r3, .L291+36
 2837 160e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2838 1610 032B     		cmp	r3, #3
 2839 1612 23D1     		bne	.L212
 2840              	.L211:
 886:gcode.c       ****           if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
 2841              		.loc 1 886 0
 2842 1614 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2843 1618 03F04003 		and	r3, r3, #64
 2844 161c 002B     		cmp	r3, #0
 2845 161e 29D0     		beq	.L208
 887:gcode.c       ****             gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
 2846              		.loc 1 887 0
 2847 1620 97F84B30 		ldrb	r3, [r7, #75]
 2848 1624 43F02003 		orr	r3, r3, #32
 2849 1628 87F84B30 		strb	r3, [r7, #75]
 886:gcode.c       ****           if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
 2850              		.loc 1 886 0
 2851 162c 22E0     		b	.L208
 2852              	.L292:
 2853 162e 00BF     		.align	3
 2854              	.L291:
 2855 1630 66666666 		.word	1717986918
 2856 1634 66663940 		.word	1077503590
 2857 1638 7B14AE47 		.word	1202590843
 2858 163c E17A743F 		.word	1064598241
 2859 1640 FCA9F1D2 		.word	-755914244
 2860 1644 4D62503F 		.word	1062232653
 2861 1648 00000000 		.word	gc_block
 2862 164c 34000000 		.word	gc_block+52
 2863 1650 1C000000 		.word	gc_state+28
 2864 1654 00000000 		.word	gc_state
 2865 1658 00000000 		.word	settings
 2866              	.L212:
 888:gcode.c       ****           }
 889:gcode.c       ****         } else {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 68


 890:gcode.c       ****           // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
 891:gcode.c       ****           if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
 2867              		.loc 1 891 0
 2868 165c 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2869 1660 03F04003 		and	r3, r3, #64
 2870 1664 002B     		cmp	r3, #0
 2871 1666 05D1     		bne	.L208
 892:gcode.c       ****             gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
 2872              		.loc 1 892 0
 2873 1668 97F84B30 		ldrb	r3, [r7, #75]
 2874 166c 43F02003 		orr	r3, r3, #32
 2875 1670 87F84B30 		strb	r3, [r7, #75]
 2876              	.L208:
 893:gcode.c       ****           }
 894:gcode.c       ****         } 
 895:gcode.c       ****       }
 896:gcode.c       ****     }
 897:gcode.c       ****   }
 898:gcode.c       **** 
 899:gcode.c       ****   // [0. Non-specific/common error-checks and miscellaneous setup]:
 900:gcode.c       ****   // NOTE: If no line number is present, the value is zero.
 901:gcode.c       ****   gc_state.line_number = gc_block.values.n;
 2877              		.loc 1 901 0
 2878 1674 9D4B     		ldr	r3, .L293
 2879 1676 1B6A     		ldr	r3, [r3, #32]
 2880 1678 9D4A     		ldr	r2, .L293+4
 2881 167a 9361     		str	r3, [r2, #24]
 902:gcode.c       ****   #ifdef USE_LINE_NUMBERS
 903:gcode.c       ****     pl_data->line_number = gc_state.line_number; // Record data for planner use.
 904:gcode.c       ****   #endif
 905:gcode.c       **** 
 906:gcode.c       ****   // [1. Comments feedback ]:  NOT SUPPORTED
 907:gcode.c       **** 
 908:gcode.c       ****   // [2. Set feed rate mode ]:
 909:gcode.c       ****   gc_state.modal.feed_rate = gc_block.modal.feed_rate;
 2882              		.loc 1 909 0
 2883 167c 9B4B     		ldr	r3, .L293
 2884 167e 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 2885 1680 9B4B     		ldr	r3, .L293+4
 2886 1682 5A70     		strb	r2, [r3, #1]
 910:gcode.c       ****   if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set conditi
 2887              		.loc 1 910 0
 2888 1684 9A4B     		ldr	r3, .L293+4
 2889 1686 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2890 1688 002B     		cmp	r3, #0
 2891 168a 06D0     		beq	.L214
 2892              		.loc 1 910 0 is_stmt 0 discriminator 1
 2893 168c BB6A     		ldr	r3, [r7, #40]
 2894 168e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2895 1690 43F00803 		orr	r3, r3, #8
 2896 1694 DAB2     		uxtb	r2, r3
 2897 1696 BB6A     		ldr	r3, [r7, #40]
 2898 1698 1A72     		strb	r2, [r3, #8]
 2899              	.L214:
 911:gcode.c       **** 
 912:gcode.c       ****   // [3. Set feed rate ]:
 913:gcode.c       ****   gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 69


 2900              		.loc 1 913 0 is_stmt 1
 2901 169a 944B     		ldr	r3, .L293
 2902 169c DB68     		ldr	r3, [r3, #12]	@ float
 2903 169e 944A     		ldr	r2, .L293+4
 2904 16a0 1361     		str	r3, [r2, #16]	@ float
 914:gcode.c       ****   pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
 2905              		.loc 1 914 0
 2906 16a2 934B     		ldr	r3, .L293+4
 2907 16a4 1A69     		ldr	r2, [r3, #16]	@ float
 2908 16a6 BB6A     		ldr	r3, [r7, #40]
 2909 16a8 1A60     		str	r2, [r3]	@ float
 915:gcode.c       **** 
 916:gcode.c       ****   // [4. Set spindle speed ]:
 917:gcode.c       ****   if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_F
 2910              		.loc 1 917 0
 2911 16aa 914B     		ldr	r3, .L293+4
 2912 16ac DA68     		ldr	r2, [r3, #12]	@ float
 2913 16ae 8F4B     		ldr	r3, .L293
 2914 16b0 DB6A     		ldr	r3, [r3, #44]	@ float
 2915 16b2 1946     		mov	r1, r3
 2916 16b4 1046     		mov	r0, r2
 2917 16b6 FFF7FEFF 		bl	__aeabi_fcmpeq
 2918 16ba 0346     		mov	r3, r0
 2919 16bc 002B     		cmp	r3, #0
 2920 16be 05D0     		beq	.L215
 2921              		.loc 1 917 0 is_stmt 0 discriminator 1
 2922 16c0 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2923 16c4 03F02003 		and	r3, r3, #32
 2924 16c8 002B     		cmp	r3, #0
 2925 16ca 21D0     		beq	.L216
 2926              	.L215:
 918:gcode.c       ****     if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
 2927              		.loc 1 918 0 is_stmt 1
 2928 16cc 884B     		ldr	r3, .L293+4
 2929 16ce 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 2930 16d0 002B     		cmp	r3, #0
 2931 16d2 19D0     		beq	.L217
 919:gcode.c       ****       #ifdef VARIABLE_SPINDLE
 920:gcode.c       ****         if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
 2932              		.loc 1 920 0
 2933 16d4 97F94B30 		ldrsb	r3, [r7, #75]
 2934 16d8 002B     		cmp	r3, #0
 2935 16da 15DB     		blt	.L217
 921:gcode.c       ****           if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
 2936              		.loc 1 921 0
 2937 16dc 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2938 16e0 03F04003 		and	r3, r3, #64
 2939 16e4 002B     		cmp	r3, #0
 2940 16e6 07D0     		beq	.L218
 922:gcode.c       ****              spindle_sync(gc_state.modal.spindle, 0.0);
 2941              		.loc 1 922 0
 2942 16e8 814B     		ldr	r3, .L293+4
 2943 16ea 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 2944 16ec 4FF00001 		mov	r1, #0
 2945 16f0 1846     		mov	r0, r3
 2946 16f2 FFF7FEFF 		bl	spindle_sync
 2947 16f6 07E0     		b	.L217
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 70


 2948              	.L218:
 923:gcode.c       ****           } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
 2949              		.loc 1 923 0
 2950 16f8 7D4B     		ldr	r3, .L293+4
 2951 16fa 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2952 16fc 7B4B     		ldr	r3, .L293
 2953 16fe DB6A     		ldr	r3, [r3, #44]	@ float
 2954 1700 1946     		mov	r1, r3
 2955 1702 1046     		mov	r0, r2
 2956 1704 FFF7FEFF 		bl	spindle_sync
 2957              	.L217:
 924:gcode.c       ****         }
 925:gcode.c       ****       #else
 926:gcode.c       ****         spindle_sync(gc_state.modal.spindle, 0.0);
 927:gcode.c       ****       #endif
 928:gcode.c       ****     }
 929:gcode.c       ****     gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
 2958              		.loc 1 929 0
 2959 1708 784B     		ldr	r3, .L293
 2960 170a DB6A     		ldr	r3, [r3, #44]	@ float
 2961 170c 784A     		ldr	r2, .L293+4
 2962 170e D360     		str	r3, [r2, #12]	@ float
 2963              	.L216:
 930:gcode.c       ****   }
 931:gcode.c       ****   // NOTE: Pass zero spindle speed for all restricted laser motions.
 932:gcode.c       ****   if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
 2964              		.loc 1 932 0
 2965 1710 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 2966 1714 03F04003 		and	r3, r3, #64
 2967 1718 002B     		cmp	r3, #0
 2968 171a 03D1     		bne	.L219
 933:gcode.c       ****     pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
 2969              		.loc 1 933 0
 2970 171c 744B     		ldr	r3, .L293+4
 2971 171e DA68     		ldr	r2, [r3, #12]	@ float
 2972 1720 BB6A     		ldr	r3, [r7, #40]
 2973 1722 5A60     		str	r2, [r3, #4]	@ float
 2974              	.L219:
 934:gcode.c       ****   } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
 935:gcode.c       ****   
 936:gcode.c       ****   // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
 937:gcode.c       ****   gc_state.tool = gc_block.values.t;
 2975              		.loc 1 937 0
 2976 1724 714B     		ldr	r3, .L293
 2977 1726 93F83020 		ldrb	r2, [r3, #48]	@ zero_extendqisi2
 2978 172a 714B     		ldr	r3, .L293+4
 2979 172c 1A75     		strb	r2, [r3, #20]
 938:gcode.c       **** 
 939:gcode.c       ****   // [6. Change tool ]: NOT SUPPORTED
 940:gcode.c       **** 
 941:gcode.c       ****   // [7. Spindle control ]:
 942:gcode.c       ****   if (gc_state.modal.spindle != gc_block.modal.spindle) {
 2980              		.loc 1 942 0
 2981 172e 704B     		ldr	r3, .L293+4
 2982 1730 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2983 1732 6E4B     		ldr	r3, .L293
 2984 1734 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 71


 2985 1736 9A42     		cmp	r2, r3
 2986 1738 0BD0     		beq	.L220
 943:gcode.c       ****     // Update spindle control and apply spindle speed when enabling it in this block.
 944:gcode.c       ****     // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
 945:gcode.c       ****     // rather than gc_state, is used to manage laser state for non-laser motions.
 946:gcode.c       ****     spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
 2987              		.loc 1 946 0
 2988 173a 6C4B     		ldr	r3, .L293
 2989 173c 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 2990 173e BB6A     		ldr	r3, [r7, #40]
 2991 1740 5B68     		ldr	r3, [r3, #4]	@ float
 2992 1742 1946     		mov	r1, r3
 2993 1744 1046     		mov	r0, r2
 2994 1746 FFF7FEFF 		bl	spindle_sync
 947:gcode.c       ****     gc_state.modal.spindle = gc_block.modal.spindle;
 2995              		.loc 1 947 0
 2996 174a 684B     		ldr	r3, .L293
 2997 174c 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 2998 174e 684B     		ldr	r3, .L293+4
 2999 1750 5A72     		strb	r2, [r3, #9]
 3000              	.L220:
 948:gcode.c       ****   }
 949:gcode.c       ****   pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
 3001              		.loc 1 949 0
 3002 1752 BB6A     		ldr	r3, [r7, #40]
 3003 1754 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3004 1756 664B     		ldr	r3, .L293+4
 3005 1758 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 3006 175a 1343     		orrs	r3, r3, r2
 3007 175c DAB2     		uxtb	r2, r3
 3008 175e BB6A     		ldr	r3, [r7, #40]
 3009 1760 1A72     		strb	r2, [r3, #8]
 950:gcode.c       **** 
 951:gcode.c       ****   // [8. Coolant control ]:
 952:gcode.c       ****   if (gc_state.modal.coolant != gc_block.modal.coolant) {
 3010              		.loc 1 952 0
 3011 1762 634B     		ldr	r3, .L293+4
 3012 1764 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3013 1766 614B     		ldr	r3, .L293
 3014 1768 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 3015 176a 9A42     		cmp	r2, r3
 3016 176c 14D0     		beq	.L221
 953:gcode.c       ****     // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
 954:gcode.c       ****     // can exist at the same time, while coolant disable clears all states.
 955:gcode.c       ****     coolant_sync(gc_block.modal.coolant);
 3017              		.loc 1 955 0
 3018 176e 5F4B     		ldr	r3, .L293
 3019 1770 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 3020 1772 1846     		mov	r0, r3
 3021 1774 FFF7FEFF 		bl	coolant_sync
 956:gcode.c       ****     if (gc_block.modal.coolant == COOLANT_DISABLE) { gc_state.modal.coolant = COOLANT_DISABLE; }
 3022              		.loc 1 956 0
 3023 1778 5C4B     		ldr	r3, .L293
 3024 177a 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 3025 177c 002B     		cmp	r3, #0
 3026 177e 03D1     		bne	.L222
 3027              		.loc 1 956 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 72


 3028 1780 5B4B     		ldr	r3, .L293+4
 3029 1782 0022     		movs	r2, #0
 3030 1784 1A72     		strb	r2, [r3, #8]
 3031 1786 07E0     		b	.L221
 3032              	.L222:
 957:gcode.c       ****     else { gc_state.modal.coolant |= gc_block.modal.coolant; }
 3033              		.loc 1 957 0 is_stmt 1
 3034 1788 594B     		ldr	r3, .L293+4
 3035 178a 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3036 178c 574B     		ldr	r3, .L293
 3037 178e 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 3038 1790 1343     		orrs	r3, r3, r2
 3039 1792 DAB2     		uxtb	r2, r3
 3040 1794 564B     		ldr	r3, .L293+4
 3041 1796 1A72     		strb	r2, [r3, #8]
 3042              	.L221:
 958:gcode.c       ****   }
 959:gcode.c       ****   pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
 3043              		.loc 1 959 0
 3044 1798 BB6A     		ldr	r3, [r7, #40]
 3045 179a 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3046 179c 544B     		ldr	r3, .L293+4
 3047 179e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3048 17a0 1343     		orrs	r3, r3, r2
 3049 17a2 DAB2     		uxtb	r2, r3
 3050 17a4 BB6A     		ldr	r3, [r7, #40]
 3051 17a6 1A72     		strb	r2, [r3, #8]
 960:gcode.c       **** 
 961:gcode.c       ****   // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED. Always enabled.
 962:gcode.c       **** 
 963:gcode.c       ****   // [10. Dwell ]:
 964:gcode.c       ****   if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
 3052              		.loc 1 964 0
 3053 17a8 504B     		ldr	r3, .L293
 3054 17aa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3055 17ac 042B     		cmp	r3, #4
 3056 17ae 04D1     		bne	.L223
 3057              		.loc 1 964 0 is_stmt 0 discriminator 1
 3058 17b0 4E4B     		ldr	r3, .L293
 3059 17b2 5B6A     		ldr	r3, [r3, #36]	@ float
 3060 17b4 1846     		mov	r0, r3
 3061 17b6 FFF7FEFF 		bl	mc_dwell
 3062              	.L223:
 965:gcode.c       **** 
 966:gcode.c       ****   // [11. Set active plane ]:
 967:gcode.c       ****   gc_state.modal.plane_select = gc_block.modal.plane_select;
 3063              		.loc 1 967 0 is_stmt 1
 3064 17ba 4C4B     		ldr	r3, .L293
 3065 17bc 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 3066 17be 4C4B     		ldr	r3, .L293+4
 3067 17c0 1A71     		strb	r2, [r3, #4]
 968:gcode.c       **** 
 969:gcode.c       ****   // [12. Set length units ]:
 970:gcode.c       ****   gc_state.modal.units = gc_block.modal.units;
 3068              		.loc 1 970 0
 3069 17c2 4A4B     		ldr	r3, .L293
 3070 17c4 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 73


 3071 17c6 4A4B     		ldr	r3, .L293+4
 3072 17c8 9A70     		strb	r2, [r3, #2]
 971:gcode.c       **** 
 972:gcode.c       ****   // [13. Cutter radius compensation ]: G41/42 NOT SUPPORTED
 973:gcode.c       ****   // gc_state.modal.cutter_comp = gc_block.modal.cutter_comp; // NOTE: Not needed since always disa
 974:gcode.c       **** 
 975:gcode.c       ****   // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
 976:gcode.c       ****   // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
 977:gcode.c       ****   // of execution. The error-checking step would simply load the offset value into the correct
 978:gcode.c       ****   // axis of the block XYZ value array.
 979:gcode.c       ****   if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
 3073              		.loc 1 979 0
 3074 17ca 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 3075 17ce 032B     		cmp	r3, #3
 3076 17d0 1CD1     		bne	.L224
 980:gcode.c       ****     gc_state.modal.tool_length = gc_block.modal.tool_length;
 3077              		.loc 1 980 0
 3078 17d2 464B     		ldr	r3, .L293
 3079 17d4 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3080 17d6 464B     		ldr	r3, .L293+4
 3081 17d8 5A71     		strb	r2, [r3, #5]
 981:gcode.c       ****     if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
 3082              		.loc 1 981 0
 3083 17da 454B     		ldr	r3, .L293+4
 3084 17dc 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 3085 17de 002B     		cmp	r3, #0
 3086 17e0 03D1     		bne	.L225
 982:gcode.c       ****       gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
 3087              		.loc 1 982 0
 3088 17e2 424B     		ldr	r3, .L293
 3089 17e4 4FF00002 		mov	r2, #0
 3090 17e8 DA63     		str	r2, [r3, #60]	@ float
 3091              	.L225:
 983:gcode.c       ****     } // else G43.1
 984:gcode.c       ****     if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
 3092              		.loc 1 984 0
 3093 17ea 414B     		ldr	r3, .L293+4
 3094 17ec 1A6C     		ldr	r2, [r3, #64]	@ float
 3095 17ee 3F4B     		ldr	r3, .L293
 3096 17f0 DB6B     		ldr	r3, [r3, #60]	@ float
 3097 17f2 1946     		mov	r1, r3
 3098 17f4 1046     		mov	r0, r2
 3099 17f6 FFF7FEFF 		bl	__aeabi_fcmpeq
 3100 17fa 0346     		mov	r3, r0
 3101 17fc 002B     		cmp	r3, #0
 3102 17fe 05D1     		bne	.L224
 985:gcode.c       ****       gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
 3103              		.loc 1 985 0
 3104 1800 3A4B     		ldr	r3, .L293
 3105 1802 DB6B     		ldr	r3, [r3, #60]	@ float
 3106 1804 3A4A     		ldr	r2, .L293+4
 3107 1806 1364     		str	r3, [r2, #64]	@ float
 986:gcode.c       ****       system_flag_wco_change();
 3108              		.loc 1 986 0
 3109 1808 FFF7FEFF 		bl	system_flag_wco_change
 3110              	.L224:
 987:gcode.c       ****     }
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 74


 988:gcode.c       ****   }
 989:gcode.c       **** 
 990:gcode.c       ****   // [15. Coordinate system selection ]:
 991:gcode.c       ****   if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 3111              		.loc 1 991 0
 3112 180c 384B     		ldr	r3, .L293+4
 3113 180e 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3114 1810 364B     		ldr	r3, .L293
 3115 1812 DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 3116 1814 9A42     		cmp	r2, r3
 3117 1816 0CD0     		beq	.L227
 992:gcode.c       ****     gc_state.modal.coord_select = gc_block.modal.coord_select;
 3118              		.loc 1 992 0
 3119 1818 344B     		ldr	r3, .L293
 3120 181a DA79     		ldrb	r2, [r3, #7]	@ zero_extendqisi2
 3121 181c 344B     		ldr	r3, .L293+4
 3122 181e 9A71     		strb	r2, [r3, #6]
 993:gcode.c       ****     memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
 3123              		.loc 1 993 0
 3124 1820 334B     		ldr	r3, .L293+4
 3125 1822 2833     		adds	r3, r3, #40
 3126 1824 07F11402 		add	r2, r7, #20
 3127 1828 07CA     		ldmia	r2, {r0, r1, r2}
 3128 182a 83E80700 		stmia	r3, {r0, r1, r2}
 994:gcode.c       ****     system_flag_wco_change();
 3129              		.loc 1 994 0
 3130 182e FFF7FEFF 		bl	system_flag_wco_change
 3131              	.L227:
 995:gcode.c       ****   }
 996:gcode.c       **** 
 997:gcode.c       ****   // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
 998:gcode.c       ****   // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
 999:gcode.c       **** 
1000:gcode.c       ****   // [17. Set distance mode ]:
1001:gcode.c       ****   gc_state.modal.distance = gc_block.modal.distance;
 3132              		.loc 1 1001 0
 3133 1832 2E4B     		ldr	r3, .L293
 3134 1834 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 3135 1836 2E4B     		ldr	r3, .L293+4
 3136 1838 DA70     		strb	r2, [r3, #3]
1002:gcode.c       **** 
1003:gcode.c       ****   // [18. Set retract mode ]: NOT SUPPORTED
1004:gcode.c       **** 
1005:gcode.c       ****   // [19. Go to predefined position, Set G10, or Set axis offsets ]:
1006:gcode.c       ****   switch(gc_block.non_modal_command) {
 3137              		.loc 1 1006 0
 3138 183a 2C4B     		ldr	r3, .L293
 3139 183c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3140 183e 262B     		cmp	r3, #38
 3141 1840 40D0     		beq	.L229
 3142 1842 262B     		cmp	r3, #38
 3143 1844 06DC     		bgt	.L230
 3144 1846 1C2B     		cmp	r3, #28
 3145 1848 21D0     		beq	.L231
 3146 184a 1E2B     		cmp	r3, #30
 3147 184c 1FD0     		beq	.L231
 3148 184e 0A2B     		cmp	r3, #10
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 75


 3149 1850 07D0     		beq	.L232
 3150 1852 5EE0     		b	.L228
 3151              	.L230:
 3152 1854 5C2B     		cmp	r3, #92
 3153 1856 3FD0     		beq	.L233
 3154 1858 662B     		cmp	r3, #102
 3155 185a 51D0     		beq	.L234
 3156 185c 282B     		cmp	r3, #40
 3157 185e 36D0     		beq	.L235
 3158 1860 57E0     		b	.L228
 3159              	.L232:
1007:gcode.c       ****     case NON_MODAL_SET_COORDINATE_DATA:
1008:gcode.c       ****       settings_write_coord_data(coord_select,gc_block.values.ijk);
 3160              		.loc 1 1008 0
 3161 1862 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 3162 1866 2349     		ldr	r1, .L293+8
 3163 1868 1846     		mov	r0, r3
 3164 186a FFF7FEFF 		bl	settings_write_coord_data
1009:gcode.c       ****       // Update system coordinate system if currently active.
1010:gcode.c       ****       if (gc_state.modal.coord_select == coord_select) {
 3165              		.loc 1 1010 0
 3166 186e 204B     		ldr	r3, .L293+4
 3167 1870 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 3168 1872 97F85320 		ldrb	r2, [r7, #83]	@ zero_extendqisi2
 3169 1876 9A42     		cmp	r2, r3
 3170 1878 4AD1     		bne	.L278
1011:gcode.c       ****         memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
 3171              		.loc 1 1011 0
 3172 187a 1D4B     		ldr	r3, .L293+4
 3173 187c 1B4A     		ldr	r2, .L293
 3174 187e 2833     		adds	r3, r3, #40
 3175 1880 1032     		adds	r2, r2, #16
 3176 1882 07CA     		ldmia	r2, {r0, r1, r2}
 3177 1884 83E80700 		stmia	r3, {r0, r1, r2}
1012:gcode.c       ****         system_flag_wco_change();
 3178              		.loc 1 1012 0
 3179 1888 FFF7FEFF 		bl	system_flag_wco_change
1013:gcode.c       ****       }
1014:gcode.c       ****       break;
 3180              		.loc 1 1014 0
 3181 188c 40E0     		b	.L278
 3182              	.L231:
1015:gcode.c       ****     case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
1016:gcode.c       ****       // Move to intermediate position before going home. Obeys current coordinate system and offse
1017:gcode.c       ****       // and absolute and incremental modes.
1018:gcode.c       ****       pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 3183              		.loc 1 1018 0
 3184 188e BB6A     		ldr	r3, [r7, #40]
 3185 1890 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3186 1892 43F00103 		orr	r3, r3, #1
 3187 1896 DAB2     		uxtb	r2, r3
 3188 1898 BB6A     		ldr	r3, [r7, #40]
 3189 189a 1A72     		strb	r2, [r3, #8]
1019:gcode.c       ****       if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
 3190              		.loc 1 1019 0
 3191 189c 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 3192 18a0 002B     		cmp	r3, #0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 76


 3193 18a2 03D0     		beq	.L237
 3194              		.loc 1 1019 0 is_stmt 0 discriminator 1
 3195 18a4 B96A     		ldr	r1, [r7, #40]
 3196 18a6 1448     		ldr	r0, .L293+12
 3197 18a8 FFF7FEFF 		bl	mc_line
 3198              	.L237:
1020:gcode.c       ****       mc_line(gc_block.values.ijk, pl_data);
 3199              		.loc 1 1020 0 is_stmt 1
 3200 18ac B96A     		ldr	r1, [r7, #40]
 3201 18ae 1148     		ldr	r0, .L293+8
 3202 18b0 FFF7FEFF 		bl	mc_line
1021:gcode.c       ****       memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
 3203              		.loc 1 1021 0
 3204 18b4 0E4B     		ldr	r3, .L293+4
 3205 18b6 0D4A     		ldr	r2, .L293
 3206 18b8 1C33     		adds	r3, r3, #28
 3207 18ba 1032     		adds	r2, r2, #16
 3208 18bc 07CA     		ldmia	r2, {r0, r1, r2}
 3209 18be 83E80700 		stmia	r3, {r0, r1, r2}
1022:gcode.c       ****       break;
 3210              		.loc 1 1022 0
 3211 18c2 26E0     		b	.L228
 3212              	.L229:
1023:gcode.c       ****     case NON_MODAL_SET_HOME_0:
1024:gcode.c       ****       settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
 3213              		.loc 1 1024 0
 3214 18c4 0D49     		ldr	r1, .L293+16
 3215 18c6 0620     		movs	r0, #6
 3216 18c8 FFF7FEFF 		bl	settings_write_coord_data
1025:gcode.c       ****       break;
 3217              		.loc 1 1025 0
 3218 18cc 21E0     		b	.L228
 3219              	.L235:
1026:gcode.c       ****     case NON_MODAL_SET_HOME_1:
1027:gcode.c       ****       settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
 3220              		.loc 1 1027 0
 3221 18ce 0B49     		ldr	r1, .L293+16
 3222 18d0 0720     		movs	r0, #7
 3223 18d2 FFF7FEFF 		bl	settings_write_coord_data
1028:gcode.c       ****       break;
 3224              		.loc 1 1028 0
 3225 18d6 1CE0     		b	.L228
 3226              	.L233:
1029:gcode.c       ****     case NON_MODAL_SET_COORDINATE_OFFSET:
1030:gcode.c       ****       memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
 3227              		.loc 1 1030 0
 3228 18d8 054B     		ldr	r3, .L293+4
 3229 18da 044A     		ldr	r2, .L293
 3230 18dc 3433     		adds	r3, r3, #52
 3231 18de 3432     		adds	r2, r2, #52
 3232 18e0 07CA     		ldmia	r2, {r0, r1, r2}
 3233 18e2 83E80700 		stmia	r3, {r0, r1, r2}
1031:gcode.c       ****       system_flag_wco_change();
 3234              		.loc 1 1031 0
 3235 18e6 FFF7FEFF 		bl	system_flag_wco_change
1032:gcode.c       ****       break;
 3236              		.loc 1 1032 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 77


 3237 18ea 12E0     		b	.L228
 3238              	.L294:
 3239              		.align	2
 3240              	.L293:
 3241 18ec 00000000 		.word	gc_block
 3242 18f0 00000000 		.word	gc_state
 3243 18f4 10000000 		.word	gc_block+16
 3244 18f8 34000000 		.word	gc_block+52
 3245 18fc 1C000000 		.word	gc_state+28
 3246              	.L234:
1033:gcode.c       ****     case NON_MODAL_RESET_COORDINATE_OFFSET:
1034:gcode.c       ****       clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
 3247              		.loc 1 1034 0
 3248 1900 0C22     		movs	r2, #12
 3249 1902 0021     		movs	r1, #0
 3250 1904 6848     		ldr	r0, .L295
 3251 1906 FFF7FEFF 		bl	memset
1035:gcode.c       ****       system_flag_wco_change();
 3252              		.loc 1 1035 0
 3253 190a FFF7FEFF 		bl	system_flag_wco_change
1036:gcode.c       ****       break;
 3254              		.loc 1 1036 0
 3255 190e 00E0     		b	.L228
 3256              	.L278:
1014:gcode.c       ****     case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
 3257              		.loc 1 1014 0
 3258 1910 00BF     		nop
 3259              	.L228:
1037:gcode.c       ****   }
1038:gcode.c       **** 
1039:gcode.c       **** 
1040:gcode.c       ****   // [20. Motion modes ]:
1041:gcode.c       ****   // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
1042:gcode.c       ****   // Enter motion modes only if there are axis words or a motion mode command word in the block.
1043:gcode.c       ****   gc_state.modal.motion = gc_block.modal.motion;
 3260              		.loc 1 1043 0
 3261 1912 664B     		ldr	r3, .L295+4
 3262 1914 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 3263 1916 664B     		ldr	r3, .L295+8
 3264 1918 1A70     		strb	r2, [r3]
1044:gcode.c       ****   if (gc_state.modal.motion != MOTION_MODE_NONE) {
 3265              		.loc 1 1044 0
 3266 191a 654B     		ldr	r3, .L295+8
 3267 191c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3268 191e 502B     		cmp	r3, #80
 3269 1920 67D0     		beq	.L238
1045:gcode.c       ****     if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 3270              		.loc 1 1045 0
 3271 1922 97F85730 		ldrb	r3, [r7, #87]	@ zero_extendqisi2
 3272 1926 022B     		cmp	r3, #2
 3273 1928 63D1     		bne	.L238
 3274              	.LBB8:
1046:gcode.c       ****       uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
 3275              		.loc 1 1046 0
 3276 192a 0023     		movs	r3, #0
 3277 192c 87F83F30 		strb	r3, [r7, #63]
1047:gcode.c       ****       if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 78


 3278              		.loc 1 1047 0
 3279 1930 5F4B     		ldr	r3, .L295+8
 3280 1932 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3281 1934 012B     		cmp	r3, #1
 3282 1936 04D1     		bne	.L239
1048:gcode.c       ****         mc_line(gc_block.values.xyz, pl_data);
 3283              		.loc 1 1048 0
 3284 1938 B96A     		ldr	r1, [r7, #40]
 3285 193a 5E48     		ldr	r0, .L295+12
 3286 193c FFF7FEFF 		bl	mc_line
 3287 1940 45E0     		b	.L240
 3288              	.L239:
1049:gcode.c       ****       } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
 3289              		.loc 1 1049 0
 3290 1942 5B4B     		ldr	r3, .L295+8
 3291 1944 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3292 1946 002B     		cmp	r3, #0
 3293 1948 0BD1     		bne	.L241
1050:gcode.c       ****         pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 3294              		.loc 1 1050 0
 3295 194a BB6A     		ldr	r3, [r7, #40]
 3296 194c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3297 194e 43F00103 		orr	r3, r3, #1
 3298 1952 DAB2     		uxtb	r2, r3
 3299 1954 BB6A     		ldr	r3, [r7, #40]
 3300 1956 1A72     		strb	r2, [r3, #8]
1051:gcode.c       ****         mc_line(gc_block.values.xyz, pl_data);
 3301              		.loc 1 1051 0
 3302 1958 B96A     		ldr	r1, [r7, #40]
 3303 195a 5648     		ldr	r0, .L295+12
 3304 195c FFF7FEFF 		bl	mc_line
 3305 1960 35E0     		b	.L240
 3306              	.L241:
1052:gcode.c       ****       } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_
 3307              		.loc 1 1052 0
 3308 1962 534B     		ldr	r3, .L295+8
 3309 1964 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3310 1966 022B     		cmp	r3, #2
 3311 1968 03D0     		beq	.L242
 3312              		.loc 1 1052 0 is_stmt 0 discriminator 1
 3313 196a 514B     		ldr	r3, .L295+8
 3314 196c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3315 196e 032B     		cmp	r3, #3
 3316 1970 1CD1     		bne	.L243
 3317              	.L242:
1053:gcode.c       ****         mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.value
 3318              		.loc 1 1053 0 is_stmt 1
 3319 1972 4E4B     		ldr	r3, .L295+4
 3320 1974 9B6A     		ldr	r3, [r3, #40]	@ float
1054:gcode.c       ****             axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
 3321              		.loc 1 1054 0
 3322 1976 97F84B20 		ldrb	r2, [r7, #75]	@ zero_extendqisi2
 3323 197a 02F00402 		and	r2, r2, #4
1053:gcode.c       ****         mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.value
 3324              		.loc 1 1053 0
 3325 197e 002A     		cmp	r2, #0
 3326 1980 14BF     		ite	ne
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 79


 3327 1982 0122     		movne	r2, #1
 3328 1984 0022     		moveq	r2, #0
 3329 1986 D2B2     		uxtb	r2, r2
 3330 1988 0492     		str	r2, [sp, #16]
 3331 198a 97F85420 		ldrb	r2, [r7, #84]	@ zero_extendqisi2
 3332 198e 0392     		str	r2, [sp, #12]
 3333 1990 97F85520 		ldrb	r2, [r7, #85]	@ zero_extendqisi2
 3334 1994 0292     		str	r2, [sp, #8]
 3335 1996 97F85620 		ldrb	r2, [r7, #86]	@ zero_extendqisi2
 3336 199a 0192     		str	r2, [sp, #4]
 3337 199c 0093     		str	r3, [sp]	@ float
 3338 199e 464B     		ldr	r3, .L295+16
 3339 19a0 464A     		ldr	r2, .L295+20
 3340 19a2 B96A     		ldr	r1, [r7, #40]
 3341 19a4 4348     		ldr	r0, .L295+12
 3342 19a6 FFF7FEFF 		bl	mc_arc
 3343 19aa 10E0     		b	.L240
 3344              	.L243:
1055:gcode.c       ****       } else {
1056:gcode.c       ****         // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position valu
1057:gcode.c       ****         // upon a successful probing cycle, the machine position and the returned value should be t
1058:gcode.c       ****         #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
1059:gcode.c       ****           pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
 3345              		.loc 1 1059 0
 3346 19ac BB6A     		ldr	r3, [r7, #40]
 3347 19ae 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3348 19b0 43F00403 		orr	r3, r3, #4
 3349 19b4 DAB2     		uxtb	r2, r3
 3350 19b6 BB6A     		ldr	r3, [r7, #40]
 3351 19b8 1A72     		strb	r2, [r3, #8]
1060:gcode.c       ****         #endif
1061:gcode.c       ****         gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
 3352              		.loc 1 1061 0
 3353 19ba 97F84B30 		ldrb	r3, [r7, #75]	@ zero_extendqisi2
 3354 19be 1A46     		mov	r2, r3
 3355 19c0 B96A     		ldr	r1, [r7, #40]
 3356 19c2 3C48     		ldr	r0, .L295+12
 3357 19c4 FFF7FEFF 		bl	mc_probe_cycle
 3358 19c8 0346     		mov	r3, r0
 3359 19ca 87F83F30 		strb	r3, [r7, #63]
 3360              	.L240:
1062:gcode.c       ****       }  
1063:gcode.c       ****      
1064:gcode.c       ****       // As far as the parser is concerned, the position is now == target. In reality the
1065:gcode.c       ****       // motion control system might still be processing the action and the real tool position
1066:gcode.c       ****       // in any intermediate location.
1067:gcode.c       ****       if (gc_update_pos == GC_UPDATE_POS_TARGET) {
 3361              		.loc 1 1067 0
 3362 19ce 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 3363 19d2 002B     		cmp	r3, #0
 3364 19d4 07D1     		bne	.L244
1068:gcode.c       ****         memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.po
 3365              		.loc 1 1068 0
 3366 19d6 364B     		ldr	r3, .L295+8
 3367 19d8 344A     		ldr	r2, .L295+4
 3368 19da 1C33     		adds	r3, r3, #28
 3369 19dc 3432     		adds	r2, r2, #52
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 80


 3370 19de 07CA     		ldmia	r2, {r0, r1, r2}
 3371 19e0 83E80700 		stmia	r3, {r0, r1, r2}
 3372 19e4 05E0     		b	.L238
 3373              	.L244:
1069:gcode.c       ****       } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
 3374              		.loc 1 1069 0
 3375 19e6 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 3376 19ea 012B     		cmp	r3, #1
 3377 19ec 01D1     		bne	.L238
1070:gcode.c       ****         gc_sync_position(); // gc_state.position[] = sys_position
 3378              		.loc 1 1070 0
 3379 19ee FFF7FEFF 		bl	gc_sync_position
 3380              	.L238:
 3381              	.LBE8:
1071:gcode.c       ****       } // == GC_UPDATE_POS_NONE
1072:gcode.c       ****     }     
1073:gcode.c       ****   }
1074:gcode.c       **** 
1075:gcode.c       ****   // [21. Program flow ]:
1076:gcode.c       ****   // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
1077:gcode.c       ****   // refill and can only be resumed by the cycle start run-time command.
1078:gcode.c       ****   gc_state.modal.program_flow = gc_block.modal.program_flow;
 3382              		.loc 1 1078 0
 3383 19f2 2E4B     		ldr	r3, .L295+4
 3384 19f4 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3385 19f6 2E4B     		ldr	r3, .L295+8
 3386 19f8 DA71     		strb	r2, [r3, #7]
1079:gcode.c       ****   if (gc_state.modal.program_flow) {
 3387              		.loc 1 1079 0
 3388 19fa 2D4B     		ldr	r3, .L295+8
 3389 19fc DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 3390 19fe 002B     		cmp	r3, #0
 3391 1a00 4CD0     		beq	.L245
1080:gcode.c       ****     protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving 
 3392              		.loc 1 1080 0
 3393 1a02 FFF7FEFF 		bl	protocol_buffer_synchronize
1081:gcode.c       ****     if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
 3394              		.loc 1 1081 0
 3395 1a06 2A4B     		ldr	r3, .L295+8
 3396 1a08 DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 3397 1a0a 032B     		cmp	r3, #3
 3398 1a0c 09D1     		bne	.L246
1082:gcode.c       ****       if (sys.state != STATE_CHECK_MODE) {
 3399              		.loc 1 1082 0
 3400 1a0e 2C4B     		ldr	r3, .L295+24
 3401 1a10 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3402 1a12 022B     		cmp	r3, #2
 3403 1a14 3FD0     		beq	.L248
1083:gcode.c       ****         system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 3404              		.loc 1 1083 0
 3405 1a16 0820     		movs	r0, #8
 3406 1a18 FFF7FEFF 		bl	system_set_exec_state_flag
1084:gcode.c       ****         protocol_execute_realtime(); // Execute suspend.
 3407              		.loc 1 1084 0
 3408 1a1c FFF7FEFF 		bl	protocol_execute_realtime
 3409 1a20 39E0     		b	.L248
 3410              	.L246:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 81


1085:gcode.c       ****       }
1086:gcode.c       ****     } else { // == PROGRAM_FLOW_COMPLETED
1087:gcode.c       ****       // Upon program complete, only a subset of g-codes reset to certain defaults, according to
1088:gcode.c       ****       // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
1089:gcode.c       ****       // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
1090:gcode.c       ****       // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
1091:gcode.c       ****       gc_state.modal.motion = MOTION_MODE_LINEAR;
 3411              		.loc 1 1091 0
 3412 1a22 234B     		ldr	r3, .L295+8
 3413 1a24 0122     		movs	r2, #1
 3414 1a26 1A70     		strb	r2, [r3]
1092:gcode.c       ****       gc_state.modal.plane_select = PLANE_SELECT_XY;
 3415              		.loc 1 1092 0
 3416 1a28 214B     		ldr	r3, .L295+8
 3417 1a2a 0022     		movs	r2, #0
 3418 1a2c 1A71     		strb	r2, [r3, #4]
1093:gcode.c       ****       gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
 3419              		.loc 1 1093 0
 3420 1a2e 204B     		ldr	r3, .L295+8
 3421 1a30 0022     		movs	r2, #0
 3422 1a32 DA70     		strb	r2, [r3, #3]
1094:gcode.c       ****       gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 3423              		.loc 1 1094 0
 3424 1a34 1E4B     		ldr	r3, .L295+8
 3425 1a36 0022     		movs	r2, #0
 3426 1a38 5A70     		strb	r2, [r3, #1]
1095:gcode.c       ****       // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
1096:gcode.c       ****       gc_state.modal.coord_select = 0; // G54
 3427              		.loc 1 1096 0
 3428 1a3a 1D4B     		ldr	r3, .L295+8
 3429 1a3c 0022     		movs	r2, #0
 3430 1a3e 9A71     		strb	r2, [r3, #6]
1097:gcode.c       ****       gc_state.modal.spindle = SPINDLE_DISABLE;
 3431              		.loc 1 1097 0
 3432 1a40 1B4B     		ldr	r3, .L295+8
 3433 1a42 0022     		movs	r2, #0
 3434 1a44 5A72     		strb	r2, [r3, #9]
1098:gcode.c       ****       gc_state.modal.coolant = COOLANT_DISABLE;
 3435              		.loc 1 1098 0
 3436 1a46 1A4B     		ldr	r3, .L295+8
 3437 1a48 0022     		movs	r2, #0
 3438 1a4a 1A72     		strb	r2, [r3, #8]
1099:gcode.c       ****       // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
1100:gcode.c       **** 
1101:gcode.c       ****       #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
1102:gcode.c       ****         sys.f_override = DEFAULT_FEED_OVERRIDE;
 3439              		.loc 1 1102 0
 3440 1a4c 1C4B     		ldr	r3, .L295+24
 3441 1a4e 6422     		movs	r2, #100
 3442 1a50 DA71     		strb	r2, [r3, #7]
1103:gcode.c       ****         sys.r_override = DEFAULT_RAPID_OVERRIDE;
 3443              		.loc 1 1103 0
 3444 1a52 1B4B     		ldr	r3, .L295+24
 3445 1a54 6422     		movs	r2, #100
 3446 1a56 1A72     		strb	r2, [r3, #8]
1104:gcode.c       ****         sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
 3447              		.loc 1 1104 0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 82


 3448 1a58 194B     		ldr	r3, .L295+24
 3449 1a5a 6422     		movs	r2, #100
 3450 1a5c 5A72     		strb	r2, [r3, #9]
1105:gcode.c       ****       #endif
1106:gcode.c       **** 
1107:gcode.c       ****       // Execute coordinate change and spindle/coolant stop.
1108:gcode.c       ****       if (sys.state != STATE_CHECK_MODE) {
 3451              		.loc 1 1108 0
 3452 1a5e 184B     		ldr	r3, .L295+24
 3453 1a60 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3454 1a62 022B     		cmp	r3, #2
 3455 1a64 14D0     		beq	.L249
1109:gcode.c       ****         if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(
 3456              		.loc 1 1109 0
 3457 1a66 124B     		ldr	r3, .L295+8
 3458 1a68 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 3459 1a6a 1649     		ldr	r1, .L295+28
 3460 1a6c 1846     		mov	r0, r3
 3461 1a6e FFF7FEFF 		bl	settings_read_coord_data
 3462 1a72 0346     		mov	r3, r0
 3463 1a74 002B     		cmp	r3, #0
 3464 1a76 01D1     		bne	.L250
 3465              		.loc 1 1109 0 is_stmt 0 discriminator 1
 3466 1a78 0723     		movs	r3, #7
 3467 1a7a 10E0     		b	.L251
 3468              	.L250:
1110:gcode.c       ****         system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 3469              		.loc 1 1110 0 is_stmt 1
 3470 1a7c FFF7FEFF 		bl	system_flag_wco_change
1111:gcode.c       ****         spindle_set_state(SPINDLE_DISABLE,0.0);
 3471              		.loc 1 1111 0
 3472 1a80 4FF00001 		mov	r1, #0
 3473 1a84 0020     		movs	r0, #0
 3474 1a86 FFF7FEFF 		bl	spindle_set_state
1112:gcode.c       ****         coolant_set_state(COOLANT_DISABLE);
 3475              		.loc 1 1112 0
 3476 1a8a 0020     		movs	r0, #0
 3477 1a8c FFF7FEFF 		bl	coolant_set_state
 3478              	.L249:
1113:gcode.c       ****       }
1114:gcode.c       ****       report_feedback_message(MESSAGE_PROGRAM_END);
 3479              		.loc 1 1114 0
 3480 1a90 0820     		movs	r0, #8
 3481 1a92 FFF7FEFF 		bl	report_feedback_message
 3482              	.L248:
1115:gcode.c       ****     }
1116:gcode.c       ****     gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
 3483              		.loc 1 1116 0
 3484 1a96 064B     		ldr	r3, .L295+8
 3485 1a98 0022     		movs	r2, #0
 3486 1a9a DA71     		strb	r2, [r3, #7]
 3487              	.L245:
1117:gcode.c       ****   }
1118:gcode.c       **** 
1119:gcode.c       ****   // TODO: % to denote start of program.
1120:gcode.c       **** 
1121:gcode.c       ****   return(STATUS_OK);
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 83


 3488              		.loc 1 1121 0
 3489 1a9c 0023     		movs	r3, #0
 3490              	.L251:
1122:gcode.c       **** }
 3491              		.loc 1 1122 0 discriminator 3
 3492 1a9e 1846     		mov	r0, r3
 3493 1aa0 5C37     		adds	r7, r7, #92
 3494              		.cfi_def_cfa_offset 28
 3495 1aa2 BD46     		mov	sp, r7
 3496              		.cfi_def_cfa_register 13
 3497              		@ sp needed
 3498 1aa4 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3499              	.L296:
 3500              		.align	2
 3501              	.L295:
 3502 1aa8 34000000 		.word	gc_state+52
 3503 1aac 00000000 		.word	gc_block
 3504 1ab0 00000000 		.word	gc_state
 3505 1ab4 34000000 		.word	gc_block+52
 3506 1ab8 10000000 		.word	gc_block+16
 3507 1abc 1C000000 		.word	gc_state+28
 3508 1ac0 00000000 		.word	sys
 3509 1ac4 28000000 		.word	gc_state+40
 3510              		.cfi_endproc
 3511              	.LFE66:
 3512              		.size	gc_execute_line, .-gc_execute_line
 3513              		.text
 3514              	.Letext0:
 3515              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 3516              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 3517              		.file 4 "settings.h"
 3518              		.file 5 "system.h"
 3519              		.file 6 "planner.h"
 3520              		.file 7 "gcode.h"
 3521              		.file 8 "Generated_Source\\PSoC5/core_cm3.h"
 3522              		.section	.debug_info,"",%progbits
 3523              	.Ldebug_info0:
 3524 0000 6F070000 		.4byte	0x76f
 3525 0004 0400     		.2byte	0x4
 3526 0006 00000000 		.4byte	.Ldebug_abbrev0
 3527 000a 04       		.byte	0x4
 3528 000b 01       		.uleb128 0x1
 3529 000c 80000000 		.4byte	.LASF116
 3530 0010 0C       		.byte	0xc
 3531 0011 63000000 		.4byte	.LASF117
 3532 0015 9B010000 		.4byte	.LASF118
 3533 0019 20000000 		.4byte	.Ldebug_ranges0+0x20
 3534 001d 00000000 		.4byte	0
 3535 0021 00000000 		.4byte	.Ldebug_line0
 3536 0025 02       		.uleb128 0x2
 3537 0026 01       		.byte	0x1
 3538 0027 06       		.byte	0x6
 3539 0028 CA050000 		.4byte	.LASF0
 3540 002c 03       		.uleb128 0x3
 3541 002d D7040000 		.4byte	.LASF3
 3542 0031 02       		.byte	0x2
 3543 0032 1D       		.byte	0x1d
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 84


 3544 0033 37000000 		.4byte	0x37
 3545 0037 02       		.uleb128 0x2
 3546 0038 01       		.byte	0x1
 3547 0039 08       		.byte	0x8
 3548 003a 81050000 		.4byte	.LASF1
 3549 003e 02       		.uleb128 0x2
 3550 003f 02       		.byte	0x2
 3551 0040 05       		.byte	0x5
 3552 0041 6E040000 		.4byte	.LASF2
 3553 0045 03       		.uleb128 0x3
 3554 0046 1A020000 		.4byte	.LASF4
 3555 004a 02       		.byte	0x2
 3556 004b 2B       		.byte	0x2b
 3557 004c 50000000 		.4byte	0x50
 3558 0050 02       		.uleb128 0x2
 3559 0051 02       		.byte	0x2
 3560 0052 07       		.byte	0x7
 3561 0053 EC050000 		.4byte	.LASF5
 3562 0057 03       		.uleb128 0x3
 3563 0058 76000000 		.4byte	.LASF6
 3564 005c 02       		.byte	0x2
 3565 005d 3F       		.byte	0x3f
 3566 005e 62000000 		.4byte	0x62
 3567 0062 02       		.uleb128 0x2
 3568 0063 04       		.byte	0x4
 3569 0064 05       		.byte	0x5
 3570 0065 78040000 		.4byte	.LASF7
 3571 0069 02       		.uleb128 0x2
 3572 006a 04       		.byte	0x4
 3573 006b 07       		.byte	0x7
 3574 006c 42050000 		.4byte	.LASF8
 3575 0070 02       		.uleb128 0x2
 3576 0071 08       		.byte	0x8
 3577 0072 05       		.byte	0x5
 3578 0073 88030000 		.4byte	.LASF9
 3579 0077 02       		.uleb128 0x2
 3580 0078 08       		.byte	0x8
 3581 0079 07       		.byte	0x7
 3582 007a F8010000 		.4byte	.LASF10
 3583 007e 04       		.uleb128 0x4
 3584 007f 04       		.byte	0x4
 3585 0080 05       		.byte	0x5
 3586 0081 696E7400 		.ascii	"int\000"
 3587 0085 02       		.uleb128 0x2
 3588 0086 04       		.byte	0x4
 3589 0087 07       		.byte	0x7
 3590 0088 4A000000 		.4byte	.LASF11
 3591 008c 03       		.uleb128 0x3
 3592 008d 52030000 		.4byte	.LASF12
 3593 0091 03       		.byte	0x3
 3594 0092 18       		.byte	0x18
 3595 0093 2C000000 		.4byte	0x2c
 3596 0097 03       		.uleb128 0x3
 3597 0098 33040000 		.4byte	.LASF13
 3598 009c 03       		.byte	0x3
 3599 009d 24       		.byte	0x24
 3600 009e 45000000 		.4byte	0x45
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 85


 3601 00a2 03       		.uleb128 0x3
 3602 00a3 54050000 		.4byte	.LASF14
 3603 00a7 03       		.byte	0x3
 3604 00a8 2C       		.byte	0x2c
 3605 00a9 57000000 		.4byte	0x57
 3606 00ad 02       		.uleb128 0x2
 3607 00ae 04       		.byte	0x4
 3608 00af 04       		.byte	0x4
 3609 00b0 95010000 		.4byte	.LASF15
 3610 00b4 02       		.uleb128 0x2
 3611 00b5 08       		.byte	0x8
 3612 00b6 04       		.byte	0x4
 3613 00b7 28060000 		.4byte	.LASF16
 3614 00bb 02       		.uleb128 0x2
 3615 00bc 01       		.byte	0x1
 3616 00bd 08       		.byte	0x8
 3617 00be C2020000 		.4byte	.LASF17
 3618 00c2 02       		.uleb128 0x2
 3619 00c3 08       		.byte	0x8
 3620 00c4 04       		.byte	0x4
 3621 00c5 27040000 		.4byte	.LASF18
 3622 00c9 02       		.uleb128 0x2
 3623 00ca 04       		.byte	0x4
 3624 00cb 07       		.byte	0x7
 3625 00cc 39050000 		.4byte	.LASF19
 3626 00d0 05       		.uleb128 0x5
 3627 00d1 04       		.byte	0x4
 3628 00d2 BB000000 		.4byte	0xbb
 3629 00d6 06       		.uleb128 0x6
 3630 00d7 8C000000 		.4byte	0x8c
 3631 00db 07       		.uleb128 0x7
 3632 00dc 5C       		.byte	0x5c
 3633 00dd 04       		.byte	0x4
 3634 00de 4F       		.byte	0x4f
 3635 00df C8010000 		.4byte	0x1c8
 3636 00e3 08       		.uleb128 0x8
 3637 00e4 BE030000 		.4byte	.LASF20
 3638 00e8 04       		.byte	0x4
 3639 00e9 51       		.byte	0x51
 3640 00ea C8010000 		.4byte	0x1c8
 3641 00ee 00       		.byte	0
 3642 00ef 08       		.uleb128 0x8
 3643 00f0 3C040000 		.4byte	.LASF21
 3644 00f4 04       		.byte	0x4
 3645 00f5 52       		.byte	0x52
 3646 00f6 C8010000 		.4byte	0x1c8
 3647 00fa 0C       		.byte	0xc
 3648 00fb 08       		.uleb128 0x8
 3649 00fc 66010000 		.4byte	.LASF22
 3650 0100 04       		.byte	0x4
 3651 0101 53       		.byte	0x53
 3652 0102 C8010000 		.4byte	0x1c8
 3653 0106 18       		.byte	0x18
 3654 0107 08       		.uleb128 0x8
 3655 0108 B7020000 		.4byte	.LASF23
 3656 010c 04       		.byte	0x4
 3657 010d 54       		.byte	0x54
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 86


 3658 010e C8010000 		.4byte	0x1c8
 3659 0112 24       		.byte	0x24
 3660 0113 08       		.uleb128 0x8
 3661 0114 00000000 		.4byte	.LASF24
 3662 0118 04       		.byte	0x4
 3663 0119 57       		.byte	0x57
 3664 011a 8C000000 		.4byte	0x8c
 3665 011e 30       		.byte	0x30
 3666 011f 08       		.uleb128 0x8
 3667 0120 16040000 		.4byte	.LASF25
 3668 0124 04       		.byte	0x4
 3669 0125 58       		.byte	0x58
 3670 0126 8C000000 		.4byte	0x8c
 3671 012a 31       		.byte	0x31
 3672 012b 08       		.uleb128 0x8
 3673 012c 83060000 		.4byte	.LASF26
 3674 0130 04       		.byte	0x4
 3675 0131 59       		.byte	0x59
 3676 0132 8C000000 		.4byte	0x8c
 3677 0136 32       		.byte	0x32
 3678 0137 08       		.uleb128 0x8
 3679 0138 27010000 		.4byte	.LASF27
 3680 013c 04       		.byte	0x4
 3681 013d 5A       		.byte	0x5a
 3682 013e 8C000000 		.4byte	0x8c
 3683 0142 33       		.byte	0x33
 3684 0143 08       		.uleb128 0x8
 3685 0144 37000000 		.4byte	.LASF28
 3686 0148 04       		.byte	0x4
 3687 0149 5B       		.byte	0x5b
 3688 014a 8C000000 		.4byte	0x8c
 3689 014e 34       		.byte	0x34
 3690 014f 08       		.uleb128 0x8
 3691 0150 3F060000 		.4byte	.LASF29
 3692 0154 04       		.byte	0x4
 3693 0155 5C       		.byte	0x5c
 3694 0156 AD000000 		.4byte	0xad
 3695 015a 38       		.byte	0x38
 3696 015b 08       		.uleb128 0x8
 3697 015c 44010000 		.4byte	.LASF30
 3698 0160 04       		.byte	0x4
 3699 0161 5D       		.byte	0x5d
 3700 0162 AD000000 		.4byte	0xad
 3701 0166 3C       		.byte	0x3c
 3702 0167 08       		.uleb128 0x8
 3703 0168 DA020000 		.4byte	.LASF31
 3704 016c 04       		.byte	0x4
 3705 016d 5F       		.byte	0x5f
 3706 016e AD000000 		.4byte	0xad
 3707 0172 40       		.byte	0x40
 3708 0173 08       		.uleb128 0x8
 3709 0174 FF050000 		.4byte	.LASF32
 3710 0178 04       		.byte	0x4
 3711 0179 60       		.byte	0x60
 3712 017a AD000000 		.4byte	0xad
 3713 017e 44       		.byte	0x44
 3714 017f 08       		.uleb128 0x8
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 87


 3715 0180 29000000 		.4byte	.LASF33
 3716 0184 04       		.byte	0x4
 3717 0185 62       		.byte	0x62
 3718 0186 8C000000 		.4byte	0x8c
 3719 018a 48       		.byte	0x48
 3720 018b 08       		.uleb128 0x8
 3721 018c 2F060000 		.4byte	.LASF34
 3722 0190 04       		.byte	0x4
 3723 0191 64       		.byte	0x64
 3724 0192 8C000000 		.4byte	0x8c
 3725 0196 49       		.byte	0x49
 3726 0197 08       		.uleb128 0x8
 3727 0198 84010000 		.4byte	.LASF35
 3728 019c 04       		.byte	0x4
 3729 019d 65       		.byte	0x65
 3730 019e AD000000 		.4byte	0xad
 3731 01a2 4C       		.byte	0x4c
 3732 01a3 08       		.uleb128 0x8
 3733 01a4 73010000 		.4byte	.LASF36
 3734 01a8 04       		.byte	0x4
 3735 01a9 66       		.byte	0x66
 3736 01aa AD000000 		.4byte	0xad
 3737 01ae 50       		.byte	0x50
 3738 01af 08       		.uleb128 0x8
 3739 01b0 D6050000 		.4byte	.LASF37
 3740 01b4 04       		.byte	0x4
 3741 01b5 67       		.byte	0x67
 3742 01b6 97000000 		.4byte	0x97
 3743 01ba 54       		.byte	0x54
 3744 01bb 08       		.uleb128 0x8
 3745 01bc 56020000 		.4byte	.LASF38
 3746 01c0 04       		.byte	0x4
 3747 01c1 68       		.byte	0x68
 3748 01c2 AD000000 		.4byte	0xad
 3749 01c6 58       		.byte	0x58
 3750 01c7 00       		.byte	0
 3751 01c8 09       		.uleb128 0x9
 3752 01c9 AD000000 		.4byte	0xad
 3753 01cd D8010000 		.4byte	0x1d8
 3754 01d1 0A       		.uleb128 0xa
 3755 01d2 C9000000 		.4byte	0xc9
 3756 01d6 02       		.byte	0x2
 3757 01d7 00       		.byte	0
 3758 01d8 03       		.uleb128 0x3
 3759 01d9 07060000 		.4byte	.LASF39
 3760 01dd 04       		.byte	0x4
 3761 01de 69       		.byte	0x69
 3762 01df DB000000 		.4byte	0xdb
 3763 01e3 07       		.uleb128 0x7
 3764 01e4 14       		.byte	0x14
 3765 01e5 05       		.byte	0x5
 3766 01e6 81       		.byte	0x81
 3767 01e7 94020000 		.4byte	0x294
 3768 01eb 08       		.uleb128 0x8
 3769 01ec 94050000 		.4byte	.LASF40
 3770 01f0 05       		.byte	0x5
 3771 01f1 82       		.byte	0x82
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 88


 3772 01f2 8C000000 		.4byte	0x8c
 3773 01f6 00       		.byte	0
 3774 01f7 08       		.uleb128 0x8
 3775 01f8 3C020000 		.4byte	.LASF41
 3776 01fc 05       		.byte	0x5
 3777 01fd 83       		.byte	0x83
 3778 01fe 8C000000 		.4byte	0x8c
 3779 0202 01       		.byte	0x1
 3780 0203 08       		.uleb128 0x8
 3781 0204 73020000 		.4byte	.LASF42
 3782 0208 05       		.byte	0x5
 3783 0209 84       		.byte	0x84
 3784 020a 8C000000 		.4byte	0x8c
 3785 020e 02       		.byte	0x2
 3786 020f 08       		.uleb128 0x8
 3787 0210 CC040000 		.4byte	.LASF43
 3788 0214 05       		.byte	0x5
 3789 0215 85       		.byte	0x85
 3790 0216 8C000000 		.4byte	0x8c
 3791 021a 03       		.byte	0x3
 3792 021b 08       		.uleb128 0x8
 3793 021c 61040000 		.4byte	.LASF44
 3794 0220 05       		.byte	0x5
 3795 0221 86       		.byte	0x86
 3796 0222 8C000000 		.4byte	0x8c
 3797 0226 04       		.byte	0x4
 3798 0227 08       		.uleb128 0x8
 3799 0228 E1040000 		.4byte	.LASF45
 3800 022c 05       		.byte	0x5
 3801 022d 87       		.byte	0x87
 3802 022e 8C000000 		.4byte	0x8c
 3803 0232 05       		.byte	0x5
 3804 0233 08       		.uleb128 0x8
 3805 0234 52060000 		.4byte	.LASF46
 3806 0238 05       		.byte	0x5
 3807 0239 88       		.byte	0x88
 3808 023a 8C000000 		.4byte	0x8c
 3809 023e 06       		.byte	0x6
 3810 023f 08       		.uleb128 0x8
 3811 0240 0F020000 		.4byte	.LASF47
 3812 0244 05       		.byte	0x5
 3813 0245 89       		.byte	0x89
 3814 0246 8C000000 		.4byte	0x8c
 3815 024a 07       		.byte	0x7
 3816 024b 08       		.uleb128 0x8
 3817 024c 6B000000 		.4byte	.LASF48
 3818 0250 05       		.byte	0x5
 3819 0251 8A       		.byte	0x8a
 3820 0252 8C000000 		.4byte	0x8c
 3821 0256 08       		.byte	0x8
 3822 0257 08       		.uleb128 0x8
 3823 0258 40030000 		.4byte	.LASF49
 3824 025c 05       		.byte	0x5
 3825 025d 8B       		.byte	0x8b
 3826 025e 8C000000 		.4byte	0x8c
 3827 0262 09       		.byte	0x9
 3828 0263 08       		.uleb128 0x8
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 89


 3829 0264 25020000 		.4byte	.LASF50
 3830 0268 05       		.byte	0x5
 3831 0269 8C       		.byte	0x8c
 3832 026a 8C000000 		.4byte	0x8c
 3833 026e 0A       		.byte	0xa
 3834 026f 08       		.uleb128 0x8
 3835 0270 07030000 		.4byte	.LASF51
 3836 0274 05       		.byte	0x5
 3837 0275 8D       		.byte	0x8d
 3838 0276 8C000000 		.4byte	0x8c
 3839 027a 0B       		.byte	0xb
 3840 027b 08       		.uleb128 0x8
 3841 027c A1040000 		.4byte	.LASF52
 3842 0280 05       		.byte	0x5
 3843 0281 8E       		.byte	0x8e
 3844 0282 8C000000 		.4byte	0x8c
 3845 0286 0C       		.byte	0xc
 3846 0287 08       		.uleb128 0x8
 3847 0288 EB020000 		.4byte	.LASF53
 3848 028c 05       		.byte	0x5
 3849 028d 90       		.byte	0x90
 3850 028e AD000000 		.4byte	0xad
 3851 0292 10       		.byte	0x10
 3852 0293 00       		.byte	0
 3853 0294 03       		.uleb128 0x3
 3854 0295 8E040000 		.4byte	.LASF54
 3855 0299 05       		.byte	0x5
 3856 029a 92       		.byte	0x92
 3857 029b E3010000 		.4byte	0x1e3
 3858 029f 07       		.uleb128 0x7
 3859 02a0 0C       		.byte	0xc
 3860 02a1 06       		.byte	0x6
 3861 02a2 5C       		.byte	0x5c
 3862 02a3 CC020000 		.4byte	0x2cc
 3863 02a7 08       		.uleb128 0x8
 3864 02a8 97040000 		.4byte	.LASF55
 3865 02ac 06       		.byte	0x6
 3866 02ad 5D       		.byte	0x5d
 3867 02ae AD000000 		.4byte	0xad
 3868 02b2 00       		.byte	0
 3869 02b3 08       		.uleb128 0x8
 3870 02b4 EB020000 		.4byte	.LASF53
 3871 02b8 06       		.byte	0x6
 3872 02b9 5E       		.byte	0x5e
 3873 02ba AD000000 		.4byte	0xad
 3874 02be 04       		.byte	0x4
 3875 02bf 08       		.uleb128 0x8
 3876 02c0 63060000 		.4byte	.LASF56
 3877 02c4 06       		.byte	0x6
 3878 02c5 5F       		.byte	0x5f
 3879 02c6 8C000000 		.4byte	0x8c
 3880 02ca 08       		.byte	0x8
 3881 02cb 00       		.byte	0
 3882 02cc 03       		.uleb128 0x3
 3883 02cd DD010000 		.4byte	.LASF57
 3884 02d1 06       		.byte	0x6
 3885 02d2 63       		.byte	0x63
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 90


 3886 02d3 9F020000 		.4byte	0x29f
 3887 02d7 07       		.uleb128 0x7
 3888 02d8 0A       		.byte	0xa
 3889 02d9 07       		.byte	0x7
 3890 02da B4       		.byte	0xb4
 3891 02db 58030000 		.4byte	0x358
 3892 02df 08       		.uleb128 0x8
 3893 02e0 32050000 		.4byte	.LASF58
 3894 02e4 07       		.byte	0x7
 3895 02e5 B5       		.byte	0xb5
 3896 02e6 8C000000 		.4byte	0x8c
 3897 02ea 00       		.byte	0
 3898 02eb 08       		.uleb128 0x8
 3899 02ec 97040000 		.4byte	.LASF55
 3900 02f0 07       		.byte	0x7
 3901 02f1 B6       		.byte	0xb6
 3902 02f2 8C000000 		.4byte	0x8c
 3903 02f6 01       		.byte	0x1
 3904 02f7 08       		.uleb128 0x8
 3905 02f8 C4050000 		.4byte	.LASF59
 3906 02fc 07       		.byte	0x7
 3907 02fd B7       		.byte	0xb7
 3908 02fe 8C000000 		.4byte	0x8c
 3909 0302 02       		.byte	0x2
 3910 0303 08       		.uleb128 0x8
 3911 0304 13000000 		.4byte	.LASF60
 3912 0308 07       		.byte	0x7
 3913 0309 B8       		.byte	0xb8
 3914 030a 8C000000 		.4byte	0x8c
 3915 030e 03       		.byte	0x3
 3916 030f 08       		.uleb128 0x8
 3917 0310 7B020000 		.4byte	.LASF61
 3918 0314 07       		.byte	0x7
 3919 0315 BA       		.byte	0xba
 3920 0316 8C000000 		.4byte	0x8c
 3921 031a 04       		.byte	0x4
 3922 031b 08       		.uleb128 0x8
 3923 031c 4A020000 		.4byte	.LASF62
 3924 0320 07       		.byte	0x7
 3925 0321 BC       		.byte	0xbc
 3926 0322 8C000000 		.4byte	0x8c
 3927 0326 05       		.byte	0x5
 3928 0327 08       		.uleb128 0x8
 3929 0328 A1020000 		.4byte	.LASF63
 3930 032c 07       		.byte	0x7
 3931 032d BD       		.byte	0xbd
 3932 032e 8C000000 		.4byte	0x8c
 3933 0332 06       		.byte	0x6
 3934 0333 08       		.uleb128 0x8
 3935 0334 1C000000 		.4byte	.LASF64
 3936 0338 07       		.byte	0x7
 3937 0339 BF       		.byte	0xbf
 3938 033a 8C000000 		.4byte	0x8c
 3939 033e 07       		.byte	0x7
 3940 033f 08       		.uleb128 0x8
 3941 0340 42020000 		.4byte	.LASF65
 3942 0344 07       		.byte	0x7
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 91


 3943 0345 C0       		.byte	0xc0
 3944 0346 8C000000 		.4byte	0x8c
 3945 034a 08       		.byte	0x8
 3946 034b 08       		.uleb128 0x8
 3947 034c 5E010000 		.4byte	.LASF66
 3948 0350 07       		.byte	0x7
 3949 0351 C1       		.byte	0xc1
 3950 0352 8C000000 		.4byte	0x8c
 3951 0356 09       		.byte	0x9
 3952 0357 00       		.byte	0
 3953 0358 03       		.uleb128 0x3
 3954 0359 AC050000 		.4byte	.LASF67
 3955 035d 07       		.byte	0x7
 3956 035e C2       		.byte	0xc2
 3957 035f D7020000 		.4byte	0x2d7
 3958 0363 07       		.uleb128 0x7
 3959 0364 34       		.byte	0x34
 3960 0365 07       		.byte	0x7
 3961 0366 C4       		.byte	0xc4
 3962 0367 CA030000 		.4byte	0x3ca
 3963 036b 0B       		.uleb128 0xb
 3964 036c 6600     		.ascii	"f\000"
 3965 036e 07       		.byte	0x7
 3966 036f C5       		.byte	0xc5
 3967 0370 AD000000 		.4byte	0xad
 3968 0374 00       		.byte	0
 3969 0375 0B       		.uleb128 0xb
 3970 0376 696A6B00 		.ascii	"ijk\000"
 3971 037a 07       		.byte	0x7
 3972 037b C6       		.byte	0xc6
 3973 037c C8010000 		.4byte	0x1c8
 3974 0380 04       		.byte	0x4
 3975 0381 0B       		.uleb128 0xb
 3976 0382 6C00     		.ascii	"l\000"
 3977 0384 07       		.byte	0x7
 3978 0385 C7       		.byte	0xc7
 3979 0386 8C000000 		.4byte	0x8c
 3980 038a 10       		.byte	0x10
 3981 038b 0B       		.uleb128 0xb
 3982 038c 6E00     		.ascii	"n\000"
 3983 038e 07       		.byte	0x7
 3984 038f C8       		.byte	0xc8
 3985 0390 A2000000 		.4byte	0xa2
 3986 0394 14       		.byte	0x14
 3987 0395 0B       		.uleb128 0xb
 3988 0396 7000     		.ascii	"p\000"
 3989 0398 07       		.byte	0x7
 3990 0399 C9       		.byte	0xc9
 3991 039a AD000000 		.4byte	0xad
 3992 039e 18       		.byte	0x18
 3993 039f 0B       		.uleb128 0xb
 3994 03a0 7200     		.ascii	"r\000"
 3995 03a2 07       		.byte	0x7
 3996 03a3 CB       		.byte	0xcb
 3997 03a4 AD000000 		.4byte	0xad
 3998 03a8 1C       		.byte	0x1c
 3999 03a9 0B       		.uleb128 0xb
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 92


 4000 03aa 7300     		.ascii	"s\000"
 4001 03ac 07       		.byte	0x7
 4002 03ad CC       		.byte	0xcc
 4003 03ae AD000000 		.4byte	0xad
 4004 03b2 20       		.byte	0x20
 4005 03b3 0B       		.uleb128 0xb
 4006 03b4 7400     		.ascii	"t\000"
 4007 03b6 07       		.byte	0x7
 4008 03b7 CD       		.byte	0xcd
 4009 03b8 8C000000 		.4byte	0x8c
 4010 03bc 24       		.byte	0x24
 4011 03bd 0B       		.uleb128 0xb
 4012 03be 78797A00 		.ascii	"xyz\000"
 4013 03c2 07       		.byte	0x7
 4014 03c3 CE       		.byte	0xce
 4015 03c4 C8010000 		.4byte	0x1c8
 4016 03c8 28       		.byte	0x28
 4017 03c9 00       		.byte	0
 4018 03ca 03       		.uleb128 0x3
 4019 03cb 34030000 		.4byte	.LASF68
 4020 03cf 07       		.byte	0x7
 4021 03d0 CF       		.byte	0xcf
 4022 03d1 63030000 		.4byte	0x363
 4023 03d5 07       		.uleb128 0x7
 4024 03d6 44       		.byte	0x44
 4025 03d7 07       		.byte	0x7
 4026 03d8 D2       		.byte	0xd2
 4027 03d9 4A040000 		.4byte	0x44a
 4028 03dd 08       		.uleb128 0x8
 4029 03de 3E010000 		.4byte	.LASF69
 4030 03e2 07       		.byte	0x7
 4031 03e3 D3       		.byte	0xd3
 4032 03e4 58030000 		.4byte	0x358
 4033 03e8 00       		.byte	0
 4034 03e9 08       		.uleb128 0x8
 4035 03ea EB020000 		.4byte	.LASF53
 4036 03ee 07       		.byte	0x7
 4037 03ef D5       		.byte	0xd5
 4038 03f0 AD000000 		.4byte	0xad
 4039 03f4 0C       		.byte	0xc
 4040 03f5 08       		.uleb128 0x8
 4041 03f6 97040000 		.4byte	.LASF55
 4042 03fa 07       		.byte	0x7
 4043 03fb D6       		.byte	0xd6
 4044 03fc AD000000 		.4byte	0xad
 4045 0400 10       		.byte	0x10
 4046 0401 08       		.uleb128 0x8
 4047 0402 65020000 		.4byte	.LASF70
 4048 0406 07       		.byte	0x7
 4049 0407 D7       		.byte	0xd7
 4050 0408 8C000000 		.4byte	0x8c
 4051 040c 14       		.byte	0x14
 4052 040d 08       		.uleb128 0x8
 4053 040e CB030000 		.4byte	.LASF71
 4054 0412 07       		.byte	0x7
 4055 0413 D8       		.byte	0xd8
 4056 0414 A2000000 		.4byte	0xa2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 93


 4057 0418 18       		.byte	0x18
 4058 0419 08       		.uleb128 0x8
 4059 041a 7A060000 		.4byte	.LASF72
 4060 041e 07       		.byte	0x7
 4061 041f DA       		.byte	0xda
 4062 0420 C8010000 		.4byte	0x1c8
 4063 0424 1C       		.byte	0x1c
 4064 0425 08       		.uleb128 0x8
 4065 0426 B1030000 		.4byte	.LASF73
 4066 042a 07       		.byte	0x7
 4067 042b DC       		.byte	0xdc
 4068 042c C8010000 		.4byte	0x1c8
 4069 0430 28       		.byte	0x28
 4070 0431 08       		.uleb128 0x8
 4071 0432 5C050000 		.4byte	.LASF74
 4072 0436 07       		.byte	0x7
 4073 0437 DE       		.byte	0xde
 4074 0438 C8010000 		.4byte	0x1c8
 4075 043c 34       		.byte	0x34
 4076 043d 08       		.uleb128 0x8
 4077 043e C7020000 		.4byte	.LASF75
 4078 0442 07       		.byte	0x7
 4079 0443 E0       		.byte	0xe0
 4080 0444 AD000000 		.4byte	0xad
 4081 0448 40       		.byte	0x40
 4082 0449 00       		.byte	0
 4083 044a 03       		.uleb128 0x3
 4084 044b 61030000 		.4byte	.LASF76
 4085 044f 07       		.byte	0x7
 4086 0450 E1       		.byte	0xe1
 4087 0451 D5030000 		.4byte	0x3d5
 4088 0455 07       		.uleb128 0x7
 4089 0456 40       		.byte	0x40
 4090 0457 07       		.byte	0x7
 4091 0458 E5       		.byte	0xe5
 4092 0459 82040000 		.4byte	0x482
 4093 045d 08       		.uleb128 0x8
 4094 045e 04040000 		.4byte	.LASF77
 4095 0462 07       		.byte	0x7
 4096 0463 E6       		.byte	0xe6
 4097 0464 8C000000 		.4byte	0x8c
 4098 0468 00       		.byte	0
 4099 0469 08       		.uleb128 0x8
 4100 046a 3E010000 		.4byte	.LASF69
 4101 046e 07       		.byte	0x7
 4102 046f E7       		.byte	0xe7
 4103 0470 58030000 		.4byte	0x358
 4104 0474 01       		.byte	0x1
 4105 0475 08       		.uleb128 0x8
 4106 0476 E0030000 		.4byte	.LASF78
 4107 047a 07       		.byte	0x7
 4108 047b E8       		.byte	0xe8
 4109 047c CA030000 		.4byte	0x3ca
 4110 0480 0C       		.byte	0xc
 4111 0481 00       		.byte	0
 4112 0482 03       		.uleb128 0x3
 4113 0483 23050000 		.4byte	.LASF79
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 94


 4114 0487 07       		.byte	0x7
 4115 0488 E9       		.byte	0xe9
 4116 0489 55040000 		.4byte	0x455
 4117 048d 0C       		.uleb128 0xc
 4118 048e A9030000 		.4byte	.LASF80
 4119 0492 01       		.byte	0x1
 4120 0493 2B       		.byte	0x2b
 4121 0494 00000000 		.4byte	.LFB64
 4122 0498 34000000 		.4byte	.LFE64-.LFB64
 4123 049c 01       		.uleb128 0x1
 4124 049d 9C       		.byte	0x9c
 4125 049e 0C       		.uleb128 0xc
 4126 049f 1A030000 		.4byte	.LASF81
 4127 04a3 01       		.byte	0x1
 4128 04a4 38       		.byte	0x38
 4129 04a5 00000000 		.4byte	.LFB65
 4130 04a9 18000000 		.4byte	.LFE65-.LFB65
 4131 04ad 01       		.uleb128 0x1
 4132 04ae 9C       		.byte	0x9c
 4133 04af 0D       		.uleb128 0xd
 4134 04b0 F4030000 		.4byte	.LASF119
 4135 04b4 01       		.byte	0x1
 4136 04b5 43       		.byte	0x43
 4137 04b6 8C000000 		.4byte	0x8c
 4138 04ba 00000000 		.4byte	.LFB66
 4139 04be C81A0000 		.4byte	.LFE66-.LFB66
 4140 04c2 01       		.uleb128 0x1
 4141 04c3 9C       		.byte	0x9c
 4142 04c4 9C060000 		.4byte	0x69c
 4143 04c8 0E       		.uleb128 0xe
 4144 04c9 8F050000 		.4byte	.LASF120
 4145 04cd 01       		.byte	0x1
 4146 04ce 43       		.byte	0x43
 4147 04cf D0000000 		.4byte	0xd0
 4148 04d3 03       		.uleb128 0x3
 4149 04d4 91       		.byte	0x91
 4150 04d5 8C7F     		.sleb128 -116
 4151 04d7 0F       		.uleb128 0xf
 4152 04d8 B7050000 		.4byte	.LASF82
 4153 04dc 01       		.byte	0x1
 4154 04dd 4F       		.byte	0x4f
 4155 04de 8C000000 		.4byte	0x8c
 4156 04e2 02       		.uleb128 0x2
 4157 04e3 91       		.byte	0x91
 4158 04e4 5F       		.sleb128 -33
 4159 04e5 0F       		.uleb128 0xf
 4160 04e6 69050000 		.4byte	.LASF83
 4161 04ea 01       		.byte	0x1
 4162 04eb 50       		.byte	0x50
 4163 04ec 8C000000 		.4byte	0x8c
 4164 04f0 02       		.uleb128 0x2
 4165 04f1 91       		.byte	0x91
 4166 04f2 5E       		.sleb128 -34
 4167 04f3 0F       		.uleb128 0xf
 4168 04f4 70050000 		.4byte	.LASF84
 4169 04f8 01       		.byte	0x1
 4170 04f9 50       		.byte	0x50
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 95


 4171 04fa 8C000000 		.4byte	0x8c
 4172 04fe 02       		.uleb128 0x2
 4173 04ff 91       		.byte	0x91
 4174 0500 5D       		.sleb128 -35
 4175 0501 0F       		.uleb128 0xf
 4176 0502 52010000 		.4byte	.LASF85
 4177 0506 01       		.byte	0x1
 4178 0507 50       		.byte	0x50
 4179 0508 8C000000 		.4byte	0x8c
 4180 050c 02       		.uleb128 0x2
 4181 050d 91       		.byte	0x91
 4182 050e 5C       		.sleb128 -36
 4183 050f 0F       		.uleb128 0xf
 4184 0510 A1020000 		.4byte	.LASF63
 4185 0514 01       		.byte	0x1
 4186 0515 51       		.byte	0x51
 4187 0516 8C000000 		.4byte	0x8c
 4188 051a 02       		.uleb128 0x2
 4189 051b 91       		.byte	0x91
 4190 051c 5B       		.sleb128 -37
 4191 051d 0F       		.uleb128 0xf
 4192 051e 1D060000 		.4byte	.LASF86
 4193 0522 01       		.byte	0x1
 4194 0523 54       		.byte	0x54
 4195 0524 8C000000 		.4byte	0x8c
 4196 0528 02       		.uleb128 0x2
 4197 0529 91       		.byte	0x91
 4198 052a 5A       		.sleb128 -38
 4199 052b 0F       		.uleb128 0xf
 4200 052c EE010000 		.4byte	.LASF87
 4201 0530 01       		.byte	0x1
 4202 0531 55       		.byte	0x55
 4203 0532 8C000000 		.4byte	0x8c
 4204 0536 02       		.uleb128 0x2
 4205 0537 91       		.byte	0x91
 4206 0538 59       		.sleb128 -39
 4207 0539 0F       		.uleb128 0xf
 4208 053a BE040000 		.4byte	.LASF88
 4209 053e 01       		.byte	0x1
 4210 053f 58       		.byte	0x58
 4211 0540 97000000 		.4byte	0x97
 4212 0544 02       		.uleb128 0x2
 4213 0545 91       		.byte	0x91
 4214 0546 56       		.sleb128 -42
 4215 0547 0F       		.uleb128 0xf
 4216 0548 57000000 		.4byte	.LASF89
 4217 054c 01       		.byte	0x1
 4218 054d 59       		.byte	0x59
 4219 054e 97000000 		.4byte	0x97
 4220 0552 02       		.uleb128 0x2
 4221 0553 91       		.byte	0x91
 4222 0554 54       		.sleb128 -44
 4223 0555 0F       		.uleb128 0xf
 4224 0556 70030000 		.4byte	.LASF90
 4225 055a 01       		.byte	0x1
 4226 055b 5A       		.byte	0x5a
 4227 055c 8C000000 		.4byte	0x8c
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 96


 4228 0560 02       		.uleb128 0x2
 4229 0561 91       		.byte	0x91
 4230 0562 53       		.sleb128 -45
 4231 0563 0F       		.uleb128 0xf
 4232 0564 2B030000 		.4byte	.LASF91
 4233 0568 01       		.byte	0x1
 4234 0569 6D       		.byte	0x6d
 4235 056a 8C000000 		.4byte	0x8c
 4236 056e 02       		.uleb128 0x2
 4237 056f 91       		.byte	0x91
 4238 0570 52       		.sleb128 -46
 4239 0571 0F       		.uleb128 0xf
 4240 0572 6D060000 		.4byte	.LASF92
 4241 0576 01       		.byte	0x1
 4242 0577 6E       		.byte	0x6e
 4243 0578 8C000000 		.4byte	0x8c
 4244 057c 03       		.uleb128 0x3
 4245 057d 91       		.byte	0x91
 4246 057e AE7F     		.sleb128 -82
 4247 0580 0F       		.uleb128 0xf
 4248 0581 88020000 		.4byte	.LASF93
 4249 0585 01       		.byte	0x1
 4250 0586 6F       		.byte	0x6f
 4251 0587 BB000000 		.4byte	0xbb
 4252 058b 02       		.uleb128 0x2
 4253 058c 91       		.byte	0x91
 4254 058d 45       		.sleb128 -59
 4255 058e 0F       		.uleb128 0xf
 4256 058f 36020000 		.4byte	.LASF94
 4257 0593 01       		.byte	0x1
 4258 0594 70       		.byte	0x70
 4259 0595 AD000000 		.4byte	0xad
 4260 0599 03       		.uleb128 0x3
 4261 059a 91       		.byte	0x91
 4262 059b A87F     		.sleb128 -88
 4263 059d 0F       		.uleb128 0xf
 4264 059e B4040000 		.4byte	.LASF95
 4265 05a2 01       		.byte	0x1
 4266 05a3 71       		.byte	0x71
 4267 05a4 8C000000 		.4byte	0x8c
 4268 05a8 02       		.uleb128 0x2
 4269 05a9 91       		.byte	0x91
 4270 05aa 46       		.sleb128 -58
 4271 05ab 0F       		.uleb128 0xf
 4272 05ac 1E010000 		.4byte	.LASF96
 4273 05b0 01       		.byte	0x1
 4274 05b1 72       		.byte	0x72
 4275 05b2 97000000 		.4byte	0x97
 4276 05b6 02       		.uleb128 0x2
 4277 05b7 91       		.byte	0x91
 4278 05b8 50       		.sleb128 -48
 4279 05b9 10       		.uleb128 0x10
 4280 05ba 69647800 		.ascii	"idx\000"
 4281 05be 01       		.byte	0x1
 4282 05bf D801     		.2byte	0x1d8
 4283 05c1 8C000000 		.4byte	0x8c
 4284 05c5 02       		.uleb128 0x2
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 97


 4285 05c6 91       		.byte	0x91
 4286 05c7 4F       		.sleb128 -49
 4287 05c8 11       		.uleb128 0x11
 4288 05c9 10050000 		.4byte	.LASF97
 4289 05cd 01       		.byte	0x1
 4290 05ce F601     		.2byte	0x1f6
 4291 05d0 C8010000 		.4byte	0x1c8
 4292 05d4 03       		.uleb128 0x3
 4293 05d5 91       		.byte	0x91
 4294 05d6 9C7F     		.sleb128 -100
 4295 05d8 11       		.uleb128 0x11
 4296 05d9 77050000 		.4byte	.LASF98
 4297 05dd 01       		.byte	0x1
 4298 05de 4D03     		.2byte	0x34d
 4299 05e0 CC020000 		.4byte	0x2cc
 4300 05e4 03       		.uleb128 0x3
 4301 05e5 91       		.byte	0x91
 4302 05e6 907F     		.sleb128 -112
 4303 05e8 11       		.uleb128 0x11
 4304 05e9 2F000000 		.4byte	.LASF99
 4305 05ed 01       		.byte	0x1
 4306 05ee 4E03     		.2byte	0x34e
 4307 05f0 9C060000 		.4byte	0x69c
 4308 05f4 03       		.uleb128 0x3
 4309 05f5 91       		.byte	0x91
 4310 05f6 B07F     		.sleb128 -80
 4311 05f8 12       		.uleb128 0x12
 4312 05f9 72100000 		.4byte	.LBB2
 4313 05fd 64040000 		.4byte	.LBE2-.LBB2
 4314 0601 64060000 		.4byte	0x664
 4315 0605 10       		.uleb128 0x10
 4316 0606 7800     		.ascii	"x\000"
 4317 0608 01       		.byte	0x1
 4318 0609 AD02     		.2byte	0x2ad
 4319 060b AD000000 		.4byte	0xad
 4320 060f 02       		.uleb128 0x2
 4321 0610 91       		.byte	0x91
 4322 0611 40       		.sleb128 -64
 4323 0612 10       		.uleb128 0x10
 4324 0613 7900     		.ascii	"y\000"
 4325 0615 01       		.byte	0x1
 4326 0616 AD02     		.2byte	0x2ad
 4327 0618 AD000000 		.4byte	0xad
 4328 061c 03       		.uleb128 0x3
 4329 061d 91       		.byte	0x91
 4330 061e BC7F     		.sleb128 -68
 4331 0620 12       		.uleb128 0x12
 4332 0621 1C110000 		.4byte	.LBB3
 4333 0625 D0010000 		.4byte	.LBE3-.LBB3
 4334 0629 3D060000 		.4byte	0x63d
 4335 062d 11       		.uleb128 0x11
 4336 062e 12060000 		.4byte	.LASF100
 4337 0632 01       		.byte	0x1
 4338 0633 E902     		.2byte	0x2e9
 4339 0635 AD000000 		.4byte	0xad
 4340 0639 02       		.uleb128 0x2
 4341 063a 91       		.byte	0x91
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 98


 4342 063b 48       		.sleb128 -56
 4343 063c 00       		.byte	0
 4344 063d 13       		.uleb128 0x13
 4345 063e 00000000 		.4byte	.Ldebug_ranges0+0
 4346 0642 11       		.uleb128 0x11
 4347 0643 E2020000 		.4byte	.LASF101
 4348 0647 01       		.byte	0x1
 4349 0648 1B03     		.2byte	0x31b
 4350 064a AD000000 		.4byte	0xad
 4351 064e 03       		.uleb128 0x3
 4352 064f 91       		.byte	0x91
 4353 0650 B87F     		.sleb128 -72
 4354 0652 11       		.uleb128 0x11
 4355 0653 80030000 		.4byte	.LASF102
 4356 0657 01       		.byte	0x1
 4357 0658 2103     		.2byte	0x321
 4358 065a AD000000 		.4byte	0xad
 4359 065e 03       		.uleb128 0x3
 4360 065f 91       		.byte	0x91
 4361 0660 B47F     		.sleb128 -76
 4362 0662 00       		.byte	0
 4363 0663 00       		.byte	0
 4364 0664 12       		.uleb128 0x12
 4365 0665 3C150000 		.4byte	.LBB7
 4366 0669 68000000 		.4byte	.LBE7-.LBB7
 4367 066d 82060000 		.4byte	0x682
 4368 0671 11       		.uleb128 0x11
 4369 0672 5A030000 		.4byte	.LASF103
 4370 0676 01       		.byte	0x1
 4371 0677 5F03     		.2byte	0x35f
 4372 0679 8C000000 		.4byte	0x8c
 4373 067d 03       		.uleb128 0x3
 4374 067e 91       		.byte	0x91
 4375 067f AF7F     		.sleb128 -81
 4376 0681 00       		.byte	0
 4377 0682 14       		.uleb128 0x14
 4378 0683 2A190000 		.4byte	.LBB8
 4379 0687 C8000000 		.4byte	.LBE8-.LBB8
 4380 068b 11       		.uleb128 0x11
 4381 068c F9020000 		.4byte	.LASF104
 4382 0690 01       		.byte	0x1
 4383 0691 1604     		.2byte	0x416
 4384 0693 8C000000 		.4byte	0x8c
 4385 0697 02       		.uleb128 0x2
 4386 0698 91       		.byte	0x91
 4387 0699 47       		.sleb128 -57
 4388 069a 00       		.byte	0
 4389 069b 00       		.byte	0
 4390 069c 05       		.uleb128 0x5
 4391 069d 04       		.byte	0x4
 4392 069e CC020000 		.4byte	0x2cc
 4393 06a2 15       		.uleb128 0x15
 4394 06a3 81040000 		.4byte	.LASF105
 4395 06a7 08       		.byte	0x8
 4396 06a8 1207     		.2byte	0x712
 4397 06aa AE060000 		.4byte	0x6ae
 4398 06ae 06       		.uleb128 0x6
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 99


 4399 06af A2000000 		.4byte	0xa2
 4400 06b3 16       		.uleb128 0x16
 4401 06b4 AE020000 		.4byte	.LASF106
 4402 06b8 04       		.byte	0x4
 4403 06b9 6A       		.byte	0x6a
 4404 06ba D8010000 		.4byte	0x1d8
 4405 06be 17       		.uleb128 0x17
 4406 06bf 73797300 		.ascii	"sys\000"
 4407 06c3 05       		.byte	0x5
 4408 06c4 93       		.byte	0x93
 4409 06c5 94020000 		.4byte	0x294
 4410 06c9 09       		.uleb128 0x9
 4411 06ca A2000000 		.4byte	0xa2
 4412 06ce D9060000 		.4byte	0x6d9
 4413 06d2 0A       		.uleb128 0xa
 4414 06d3 C9000000 		.4byte	0xc9
 4415 06d7 02       		.byte	0x2
 4416 06d8 00       		.byte	0
 4417 06d9 18       		.uleb128 0x18
 4418 06da E7030000 		.4byte	.LASF107
 4419 06de 05       		.byte	0x5
 4420 06df 96       		.byte	0x96
 4421 06e0 C9060000 		.4byte	0x6c9
 4422 06e4 05       		.uleb128 0x5
 4423 06e5 03       		.byte	0x3
 4424 06e6 00000000 		.4byte	sys_position
 4425 06ea 18       		.uleb128 0x18
 4426 06eb 96030000 		.4byte	.LASF108
 4427 06ef 05       		.byte	0x5
 4428 06f0 97       		.byte	0x97
 4429 06f1 C9060000 		.4byte	0x6c9
 4430 06f5 05       		.uleb128 0x5
 4431 06f6 03       		.byte	0x3
 4432 06f7 00000000 		.4byte	sys_probe_position
 4433 06fb 18       		.uleb128 0x18
 4434 06fc 0E010000 		.4byte	.LASF109
 4435 0700 05       		.byte	0x5
 4436 0701 99       		.byte	0x99
 4437 0702 D6000000 		.4byte	0xd6
 4438 0706 05       		.uleb128 0x5
 4439 0707 03       		.byte	0x3
 4440 0708 00000000 		.4byte	sys_probe_state
 4441 070c 18       		.uleb128 0x18
 4442 070d 8F020000 		.4byte	.LASF110
 4443 0711 05       		.byte	0x5
 4444 0712 9A       		.byte	0x9a
 4445 0713 D6000000 		.4byte	0xd6
 4446 0717 05       		.uleb128 0x5
 4447 0718 03       		.byte	0x3
 4448 0719 00000000 		.4byte	sys_rt_exec_state
 4449 071d 18       		.uleb128 0x18
 4450 071e 9A050000 		.4byte	.LASF111
 4451 0722 05       		.byte	0x5
 4452 0723 9B       		.byte	0x9b
 4453 0724 D6000000 		.4byte	0xd6
 4454 0728 05       		.uleb128 0x5
 4455 0729 03       		.byte	0x3
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 100


 4456 072a 00000000 		.4byte	sys_rt_exec_alarm
 4457 072e 18       		.uleb128 0x18
 4458 072f 45040000 		.4byte	.LASF112
 4459 0733 05       		.byte	0x5
 4460 0734 9C       		.byte	0x9c
 4461 0735 D6000000 		.4byte	0xd6
 4462 0739 05       		.uleb128 0x5
 4463 073a 03       		.byte	0x3
 4464 073b 00000000 		.4byte	sys_rt_exec_motion_override
 4465 073f 18       		.uleb128 0x18
 4466 0740 F1040000 		.4byte	.LASF113
 4467 0744 05       		.byte	0x5
 4468 0745 9D       		.byte	0x9d
 4469 0746 D6000000 		.4byte	0xd6
 4470 074a 05       		.uleb128 0x5
 4471 074b 03       		.byte	0x3
 4472 074c 00000000 		.4byte	sys_rt_exec_accessory_override
 4473 0750 18       		.uleb128 0x18
 4474 0751 D7030000 		.4byte	.LASF114
 4475 0755 01       		.byte	0x1
 4476 0756 25       		.byte	0x25
 4477 0757 4A040000 		.4byte	0x44a
 4478 075b 05       		.uleb128 0x5
 4479 075c 03       		.byte	0x3
 4480 075d 00000000 		.4byte	gc_state
 4481 0761 18       		.uleb128 0x18
 4482 0762 6A020000 		.4byte	.LASF115
 4483 0766 01       		.byte	0x1
 4484 0767 26       		.byte	0x26
 4485 0768 82040000 		.4byte	0x482
 4486 076c 05       		.uleb128 0x5
 4487 076d 03       		.byte	0x3
 4488 076e 00000000 		.4byte	gc_block
 4489 0772 00       		.byte	0
 4490              		.section	.debug_abbrev,"",%progbits
 4491              	.Ldebug_abbrev0:
 4492 0000 01       		.uleb128 0x1
 4493 0001 11       		.uleb128 0x11
 4494 0002 01       		.byte	0x1
 4495 0003 25       		.uleb128 0x25
 4496 0004 0E       		.uleb128 0xe
 4497 0005 13       		.uleb128 0x13
 4498 0006 0B       		.uleb128 0xb
 4499 0007 03       		.uleb128 0x3
 4500 0008 0E       		.uleb128 0xe
 4501 0009 1B       		.uleb128 0x1b
 4502 000a 0E       		.uleb128 0xe
 4503 000b 55       		.uleb128 0x55
 4504 000c 17       		.uleb128 0x17
 4505 000d 11       		.uleb128 0x11
 4506 000e 01       		.uleb128 0x1
 4507 000f 10       		.uleb128 0x10
 4508 0010 17       		.uleb128 0x17
 4509 0011 00       		.byte	0
 4510 0012 00       		.byte	0
 4511 0013 02       		.uleb128 0x2
 4512 0014 24       		.uleb128 0x24
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 101


 4513 0015 00       		.byte	0
 4514 0016 0B       		.uleb128 0xb
 4515 0017 0B       		.uleb128 0xb
 4516 0018 3E       		.uleb128 0x3e
 4517 0019 0B       		.uleb128 0xb
 4518 001a 03       		.uleb128 0x3
 4519 001b 0E       		.uleb128 0xe
 4520 001c 00       		.byte	0
 4521 001d 00       		.byte	0
 4522 001e 03       		.uleb128 0x3
 4523 001f 16       		.uleb128 0x16
 4524 0020 00       		.byte	0
 4525 0021 03       		.uleb128 0x3
 4526 0022 0E       		.uleb128 0xe
 4527 0023 3A       		.uleb128 0x3a
 4528 0024 0B       		.uleb128 0xb
 4529 0025 3B       		.uleb128 0x3b
 4530 0026 0B       		.uleb128 0xb
 4531 0027 49       		.uleb128 0x49
 4532 0028 13       		.uleb128 0x13
 4533 0029 00       		.byte	0
 4534 002a 00       		.byte	0
 4535 002b 04       		.uleb128 0x4
 4536 002c 24       		.uleb128 0x24
 4537 002d 00       		.byte	0
 4538 002e 0B       		.uleb128 0xb
 4539 002f 0B       		.uleb128 0xb
 4540 0030 3E       		.uleb128 0x3e
 4541 0031 0B       		.uleb128 0xb
 4542 0032 03       		.uleb128 0x3
 4543 0033 08       		.uleb128 0x8
 4544 0034 00       		.byte	0
 4545 0035 00       		.byte	0
 4546 0036 05       		.uleb128 0x5
 4547 0037 0F       		.uleb128 0xf
 4548 0038 00       		.byte	0
 4549 0039 0B       		.uleb128 0xb
 4550 003a 0B       		.uleb128 0xb
 4551 003b 49       		.uleb128 0x49
 4552 003c 13       		.uleb128 0x13
 4553 003d 00       		.byte	0
 4554 003e 00       		.byte	0
 4555 003f 06       		.uleb128 0x6
 4556 0040 35       		.uleb128 0x35
 4557 0041 00       		.byte	0
 4558 0042 49       		.uleb128 0x49
 4559 0043 13       		.uleb128 0x13
 4560 0044 00       		.byte	0
 4561 0045 00       		.byte	0
 4562 0046 07       		.uleb128 0x7
 4563 0047 13       		.uleb128 0x13
 4564 0048 01       		.byte	0x1
 4565 0049 0B       		.uleb128 0xb
 4566 004a 0B       		.uleb128 0xb
 4567 004b 3A       		.uleb128 0x3a
 4568 004c 0B       		.uleb128 0xb
 4569 004d 3B       		.uleb128 0x3b
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 102


 4570 004e 0B       		.uleb128 0xb
 4571 004f 01       		.uleb128 0x1
 4572 0050 13       		.uleb128 0x13
 4573 0051 00       		.byte	0
 4574 0052 00       		.byte	0
 4575 0053 08       		.uleb128 0x8
 4576 0054 0D       		.uleb128 0xd
 4577 0055 00       		.byte	0
 4578 0056 03       		.uleb128 0x3
 4579 0057 0E       		.uleb128 0xe
 4580 0058 3A       		.uleb128 0x3a
 4581 0059 0B       		.uleb128 0xb
 4582 005a 3B       		.uleb128 0x3b
 4583 005b 0B       		.uleb128 0xb
 4584 005c 49       		.uleb128 0x49
 4585 005d 13       		.uleb128 0x13
 4586 005e 38       		.uleb128 0x38
 4587 005f 0B       		.uleb128 0xb
 4588 0060 00       		.byte	0
 4589 0061 00       		.byte	0
 4590 0062 09       		.uleb128 0x9
 4591 0063 01       		.uleb128 0x1
 4592 0064 01       		.byte	0x1
 4593 0065 49       		.uleb128 0x49
 4594 0066 13       		.uleb128 0x13
 4595 0067 01       		.uleb128 0x1
 4596 0068 13       		.uleb128 0x13
 4597 0069 00       		.byte	0
 4598 006a 00       		.byte	0
 4599 006b 0A       		.uleb128 0xa
 4600 006c 21       		.uleb128 0x21
 4601 006d 00       		.byte	0
 4602 006e 49       		.uleb128 0x49
 4603 006f 13       		.uleb128 0x13
 4604 0070 2F       		.uleb128 0x2f
 4605 0071 0B       		.uleb128 0xb
 4606 0072 00       		.byte	0
 4607 0073 00       		.byte	0
 4608 0074 0B       		.uleb128 0xb
 4609 0075 0D       		.uleb128 0xd
 4610 0076 00       		.byte	0
 4611 0077 03       		.uleb128 0x3
 4612 0078 08       		.uleb128 0x8
 4613 0079 3A       		.uleb128 0x3a
 4614 007a 0B       		.uleb128 0xb
 4615 007b 3B       		.uleb128 0x3b
 4616 007c 0B       		.uleb128 0xb
 4617 007d 49       		.uleb128 0x49
 4618 007e 13       		.uleb128 0x13
 4619 007f 38       		.uleb128 0x38
 4620 0080 0B       		.uleb128 0xb
 4621 0081 00       		.byte	0
 4622 0082 00       		.byte	0
 4623 0083 0C       		.uleb128 0xc
 4624 0084 2E       		.uleb128 0x2e
 4625 0085 00       		.byte	0
 4626 0086 3F       		.uleb128 0x3f
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 103


 4627 0087 19       		.uleb128 0x19
 4628 0088 03       		.uleb128 0x3
 4629 0089 0E       		.uleb128 0xe
 4630 008a 3A       		.uleb128 0x3a
 4631 008b 0B       		.uleb128 0xb
 4632 008c 3B       		.uleb128 0x3b
 4633 008d 0B       		.uleb128 0xb
 4634 008e 11       		.uleb128 0x11
 4635 008f 01       		.uleb128 0x1
 4636 0090 12       		.uleb128 0x12
 4637 0091 06       		.uleb128 0x6
 4638 0092 40       		.uleb128 0x40
 4639 0093 18       		.uleb128 0x18
 4640 0094 9642     		.uleb128 0x2116
 4641 0096 19       		.uleb128 0x19
 4642 0097 00       		.byte	0
 4643 0098 00       		.byte	0
 4644 0099 0D       		.uleb128 0xd
 4645 009a 2E       		.uleb128 0x2e
 4646 009b 01       		.byte	0x1
 4647 009c 3F       		.uleb128 0x3f
 4648 009d 19       		.uleb128 0x19
 4649 009e 03       		.uleb128 0x3
 4650 009f 0E       		.uleb128 0xe
 4651 00a0 3A       		.uleb128 0x3a
 4652 00a1 0B       		.uleb128 0xb
 4653 00a2 3B       		.uleb128 0x3b
 4654 00a3 0B       		.uleb128 0xb
 4655 00a4 27       		.uleb128 0x27
 4656 00a5 19       		.uleb128 0x19
 4657 00a6 49       		.uleb128 0x49
 4658 00a7 13       		.uleb128 0x13
 4659 00a8 11       		.uleb128 0x11
 4660 00a9 01       		.uleb128 0x1
 4661 00aa 12       		.uleb128 0x12
 4662 00ab 06       		.uleb128 0x6
 4663 00ac 40       		.uleb128 0x40
 4664 00ad 18       		.uleb128 0x18
 4665 00ae 9642     		.uleb128 0x2116
 4666 00b0 19       		.uleb128 0x19
 4667 00b1 01       		.uleb128 0x1
 4668 00b2 13       		.uleb128 0x13
 4669 00b3 00       		.byte	0
 4670 00b4 00       		.byte	0
 4671 00b5 0E       		.uleb128 0xe
 4672 00b6 05       		.uleb128 0x5
 4673 00b7 00       		.byte	0
 4674 00b8 03       		.uleb128 0x3
 4675 00b9 0E       		.uleb128 0xe
 4676 00ba 3A       		.uleb128 0x3a
 4677 00bb 0B       		.uleb128 0xb
 4678 00bc 3B       		.uleb128 0x3b
 4679 00bd 0B       		.uleb128 0xb
 4680 00be 49       		.uleb128 0x49
 4681 00bf 13       		.uleb128 0x13
 4682 00c0 02       		.uleb128 0x2
 4683 00c1 18       		.uleb128 0x18
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 104


 4684 00c2 00       		.byte	0
 4685 00c3 00       		.byte	0
 4686 00c4 0F       		.uleb128 0xf
 4687 00c5 34       		.uleb128 0x34
 4688 00c6 00       		.byte	0
 4689 00c7 03       		.uleb128 0x3
 4690 00c8 0E       		.uleb128 0xe
 4691 00c9 3A       		.uleb128 0x3a
 4692 00ca 0B       		.uleb128 0xb
 4693 00cb 3B       		.uleb128 0x3b
 4694 00cc 0B       		.uleb128 0xb
 4695 00cd 49       		.uleb128 0x49
 4696 00ce 13       		.uleb128 0x13
 4697 00cf 02       		.uleb128 0x2
 4698 00d0 18       		.uleb128 0x18
 4699 00d1 00       		.byte	0
 4700 00d2 00       		.byte	0
 4701 00d3 10       		.uleb128 0x10
 4702 00d4 34       		.uleb128 0x34
 4703 00d5 00       		.byte	0
 4704 00d6 03       		.uleb128 0x3
 4705 00d7 08       		.uleb128 0x8
 4706 00d8 3A       		.uleb128 0x3a
 4707 00d9 0B       		.uleb128 0xb
 4708 00da 3B       		.uleb128 0x3b
 4709 00db 05       		.uleb128 0x5
 4710 00dc 49       		.uleb128 0x49
 4711 00dd 13       		.uleb128 0x13
 4712 00de 02       		.uleb128 0x2
 4713 00df 18       		.uleb128 0x18
 4714 00e0 00       		.byte	0
 4715 00e1 00       		.byte	0
 4716 00e2 11       		.uleb128 0x11
 4717 00e3 34       		.uleb128 0x34
 4718 00e4 00       		.byte	0
 4719 00e5 03       		.uleb128 0x3
 4720 00e6 0E       		.uleb128 0xe
 4721 00e7 3A       		.uleb128 0x3a
 4722 00e8 0B       		.uleb128 0xb
 4723 00e9 3B       		.uleb128 0x3b
 4724 00ea 05       		.uleb128 0x5
 4725 00eb 49       		.uleb128 0x49
 4726 00ec 13       		.uleb128 0x13
 4727 00ed 02       		.uleb128 0x2
 4728 00ee 18       		.uleb128 0x18
 4729 00ef 00       		.byte	0
 4730 00f0 00       		.byte	0
 4731 00f1 12       		.uleb128 0x12
 4732 00f2 0B       		.uleb128 0xb
 4733 00f3 01       		.byte	0x1
 4734 00f4 11       		.uleb128 0x11
 4735 00f5 01       		.uleb128 0x1
 4736 00f6 12       		.uleb128 0x12
 4737 00f7 06       		.uleb128 0x6
 4738 00f8 01       		.uleb128 0x1
 4739 00f9 13       		.uleb128 0x13
 4740 00fa 00       		.byte	0
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 105


 4741 00fb 00       		.byte	0
 4742 00fc 13       		.uleb128 0x13
 4743 00fd 0B       		.uleb128 0xb
 4744 00fe 01       		.byte	0x1
 4745 00ff 55       		.uleb128 0x55
 4746 0100 17       		.uleb128 0x17
 4747 0101 00       		.byte	0
 4748 0102 00       		.byte	0
 4749 0103 14       		.uleb128 0x14
 4750 0104 0B       		.uleb128 0xb
 4751 0105 01       		.byte	0x1
 4752 0106 11       		.uleb128 0x11
 4753 0107 01       		.uleb128 0x1
 4754 0108 12       		.uleb128 0x12
 4755 0109 06       		.uleb128 0x6
 4756 010a 00       		.byte	0
 4757 010b 00       		.byte	0
 4758 010c 15       		.uleb128 0x15
 4759 010d 34       		.uleb128 0x34
 4760 010e 00       		.byte	0
 4761 010f 03       		.uleb128 0x3
 4762 0110 0E       		.uleb128 0xe
 4763 0111 3A       		.uleb128 0x3a
 4764 0112 0B       		.uleb128 0xb
 4765 0113 3B       		.uleb128 0x3b
 4766 0114 05       		.uleb128 0x5
 4767 0115 49       		.uleb128 0x49
 4768 0116 13       		.uleb128 0x13
 4769 0117 3F       		.uleb128 0x3f
 4770 0118 19       		.uleb128 0x19
 4771 0119 3C       		.uleb128 0x3c
 4772 011a 19       		.uleb128 0x19
 4773 011b 00       		.byte	0
 4774 011c 00       		.byte	0
 4775 011d 16       		.uleb128 0x16
 4776 011e 34       		.uleb128 0x34
 4777 011f 00       		.byte	0
 4778 0120 03       		.uleb128 0x3
 4779 0121 0E       		.uleb128 0xe
 4780 0122 3A       		.uleb128 0x3a
 4781 0123 0B       		.uleb128 0xb
 4782 0124 3B       		.uleb128 0x3b
 4783 0125 0B       		.uleb128 0xb
 4784 0126 49       		.uleb128 0x49
 4785 0127 13       		.uleb128 0x13
 4786 0128 3F       		.uleb128 0x3f
 4787 0129 19       		.uleb128 0x19
 4788 012a 3C       		.uleb128 0x3c
 4789 012b 19       		.uleb128 0x19
 4790 012c 00       		.byte	0
 4791 012d 00       		.byte	0
 4792 012e 17       		.uleb128 0x17
 4793 012f 34       		.uleb128 0x34
 4794 0130 00       		.byte	0
 4795 0131 03       		.uleb128 0x3
 4796 0132 08       		.uleb128 0x8
 4797 0133 3A       		.uleb128 0x3a
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 106


 4798 0134 0B       		.uleb128 0xb
 4799 0135 3B       		.uleb128 0x3b
 4800 0136 0B       		.uleb128 0xb
 4801 0137 49       		.uleb128 0x49
 4802 0138 13       		.uleb128 0x13
 4803 0139 3F       		.uleb128 0x3f
 4804 013a 19       		.uleb128 0x19
 4805 013b 3C       		.uleb128 0x3c
 4806 013c 19       		.uleb128 0x19
 4807 013d 00       		.byte	0
 4808 013e 00       		.byte	0
 4809 013f 18       		.uleb128 0x18
 4810 0140 34       		.uleb128 0x34
 4811 0141 00       		.byte	0
 4812 0142 03       		.uleb128 0x3
 4813 0143 0E       		.uleb128 0xe
 4814 0144 3A       		.uleb128 0x3a
 4815 0145 0B       		.uleb128 0xb
 4816 0146 3B       		.uleb128 0x3b
 4817 0147 0B       		.uleb128 0xb
 4818 0148 49       		.uleb128 0x49
 4819 0149 13       		.uleb128 0x13
 4820 014a 3F       		.uleb128 0x3f
 4821 014b 19       		.uleb128 0x19
 4822 014c 02       		.uleb128 0x2
 4823 014d 18       		.uleb128 0x18
 4824 014e 00       		.byte	0
 4825 014f 00       		.byte	0
 4826 0150 00       		.byte	0
 4827              		.section	.debug_aranges,"",%progbits
 4828 0000 2C000000 		.4byte	0x2c
 4829 0004 0200     		.2byte	0x2
 4830 0006 00000000 		.4byte	.Ldebug_info0
 4831 000a 04       		.byte	0x4
 4832 000b 00       		.byte	0
 4833 000c 0000     		.2byte	0
 4834 000e 0000     		.2byte	0
 4835 0010 00000000 		.4byte	.LFB64
 4836 0014 34000000 		.4byte	.LFE64-.LFB64
 4837 0018 00000000 		.4byte	.LFB65
 4838 001c 18000000 		.4byte	.LFE65-.LFB65
 4839 0020 00000000 		.4byte	.LFB66
 4840 0024 C81A0000 		.4byte	.LFE66-.LFB66
 4841 0028 00000000 		.4byte	0
 4842 002c 00000000 		.4byte	0
 4843              		.section	.debug_ranges,"",%progbits
 4844              	.Ldebug_ranges0:
 4845 0000 EE120000 		.4byte	.LBB4
 4846 0004 3C140000 		.4byte	.LBE4
 4847 0008 3E140000 		.4byte	.LBB5
 4848 000c 82140000 		.4byte	.LBE5
 4849 0010 84140000 		.4byte	.LBB6
 4850 0014 88140000 		.4byte	.LBE6
 4851 0018 00000000 		.4byte	0
 4852 001c 00000000 		.4byte	0
 4853 0020 00000000 		.4byte	.LFB64
 4854 0024 34000000 		.4byte	.LFE64
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 107


 4855 0028 00000000 		.4byte	.LFB65
 4856 002c 18000000 		.4byte	.LFE65
 4857 0030 00000000 		.4byte	.LFB66
 4858 0034 C81A0000 		.4byte	.LFE66
 4859 0038 00000000 		.4byte	0
 4860 003c 00000000 		.4byte	0
 4861              		.section	.debug_line,"",%progbits
 4862              	.Ldebug_line0:
 4863 0000 60060000 		.section	.debug_str,"MS",%progbits,1
 4863      02007201 
 4863      00000201 
 4863      FB0E0D00 
 4863      01010101 
 4864              	.LASF24:
 4865 0000 70756C73 		.ascii	"pulse_microseconds\000"
 4865      655F6D69 
 4865      63726F73 
 4865      65636F6E 
 4865      647300
 4866              	.LASF60:
 4867 0013 64697374 		.ascii	"distance\000"
 4867      616E6365 
 4867      00
 4868              	.LASF64:
 4869 001c 70726F67 		.ascii	"program_flow\000"
 4869      72616D5F 
 4869      666C6F77 
 4869      00
 4870              	.LASF33:
 4871 0029 666C6167 		.ascii	"flags\000"
 4871      7300
 4872              	.LASF99:
 4873 002f 706C5F64 		.ascii	"pl_data\000"
 4873      61746100 
 4874              	.LASF28:
 4875 0037 73746174 		.ascii	"status_report_mask\000"
 4875      75735F72 
 4875      65706F72 
 4875      745F6D61 
 4875      736B00
 4876              	.LASF11:
 4877 004a 756E7369 		.ascii	"unsigned int\000"
 4877      676E6564 
 4877      20696E74 
 4877      00
 4878              	.LASF89:
 4879 0057 76616C75 		.ascii	"value_words\000"
 4879      655F776F 
 4879      72647300 
 4880              	.LASF117:
 4881 0063 67636F64 		.ascii	"gcode.c\000"
 4881      652E6300 
 4882              	.LASF48:
 4883 006b 725F6F76 		.ascii	"r_override\000"
 4883      65727269 
 4883      646500
 4884              	.LASF6:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 108


 4885 0076 5F5F696E 		.ascii	"__int32_t\000"
 4885      7433325F 
 4885      7400
 4886              	.LASF116:
 4887 0080 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 4887      43313120 
 4887      352E342E 
 4887      31203230 
 4887      31363036 
 4888 00b3 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 4888      20726576 
 4888      6973696F 
 4888      6E203233 
 4888      37373135 
 4889 00e6 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 4889      66756E63 
 4889      74696F6E 
 4889      2D736563 
 4889      74696F6E 
 4890              	.LASF109:
 4891 010e 7379735F 		.ascii	"sys_probe_state\000"
 4891      70726F62 
 4891      655F7374 
 4891      61746500 
 4892              	.LASF96:
 4893 011e 6D616E74 		.ascii	"mantissa\000"
 4893      69737361 
 4893      00
 4894              	.LASF27:
 4895 0127 73746570 		.ascii	"stepper_idle_lock_time\000"
 4895      7065725F 
 4895      69646C65 
 4895      5F6C6F63 
 4895      6B5F7469 
 4896              	.LASF69:
 4897 013e 6D6F6461 		.ascii	"modal\000"
 4897      6C00
 4898              	.LASF30:
 4899 0144 6172635F 		.ascii	"arc_tolerance\000"
 4899      746F6C65 
 4899      72616E63 
 4899      6500
 4900              	.LASF85:
 4901 0152 61786973 		.ascii	"axis_linear\000"
 4901      5F6C696E 
 4901      65617200 
 4902              	.LASF66:
 4903 015e 7370696E 		.ascii	"spindle\000"
 4903      646C6500 
 4904              	.LASF22:
 4905 0166 61636365 		.ascii	"acceleration\000"
 4905      6C657261 
 4905      74696F6E 
 4905      00
 4906              	.LASF36:
 4907 0173 686F6D69 		.ascii	"homing_seek_rate\000"
 4907      6E675F73 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 109


 4907      65656B5F 
 4907      72617465 
 4907      00
 4908              	.LASF35:
 4909 0184 686F6D69 		.ascii	"homing_feed_rate\000"
 4909      6E675F66 
 4909      6565645F 
 4909      72617465 
 4909      00
 4910              	.LASF15:
 4911 0195 666C6F61 		.ascii	"float\000"
 4911      7400
 4912              	.LASF118:
 4913 019b 433A5C55 		.ascii	"C:\\Users\\barto\\Dropbox\\PSoC\\Grbl_USB_Native\\G"
 4913      73657273 
 4913      5C626172 
 4913      746F5C44 
 4913      726F7062 
 4914 01c8 72626C5F 		.ascii	"rbl_USB_Native.cydsn\000"
 4914      5553425F 
 4914      4E617469 
 4914      76652E63 
 4914      7964736E 
 4915              	.LASF57:
 4916 01dd 706C616E 		.ascii	"plan_line_data_t\000"
 4916      5F6C696E 
 4916      655F6461 
 4916      74615F74 
 4916      00
 4917              	.LASF87:
 4918 01ee 696A6B5F 		.ascii	"ijk_words\000"
 4918      776F7264 
 4918      7300
 4919              	.LASF10:
 4920 01f8 6C6F6E67 		.ascii	"long long unsigned int\000"
 4920      206C6F6E 
 4920      6720756E 
 4920      7369676E 
 4920      65642069 
 4921              	.LASF47:
 4922 020f 665F6F76 		.ascii	"f_override\000"
 4922      65727269 
 4922      646500
 4923              	.LASF4:
 4924 021a 5F5F7569 		.ascii	"__uint16_t\000"
 4924      6E743136 
 4924      5F7400
 4925              	.LASF50:
 4926 0225 7370696E 		.ascii	"spindle_stop_ovr\000"
 4926      646C655F 
 4926      73746F70 
 4926      5F6F7672 
 4926      00
 4927              	.LASF94:
 4928 0236 76616C75 		.ascii	"value\000"
 4928      6500
 4929              	.LASF41:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 110


 4930 023c 61626F72 		.ascii	"abort\000"
 4930      7400
 4931              	.LASF65:
 4932 0242 636F6F6C 		.ascii	"coolant\000"
 4932      616E7400 
 4933              	.LASF62:
 4934 024a 746F6F6C 		.ascii	"tool_length\000"
 4934      5F6C656E 
 4934      67746800 
 4935              	.LASF38:
 4936 0256 686F6D69 		.ascii	"homing_pulloff\000"
 4936      6E675F70 
 4936      756C6C6F 
 4936      666600
 4937              	.LASF70:
 4938 0265 746F6F6C 		.ascii	"tool\000"
 4938      00
 4939              	.LASF115:
 4940 026a 67635F62 		.ascii	"gc_block\000"
 4940      6C6F636B 
 4940      00
 4941              	.LASF42:
 4942 0273 73757370 		.ascii	"suspend\000"
 4942      656E6400 
 4943              	.LASF61:
 4944 027b 706C616E 		.ascii	"plane_select\000"
 4944      655F7365 
 4944      6C656374 
 4944      00
 4945              	.LASF93:
 4946 0288 6C657474 		.ascii	"letter\000"
 4946      657200
 4947              	.LASF110:
 4948 028f 7379735F 		.ascii	"sys_rt_exec_state\000"
 4948      72745F65 
 4948      7865635F 
 4948      73746174 
 4948      6500
 4949              	.LASF63:
 4950 02a1 636F6F72 		.ascii	"coord_select\000"
 4950      645F7365 
 4950      6C656374 
 4950      00
 4951              	.LASF106:
 4952 02ae 73657474 		.ascii	"settings\000"
 4952      696E6773 
 4952      00
 4953              	.LASF23:
 4954 02b7 6D61785F 		.ascii	"max_travel\000"
 4954      74726176 
 4954      656C00
 4955              	.LASF17:
 4956 02c2 63686172 		.ascii	"char\000"
 4956      00
 4957              	.LASF75:
 4958 02c7 746F6F6C 		.ascii	"tool_length_offset\000"
 4958      5F6C656E 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 111


 4958      6774685F 
 4958      6F666673 
 4958      657400
 4959              	.LASF31:
 4960 02da 72706D5F 		.ascii	"rpm_max\000"
 4960      6D617800 
 4961              	.LASF101:
 4962 02e2 74617267 		.ascii	"target_r\000"
 4962      65745F72 
 4962      00
 4963              	.LASF53:
 4964 02eb 7370696E 		.ascii	"spindle_speed\000"
 4964      646C655F 
 4964      73706565 
 4964      6400
 4965              	.LASF104:
 4966 02f9 67635F75 		.ascii	"gc_update_pos\000"
 4966      70646174 
 4966      655F706F 
 4966      7300
 4967              	.LASF51:
 4968 0307 7265706F 		.ascii	"report_ovr_counter\000"
 4968      72745F6F 
 4968      76725F63 
 4968      6F756E74 
 4968      657200
 4969              	.LASF81:
 4970 031a 67635F73 		.ascii	"gc_sync_position\000"
 4970      796E635F 
 4970      706F7369 
 4970      74696F6E 
 4970      00
 4971              	.LASF91:
 4972 032b 776F7264 		.ascii	"word_bit\000"
 4972      5F626974 
 4972      00
 4973              	.LASF68:
 4974 0334 67635F76 		.ascii	"gc_values_t\000"
 4974      616C7565 
 4974      735F7400 
 4975              	.LASF49:
 4976 0340 7370696E 		.ascii	"spindle_speed_ovr\000"
 4976      646C655F 
 4976      73706565 
 4976      645F6F76 
 4976      7200
 4977              	.LASF12:
 4978 0352 75696E74 		.ascii	"uint8_t\000"
 4978      385F7400 
 4979              	.LASF103:
 4980 035a 73746174 		.ascii	"status\000"
 4980      757300
 4981              	.LASF76:
 4982 0361 70617273 		.ascii	"parser_state_t\000"
 4982      65725F73 
 4982      74617465 
 4982      5F7400
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 112


 4983              	.LASF90:
 4984 0370 67635F70 		.ascii	"gc_parser_flags\000"
 4984      61727365 
 4984      725F666C 
 4984      61677300 
 4985              	.LASF102:
 4986 0380 64656C74 		.ascii	"delta_r\000"
 4986      615F7200 
 4987              	.LASF9:
 4988 0388 6C6F6E67 		.ascii	"long long int\000"
 4988      206C6F6E 
 4988      6720696E 
 4988      7400
 4989              	.LASF108:
 4990 0396 7379735F 		.ascii	"sys_probe_position\000"
 4990      70726F62 
 4990      655F706F 
 4990      73697469 
 4990      6F6E00
 4991              	.LASF80:
 4992 03a9 67635F69 		.ascii	"gc_init\000"
 4992      6E697400 
 4993              	.LASF73:
 4994 03b1 636F6F72 		.ascii	"coord_system\000"
 4994      645F7379 
 4994      7374656D 
 4994      00
 4995              	.LASF20:
 4996 03be 73746570 		.ascii	"steps_per_mm\000"
 4996      735F7065 
 4996      725F6D6D 
 4996      00
 4997              	.LASF71:
 4998 03cb 6C696E65 		.ascii	"line_number\000"
 4998      5F6E756D 
 4998      62657200 
 4999              	.LASF114:
 5000 03d7 67635F73 		.ascii	"gc_state\000"
 5000      74617465 
 5000      00
 5001              	.LASF78:
 5002 03e0 76616C75 		.ascii	"values\000"
 5002      657300
 5003              	.LASF107:
 5004 03e7 7379735F 		.ascii	"sys_position\000"
 5004      706F7369 
 5004      74696F6E 
 5004      00
 5005              	.LASF119:
 5006 03f4 67635F65 		.ascii	"gc_execute_line\000"
 5006      78656375 
 5006      74655F6C 
 5006      696E6500 
 5007              	.LASF77:
 5008 0404 6E6F6E5F 		.ascii	"non_modal_command\000"
 5008      6D6F6461 
 5008      6C5F636F 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 113


 5008      6D6D616E 
 5008      6400
 5009              	.LASF25:
 5010 0416 73746570 		.ascii	"step_invert_mask\000"
 5010      5F696E76 
 5010      6572745F 
 5010      6D61736B 
 5010      00
 5011              	.LASF18:
 5012 0427 6C6F6E67 		.ascii	"long double\000"
 5012      20646F75 
 5012      626C6500 
 5013              	.LASF13:
 5014 0433 75696E74 		.ascii	"uint16_t\000"
 5014      31365F74 
 5014      00
 5015              	.LASF21:
 5016 043c 6D61785F 		.ascii	"max_rate\000"
 5016      72617465 
 5016      00
 5017              	.LASF112:
 5018 0445 7379735F 		.ascii	"sys_rt_exec_motion_override\000"
 5018      72745F65 
 5018      7865635F 
 5018      6D6F7469 
 5018      6F6E5F6F 
 5019              	.LASF44:
 5020 0461 73746570 		.ascii	"step_control\000"
 5020      5F636F6E 
 5020      74726F6C 
 5020      00
 5021              	.LASF2:
 5022 046e 73686F72 		.ascii	"short int\000"
 5022      7420696E 
 5022      7400
 5023              	.LASF7:
 5024 0478 6C6F6E67 		.ascii	"long int\000"
 5024      20696E74 
 5024      00
 5025              	.LASF105:
 5026 0481 49544D5F 		.ascii	"ITM_RxBuffer\000"
 5026      52784275 
 5026      66666572 
 5026      00
 5027              	.LASF54:
 5028 048e 73797374 		.ascii	"system_t\000"
 5028      656D5F74 
 5028      00
 5029              	.LASF55:
 5030 0497 66656564 		.ascii	"feed_rate\000"
 5030      5F726174 
 5030      6500
 5031              	.LASF52:
 5032 04a1 7265706F 		.ascii	"report_wco_counter\000"
 5032      72745F77 
 5032      636F5F63 
 5032      6F756E74 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 114


 5032      657200
 5033              	.LASF95:
 5034 04b4 696E745F 		.ascii	"int_value\000"
 5034      76616C75 
 5034      6500
 5035              	.LASF88:
 5036 04be 636F6D6D 		.ascii	"command_words\000"
 5036      616E645F 
 5036      776F7264 
 5036      7300
 5037              	.LASF43:
 5038 04cc 736F6674 		.ascii	"soft_limit\000"
 5038      5F6C696D 
 5038      697400
 5039              	.LASF3:
 5040 04d7 5F5F7569 		.ascii	"__uint8_t\000"
 5040      6E74385F 
 5040      7400
 5041              	.LASF45:
 5042 04e1 70726F62 		.ascii	"probe_succeeded\000"
 5042      655F7375 
 5042      63636565 
 5042      64656400 
 5043              	.LASF113:
 5044 04f1 7379735F 		.ascii	"sys_rt_exec_accessory_override\000"
 5044      72745F65 
 5044      7865635F 
 5044      61636365 
 5044      73736F72 
 5045              	.LASF97:
 5046 0510 626C6F63 		.ascii	"block_coord_system\000"
 5046      6B5F636F 
 5046      6F72645F 
 5046      73797374 
 5046      656D00
 5047              	.LASF79:
 5048 0523 70617273 		.ascii	"parser_block_t\000"
 5048      65725F62 
 5048      6C6F636B 
 5048      5F7400
 5049              	.LASF58:
 5050 0532 6D6F7469 		.ascii	"motion\000"
 5050      6F6E00
 5051              	.LASF19:
 5052 0539 73697A65 		.ascii	"sizetype\000"
 5052      74797065 
 5052      00
 5053              	.LASF8:
 5054 0542 6C6F6E67 		.ascii	"long unsigned int\000"
 5054      20756E73 
 5054      69676E65 
 5054      6420696E 
 5054      7400
 5055              	.LASF14:
 5056 0554 696E7433 		.ascii	"int32_t\000"
 5056      325F7400 
 5057              	.LASF74:
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 115


 5058 055c 636F6F72 		.ascii	"coord_offset\000"
 5058      645F6F66 
 5058      66736574 
 5058      00
 5059              	.LASF83:
 5060 0569 61786973 		.ascii	"axis_0\000"
 5060      5F3000
 5061              	.LASF84:
 5062 0570 61786973 		.ascii	"axis_1\000"
 5062      5F3100
 5063              	.LASF98:
 5064 0577 706C616E 		.ascii	"plan_data\000"
 5064      5F646174 
 5064      6100
 5065              	.LASF1:
 5066 0581 756E7369 		.ascii	"unsigned char\000"
 5066      676E6564 
 5066      20636861 
 5066      7200
 5067              	.LASF120:
 5068 058f 6C696E65 		.ascii	"line\000"
 5068      00
 5069              	.LASF40:
 5070 0594 73746174 		.ascii	"state\000"
 5070      6500
 5071              	.LASF111:
 5072 059a 7379735F 		.ascii	"sys_rt_exec_alarm\000"
 5072      72745F65 
 5072      7865635F 
 5072      616C6172 
 5072      6D00
 5073              	.LASF67:
 5074 05ac 67635F6D 		.ascii	"gc_modal_t\000"
 5074      6F64616C 
 5074      5F7400
 5075              	.LASF82:
 5076 05b7 61786973 		.ascii	"axis_command\000"
 5076      5F636F6D 
 5076      6D616E64 
 5076      00
 5077              	.LASF59:
 5078 05c4 756E6974 		.ascii	"units\000"
 5078      7300
 5079              	.LASF0:
 5080 05ca 7369676E 		.ascii	"signed char\000"
 5080      65642063 
 5080      68617200 
 5081              	.LASF37:
 5082 05d6 686F6D69 		.ascii	"homing_debounce_delay\000"
 5082      6E675F64 
 5082      65626F75 
 5082      6E63655F 
 5082      64656C61 
 5083              	.LASF5:
 5084 05ec 73686F72 		.ascii	"short unsigned int\000"
 5084      7420756E 
 5084      7369676E 
ARM GAS  C:\Users\barto\AppData\Local\Temp\ccuyfcgd.s 			page 116


 5084      65642069 
 5084      6E7400
 5085              	.LASF32:
 5086 05ff 72706D5F 		.ascii	"rpm_min\000"
 5086      6D696E00 
 5087              	.LASF39:
 5088 0607 73657474 		.ascii	"settings_t\000"
 5088      696E6773 
 5088      5F7400
 5089              	.LASF100:
 5090 0612 685F7832 		.ascii	"h_x2_div_d\000"
 5090      5F646976 
 5090      5F6400
 5091              	.LASF86:
 5092 061d 61786973 		.ascii	"axis_words\000"
 5092      5F776F72 
 5092      647300
 5093              	.LASF16:
 5094 0628 646F7562 		.ascii	"double\000"
 5094      6C6500
 5095              	.LASF34:
 5096 062f 686F6D69 		.ascii	"homing_dir_mask\000"
 5096      6E675F64 
 5096      69725F6D 
 5096      61736B00 
 5097              	.LASF29:
 5098 063f 6A756E63 		.ascii	"junction_deviation\000"
 5098      74696F6E 
 5098      5F646576 
 5098      69617469 
 5098      6F6E00
 5099              	.LASF46:
 5100 0652 686F6D69 		.ascii	"homing_axis_lock\000"
 5100      6E675F61 
 5100      7869735F 
 5100      6C6F636B 
 5100      00
 5101              	.LASF56:
 5102 0663 636F6E64 		.ascii	"condition\000"
 5102      6974696F 
 5102      6E00
 5103              	.LASF92:
 5104 066d 63686172 		.ascii	"char_counter\000"
 5104      5F636F75 
 5104      6E746572 
 5104      00
 5105              	.LASF72:
 5106 067a 706F7369 		.ascii	"position\000"
 5106      74696F6E 
 5106      00
 5107              	.LASF26:
 5108 0683 6469725F 		.ascii	"dir_invert_mask\000"
 5108      696E7665 
 5108      72745F6D 
 5108      61736B00 
 5109              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
